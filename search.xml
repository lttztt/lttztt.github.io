<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>css动画剖析</title>
      <link href="/2019/09/14/css-animation-dissect/"/>
      <url>/2019/09/14/css-animation-dissect/</url>
      
        <content type="html"><![CDATA[<h1 id="CSS动画剖析"><a href="#CSS动画剖析" class="headerlink" title="CSS动画剖析"></a>CSS动画剖析</h1><h2 id="动画的原理"><a href="#动画的原理" class="headerlink" title="动画的原理"></a>动画的原理</h2><p>静止的画面以一定的速率连续改变，导致眼球出现视觉残影的错觉，就形成了动画。</p><h2 id="前端如何做动画"><a href="#前端如何做动画" class="headerlink" title="前端如何做动画"></a>前端如何做动画</h2><ol><li>使用js控制元素的Left定位，用计时器快速移动元素</li><li>用transfrom</li></ol><blockquote><p>总结就是：用transfrom的性能好</p></blockquote><h2 id="理解transform"><a href="#理解transform" class="headerlink" title="理解transform"></a>理解transform</h2><blockquote><p>转换的意思，在浏览器渲染是会自动补充动画过程</p></blockquote><h2 id="浏览器的渲染过程"><a href="#浏览器的渲染过程" class="headerlink" title="浏览器的渲染过程"></a>浏览器的渲染过程</h2><p><strong>步骤</strong></p><ul><li>根据HTML构建HTML数（DOM）</li><li>根据CSS构建CSS树（CSSOM）</li><li>将上面的两个数合并成一个渲染树（render tree）</li><li>Layout布局（文档流、盒模型、计算大小和位置）</li><li>Paint绘制（把边框颜色、字体大小、阴影等画出来）</li><li>Compose合成（根据层叠关系展示画面）</li></ul><p><img src="/images/3trees.png" alt="three-tree"></p><h3 id="如何更新样式"><a href="#如何更新样式" class="headerlink" title="如何更新样式"></a>如何更新样式</h3><p><strong>一般我们使用JS来更新样式</strong></p><ul><li>如：div.style.background = ‘red’</li><li>如：div.style.display = ‘none’</li><li>如：div.classList.add(‘red’)</li><li>如：div.remove() 直接删掉节点</li></ul><h3 id="3种更新方式"><a href="#3种更新方式" class="headerlink" title="3种更新方式"></a>3种更新方式</h3><p><img src="/images/3renders.png" alt="3render"></p><p><strong>第一种：全走</strong></p><p>对应：<a href="http://js.jirengu.com/jagel/1/edit?html,css,js,output" target="_blank" rel="noopener">div.remove()</a>，当前元素消失，其他元素relayout</p><p><strong>第二种：跳过layout</strong></p><p>对应：<a href="http://js.jirengu.com/jidam/1/edit?html,css,js,output" target="_blank" rel="noopener">改变背景颜色</a>，直接replaint + composite</p><p><strong>第三种：跳过layout和paint</strong></p><p>对应：<a href="http://js.jirengu.com/wusew/1" target="_blank" rel="noopener">改变transform</a>，只需composite</p><blockquote><p>注意查看时需要开启chrome的paint flashing</p></blockquote><p>如果不想自己一个一个属性触发那个更新方式，可以参考<a href="https://csstriggers.com/" target="_blank" rel="noopener">csstrigger.com</a></p><h2 id="CSS动画优化"><a href="#CSS动画优化" class="headerlink" title="CSS动画优化"></a>CSS动画优化</h2><p>具体参考 google 的<a href="https://developers.google.com/web/fundamentals/performance/rendering/stick-to-compositor-only-properties-and-manage-layer-count" target="_blank" rel="noopener">文章</a></p><h3 id="JS优化"><a href="#JS优化" class="headerlink" title="JS优化"></a>JS优化</h3><p>使用requestAnimationFrame代替setTimeout或setInterval</p><h3 id="CSS优化"><a href="#CSS优化" class="headerlink" title="CSS优化"></a>CSS优化</h3><p>使用 will-change 和 transform的translate</p><h2 id="chrome调试-paint-flashing"><a href="#chrome调试-paint-flashing" class="headerlink" title="chrome调试-paint flashing"></a>chrome调试-paint flashing</h2><p>打开开发者工具后，点击三个点更多找到moreTools里的rendering，开启paint flashing。</p><p>效果是： 页面上所有被重绘的块会被高亮的显示（绿色）</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用npm-ci</title>
      <link href="/2019/08/26/use-npm-ci/"/>
      <url>/2019/08/26/use-npm-ci/</url>
      
        <content type="html"><![CDATA[<h1 id="npm-ci"><a href="#npm-ci" class="headerlink" title="npm-ci"></a>npm-ci</h1><p>这是一个 npm 命令, 可以用来完全保持 packjson-lock的版本来install依赖.</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>确保你拥有 packjson-lock.json 和 最新的 npm 安装(up-to-date install)</p><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><p>这个命令类似于 npm-install, 它比常规的 npm 安装块的多, 也更加的严格. 它可以帮助捕获由大多数npm用户的增量安装的本地环境引起的错误或不一致</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用<code>npm install</code>和之间的主要区别<code>npm ci</code>是：</p><ul><li>该项目<strong>必须</strong>有一个<code>package-lock.json</code>或<code>npm-shrinkwrap.json</code>。</li><li>如果程序包锁中的依赖项与其中的依赖项不匹配<code>package.json</code>，<code>npm ci</code>则将退出并显示错误，而不是更新程序包锁。</li><li><code>npm ci</code> 只能一次安装整个项目：使用此命令无法添加单个依赖项。</li><li>如果a <code>node_modules</code>已经存在，它将在<code>npm ci</code>开始安装之前自动删除。</li><li>它永远不会写入<code>package.json</code>或任何包锁：安装基本上是冻结的。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> npm </tag>
            
            <tag> Nodejs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原生JS轮播实现总结</title>
      <link href="/2019/08/12/JavaScript-wheel-carousel/"/>
      <url>/2019/08/12/JavaScript-wheel-carousel/</url>
      
        <content type="html"><![CDATA[<h2 id="造一个轮播的轮子"><a href="#造一个轮播的轮子" class="headerlink" title="造一个轮播的轮子"></a>造一个轮播的轮子</h2><p>文章分三个步骤。 第一步， 实现基本功能； 第二步，考虑代码的封装性和复用性； 第三步，考虑到代码的拓展性。</p><h3 id="实现基本功能"><a href="#实现基本功能" class="headerlink" title="实现基本功能"></a>实现基本功能</h3><p>完整js代码是对应 <code>main.js</code></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>carousel<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>panels<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/1.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/2.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/3.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>img/4.jpg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>action<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pre<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>上一个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>next<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>下一个<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dots<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>active<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//让document.querySelector 用起来更方便      </span><span class="token keyword">const</span> $ <span class="token operator">=</span> s <span class="token operator">=</span><span class="token operator">></span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">const</span> $$ <span class="token operator">=</span> s <span class="token operator">=</span><span class="token operator">></span> document<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">const</span> dotCt <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.carousel .dots'</span><span class="token punctuation">)</span><span class="token keyword">const</span> preBtn <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.carousel .pre'</span><span class="token punctuation">)</span><span class="token keyword">const</span> nextBtn <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.carousel .next'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//把类数组对象转换为数组，便于之后使用数组方法</span><span class="token comment" spellcheck="true">//这里对应的是包含图片面板的数组</span><span class="token keyword">const</span> panels <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span><span class="token string">'.carousel .panels > a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//这里对应的是包含小圆点的数组</span><span class="token keyword">const</span> dots <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token function">$$</span><span class="token punctuation">(</span><span class="token string">'.carousel .dots span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//要展示第几页，就先把所有页的z-index设置为0，再把要展示的页面z-index设置为10</span><span class="token keyword">const</span> showPage <span class="token operator">=</span> pageIndex <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  panels<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>panel <span class="token operator">=</span><span class="token operator">></span> panel<span class="token punctuation">.</span>style<span class="token punctuation">.</span>zIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">)</span>  panels<span class="token punctuation">[</span>pageIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>zIndex <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">}</span><span class="token keyword">const</span> setDots <span class="token operator">=</span> pageIndex <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  dots<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>dot <span class="token operator">=</span><span class="token operator">></span> dot<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  dots<span class="token punctuation">[</span>pageIndex<span class="token punctuation">]</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span>   <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//根据第几个小点上有active的类来判断在第几页</span><span class="token keyword">const</span> getIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> dots<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'.carousel .dots .active'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">const</span> getPreIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> dots<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">%</span> dots<span class="token punctuation">.</span>length<span class="token keyword">const</span> getNextIndex <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token function">getIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> dots<span class="token punctuation">.</span>lengthdotCt<span class="token punctuation">.</span>onclick <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName <span class="token operator">!==</span> <span class="token string">'SPAN'</span><span class="token punctuation">)</span> <span class="token keyword">return</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> dots<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">)</span>  <span class="token function">setDots</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>  <span class="token function">showPage</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span>preBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">getPreIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">setDots</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>  <span class="token function">showPage</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span>nextBtn<span class="token punctuation">.</span>onclick <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">getNextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  <span class="token function">setDots</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>  <span class="token function">showPage</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>上面的代码使用了原生ES6语法，核心代码逻辑是：当用户点击小圆点，得到小圆点的位置（index），设置小圆点集合的样式，切换到对应的页面。页面（.panels的子元素）使用绝对定位相互重叠到一起，我们通过修改z-index把需要展示的页面放到最上层。</p><h3 id="复用性和封装性"><a href="#复用性和封装性" class="headerlink" title="复用性和封装性"></a>复用性和封装性</h3><p>以上代码可以实现轮播基本功能，但做为意大利面条式的代码，并未做封装，无法给他人使用。另外也无法满足页面上有多个轮播的需求。</p><p>完整js代码是对应 <code>main3.js</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Carousel</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>root<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> root    <span class="token keyword">this</span><span class="token punctuation">.</span>panels <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.panels a'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dots <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token keyword">from</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelectorAll</span><span class="token punctuation">(</span><span class="token string">'.dots span'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dotLength <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dots<span class="token punctuation">.</span>length    <span class="token keyword">this</span><span class="token punctuation">.</span>dotCt <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.dots'</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.action .prev'</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.action .next'</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bindEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token function">index</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dots<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.dots span.active'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token function">nextIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dotLength  <span class="token punctuation">}</span>  <span class="token keyword">get</span> <span class="token function">prevIndex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>index <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dotLength<span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dotLength  <span class="token punctuation">}</span>  <span class="token function">bindEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dotCt<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>      <span class="token keyword">if</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">.</span>tagName <span class="token operator">!==</span> <span class="token string">'SPAN'</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>dots<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>target<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDots</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setPanels</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>prev<span class="token punctuation">.</span>onclick <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setPanels</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prevIndex<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDots</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>prevIndex<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>next<span class="token punctuation">.</span>onclick <span class="token operator">=</span> e <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setPanels</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nextIndex<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">setDots</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>nextIndex<span class="token punctuation">)</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">setDots</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dots<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>el<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      el<span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>dots<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>classList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'active'</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token function">setPanels</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>panels<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>el<span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>zIndex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>panels<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span>style<span class="token punctuation">.</span>zIndex <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Carousel</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.carousel'</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>代码里用了getter，便于或者index的值。这里需要注意的是，每次调用setDot后 this.index、this.prevIndex、this.nextIndex均会自动发生变化，调用setPanels的时候需要留意。</p><p>现在轮播可以复用了，但仍有缺憾，轮播的效果太单调。假设轮播想使用fade或者slide效果，我们可以在showPage方法内修改代码。但存在的问题是效果和轮播组件做了强绑定，假设我需要另外一个效果的轮播就得新建一个组件。比如，有这样一个需求，用户可以再切页时可以随时更改效果，用上面的代码就很难办到。</p><p>能不能实现组件和效果的解绑呢？当然可以。</p><h3 id="代码拓展性"><a href="#代码拓展性" class="headerlink" title="代码拓展性"></a>代码拓展性</h3><p>设计模式中的桥接模式可以实现上述的分离。直接给代码完整效果在 <code>main4-animation2.js</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">class</span> <span class="token class-name">Carousel</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> animation<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>animation <span class="token operator">=</span> animation <span class="token operator">||</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> onFinish<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">onFinish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> root    <span class="token operator">...</span>  <span class="token punctuation">}</span>  <span class="token operator">...</span>  <span class="token comment" spellcheck="true">//showPage传递2个参数,toIndex 表示要切换到的页面(终点页面)序号,fromIndex 表示从哪个页面(起始页面)切换过来</span>  <span class="token function">showPage</span><span class="token punctuation">(</span>toIndex<span class="token punctuation">,</span> fromIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//animation函数传递3个参数，分别为终点页面dom元素，起始页面dom元素，动画执行完毕后的回调</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">animation</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>panels<span class="token punctuation">[</span>toIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>panels<span class="token punctuation">[</span>fromIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//这里是动画执行完成后的回调          </span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> Animation <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function">fade</span><span class="token punctuation">(</span>during<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> onFinish<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">//to表示终点页面dom元素，from表示起始页面dom元素</span>      <span class="token comment" spellcheck="true">//对这两个元素进行适当的处理即可实现平滑过渡效果</span>      <span class="token operator">...</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">zoom</span><span class="token punctuation">(</span>scale<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> onFinish<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*todo...*/</span><span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">new</span> <span class="token class-name">Carousel</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'.carousel'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> Animation<span class="token punctuation">.</span><span class="token function">fade</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>上述代码中，我们把动画类型作为参数传递给Carousel，在执行setPage的时候调用动画。 而动画函数本身做的事情比较简单：处理两个绝对定位并且相互重叠的DOM元素，以特定效果让一个元素消失另外一个元素出现。</p><h3 id="动画的实现"><a href="#动画的实现" class="headerlink" title="动画的实现"></a>动画的实现</h3><p>动画可以用JS来实现（requestAnimationFrame来实现动画<code>main4-aimation.js</code>），也可以用CSS3来实现。相比JS实现动画，用CSS3性能更好并且代码更简单。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> Animation <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">const</span> css <span class="token operator">=</span> <span class="token punctuation">(</span>node<span class="token punctuation">,</span> styles<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>styles<span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> node<span class="token punctuation">.</span>style<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">)</span>  <span class="token keyword">const</span> reset <span class="token operator">=</span> node <span class="token operator">=</span><span class="token operator">></span> node<span class="token punctuation">.</span>style <span class="token operator">=</span> <span class="token string">''</span>  <span class="token keyword">return</span> <span class="token punctuation">{</span>    <span class="token function">fade</span><span class="token punctuation">(</span>during <span class="token operator">=</span> <span class="token number">400</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> onFinish<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">css</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>          opacity<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>          transition<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`all </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>during<span class="token operator">/</span><span class="token number">1000</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">s`</span></span><span class="token punctuation">,</span>          zIndex<span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">css</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token punctuation">{</span>          opacity<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          transition<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`all </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>during<span class="token operator">/</span><span class="token number">1000</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">s`</span></span><span class="token punctuation">,</span>          zIndex<span class="token punctuation">:</span> <span class="token number">9</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">css</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            opacity<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>          <span class="token function">css</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token punctuation">{</span>            opacity<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>                      <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">)</span>          <span class="token function">reset</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>          onFinish <span class="token operator">&amp;&amp;</span> <span class="token function">onFinish</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> during<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token function">zoom</span><span class="token punctuation">(</span>scale <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">,</span> during <span class="token operator">=</span> <span class="token number">600</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">,</span> onFinish<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">css</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>          opacity<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>          transform<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`scale(1)`</span></span><span class="token punctuation">,</span>          transition<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`all </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>during<span class="token operator">/</span><span class="token number">1000</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">s`</span></span><span class="token punctuation">,</span>          zIndex<span class="token punctuation">:</span> <span class="token number">10</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">css</span><span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token punctuation">{</span>          zIndex<span class="token punctuation">:</span> <span class="token number">9</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">css</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>            opacity<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span>            transform<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`scale(</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>scale<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">)`</span></span>          <span class="token punctuation">}</span><span class="token punctuation">)</span>                     <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span>        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>          <span class="token function">reset</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">)</span>          <span class="token function">reset</span><span class="token punctuation">(</span>to<span class="token punctuation">)</span>          onFinish <span class="token operator">&amp;&amp;</span> <span class="token function">onFinish</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> during<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><a href="http://js.jirengu.com/cajet" target="_blank" rel="noopener">效果预览</a><br><a href="https://github.com/lttztt/wheel-carousel" target="_blank" rel="noopener">源码github</a></p>]]></content>
      
      
      <categories>
          
          <category> Front-end </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> wheel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webstorm里使用git log中文乱码</title>
      <link href="/2019/02/14/webstorm-gitLog%E4%B9%B1%E7%A0%81/"/>
      <url>/2019/02/14/webstorm-gitLog%E4%B9%B1%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>在webstorm中使用git log一直乱码，使用很不方便，下面是解决方案。<br>找到git 的安装目录，在文件bash.bashrc(windows下在安装目录的/etc)最后两行添加</p><pre><code>export LANG=&quot;zh_CN.UTF-8&quot;export LC_ALL=&quot;zh_CN.UTF-8&quot;</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/duola8789/article/details/80974677" target="_blank" rel="noopener">webstorm中git中文乱码</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是真正的程序员(转)</title>
      <link href="/2019/01/22/the-little-printf/"/>
      <url>/2019/01/22/the-little-printf/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章的原文来自：<a href="http://ferd.ca/the-little-printf.html" target="_blank" rel="noopener">A Little Printf Story</a><br>本文是一篇译文，作者仿照《小王子》中的情节，通过小 printf 遇见的不同类型的程序员，最后悟出什么才是真正的程序员！<br>译文出处 <a href="https://www.cnblogs.com/xueweihan/p/5220513.html" target="_blank" rel="noopener">削微寒</a></p></blockquote><p>文章略长，但是耐心读完，你肯定会受益良多！</p><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><p><em>（推荐看完整篇文章，再回过头看一遍第一章）</em></p><p>我非常幸运出生在一个电脑和电子游戏还没有普遍的时代。所以我可以和我的小伙伴们一起玩耍，同时发明属于我们的游戏。</p><p>我们十分会玩：用树枝做成’🏹️’。我们可以用树枝做出任何东西，除’回旋镖’。因为你把树枝扔出去，你需要自己捡回来。（作者这个故事是活跃气氛吗？😓）</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-4813f12585603909.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="回旋镖"></p><p>当我们长大了，上面说的游戏变得很幼稚。你不能把一个松塔当成一个手榴弹；假装拥有神奇的魔法；当其他孩子觉得作为一个成年人很酷。你最终会迫于压力而长大。不过总的来说这也是一个非常幸运的童年。</p><p>偶然的一次机会我接触了电子游戏和电脑。你可能想沉浸在这个虚拟的世界，这会毁了你。</p><p>大多数电子游戏：你不能创造，只能反应，浪费你的时间。我在十多岁的时候，参加过’即兴表演’。在哪里我可以发挥我的创造性。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-6f07eb77ee8114d0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="即兴表演"></p><p>我大学的专业是’多媒体’，但是我最终却从事’编程’工作。我觉得编程is amazing！我可以发挥我的创造性，同时又可以挣钱！之后我做了我的第一个游戏。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-b4f13aad4f29cd36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="html游戏"></p><p>“这不是一个真正的电子游戏。”别人跟我说：”它只是一个html的表单，而且代码需要简化。”</p><p>这席话使我有一些沮丧，它花费了很多心思和时间。但是，我意识到如果我想做出被人们认可的东西的话，我还需要学习更多知识。</p><p>我需要学习真正的编程。从GUI工具里的JS，转到更好的语言：像PHP。所以我先学习了Js，后来又去学习PHP，但是一切并不是很顺利，其他人给我的建议去试试python。最后，我学习的是python（🎊我也是这样走上python之路的🍻）。</p><p>但是python中高深一些的东西：’lambdas’和’面向对象编程’，让我云里雾里的。后来别人建议我去读一下《计算机程序的构造和解释》，因为它是编程的基础入门圣经。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-70cd873fe5f96213.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="SICP"></p><p>就这样，我知道了Scheme，后来我又去学习C语言。因为大多数的程序员都会C，同时我旁听了我们学校的计算机课程，跟着他们一起学习。因为，真正的程序员都知道数据结构和数学，但是这些我只略懂皮毛。我开始读技术文章和书，因为程序员的知识更新太快。</p><p>经过一段时间，我掌握了Erlang，从而开始了我的职业生涯。（这篇文章的作者写了一本：Erlang入门书）。十分奇怪的是：我这个没有用Erlang做过任何生产级别的开发的人，却得到了一份教Erlang的工作。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><p>所以我忙于到世界各地演讲，教别人（夸夸其谈）。但是，大家似乎都相信我是一个真正的程序员。因为，我讲的这些事情大多都和编程无关。</p><p>一天，我结束了一个会议回家，飞机晚点。我愤怒的敲击着键盘，一个柔弱的声音打断了我：</p><p>“你好，能请你给我设计一个系统吗？”</p><p>我：”什么？”</p><p>“给我设计一个系统！”</p><p>我对这个请求很惊讶。我环视四周，发现一个渴望成为开发者的孩子。他叫’printf’（主角闪亮登场）。我觉得这个名字很傻。他的样子如下图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-d328a8e3730b6ad7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="little printf"></p><p>“我还不是很了解计算机，但是你好像是计算机方面的专家。我希望写一个blog程序，人们可以使用和访问它。求求你帮我设计一个系统！”</p><p>这是个令人惊讶的请求，并且我已经二十多个小时没睡了。我不是完全理解他所说的。我告诉他，做一个系统十分困难。我不知道他想要做什么：需要支持多少访问者；在哪里部署；所以我无法根据他提供的少量信息，设计一个合适的系统。</p><p>“没有关系，给我设计一个系统吧。”</p><p>所以我做了下面这幅结构图：</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-3bf423658d0d1c17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统结构图1"></p><p>他看了之后说：”不，这个系统还不够好。请给我再设计一个别的。”</p><p>所以我又做了下面这个：</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-91aeab889f1e14d8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统结构图2"></p><p>然后我给他讲解这个系统的工作原理。</p><p>我的新朋友 (printf)十分礼貌的说：”这不是我想要的，它又太复杂而且好多东西都是我不需要的。”</p><p>我感到十分不爽，我设计的这个系统考虑到了：冗余、监控、备份、缓存、负载、支付、故障转移、部署简单等等。我设计的这个系统都已经可以获得一份可观的咨询费用了！我已经失去耐心了，所以我就画了这个：</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-8c50190a75c7df23.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="enjoy!"></p><p>我又告诉他：”这是你设计的系统，你要的系统在这个黑盒子里。”我希望这个滑稽的答案，可以打发他。但是他的回复让我十分惊讶：</p><p>“这正是我想要的！”</p><p>这就是我和小printf相识的过程。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><p>过了一段时间，我知道了这个小鬼的编程水平。在他的代码仓库只有些小程序、网站的小demo、琐碎的程序片段。都是些不值得一提的东西。</p><p>之后他开始着手做一个需要很多模块的大型程序。这个程序需要socket、磁盘读写、用到真正的数据库。当它第一次跑起来的时候，小printf十分兴奋。但是，这个程序还不够好。</p><p>这个程序需要重构、更好的测试、文档、分析。它只运行了一段时间就崩溃了。然后一次，又一次的崩溃！</p><p>程序的设置是错误的，日志不工作、磁盘速度不稳定、网络卡顿、有bug、编码混乱、数据库需要清理、证书过期、没有异常处理导致问题找不到根源。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-e34c12b11bcb68b2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="一团糟"></p><p>真的想面条一样一团糟。</p><p>小printf跟我说：”通过这件事，我发现自己简直是一无所知！这个程序本来是根据我的需要写的。我原来的想法太天真了，后来我修复bug的时间和这个程序给我带来的便利根本不成正比！最后，变得跟我原来想的一点都不一样。虽然这样，我仍然认为这件事情让我收获了很多。”</p><p>一天早上，他决定离开我这里。”再见。”小printf跟我做了最后的道别。他想要出去看看世界，看看其他人写的程序。</p><p>小printf写的应用，最后因为不断增加的日志，导致硬盘没有空间，彻底的崩溃了。</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-e75a82604f01575c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="building.png"></p><p>小printf走进了一个办公楼，想寻找有经验的程序员取经，获得一些建议和帮助。</p><p>他遇到一个骄傲的高级程序员，而且自我感觉良好。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-22d27b4803046996.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pro.png"></p><p>傲慢的高级程序员说：”哎，过来新手！欢迎来到我所擅长领域，在这个领域我是专家！”</p><p>“专家？”小printf问到：”专家的意思是：可以编写任何程序吗？”</p><p>“是的！”傲慢的高级程序员回答道，接着他又说：”准确的说，应该是大多数程序。因为我只编写有价值的程序，我不会浪费我的时间在没有意义的小程序上。很多程序我都没有写过，但是他们都难不倒我！”</p><p>“额，所以你可以帮我完善我的程序？”小print问到，之后他开始阐述他的网站系统，但是傲慢的高级程序员打断了他：</p><p>“对不起，我觉得你的网站系统没有一点价值。”</p><p>小printf：”为什么？”</p><p>“经验，我擅长编写我开发的东西，我也只做我擅长的领域的开发。我需要确保我在我的领域的永远有价值。这叫做工作保障，也叫做适者生存。但这就是我的风格。我只专注于我的领域！”</p><p>小printf：”那你为什么不帮我呢？”</p><p>“花费我的时间去帮助你，意味着我需要花费精力去帮助别人，而不是提高自己—-这对我来说不是一个好的主意。我的建议是：自己多努力，自己弄懂。还可以塑造你自己的心性”</p><p>小printf：”你说的方法，好想不是很高效。。。”</p><p>“你可以到学校去学，或者自学。事实上这种方法可以淘汰那些懒惰，只喜欢简单的事情的人。真正渴望知识的人才能成功！”</p><p>小printf：”你认为合作和同事不能帮助你吗？”</p><p>“不，我并不是这个意思。我做好的工作状态是：独立空间，没有让我分心的事。每次我和同事合作的时候，都是一次不好的经历。以往的经验：最好的办法是：把他们的代码拿过来重写。然后就可以了！”</p><p>小printf对这个不喜欢帮助别人的专家感到十分惊讶，不仅如此，他还因人为别人的技术不行而恼火。这个专家眼界是狭隘的，他只关心自己擅长的领域。活在自己的世界里。</p><p>小printf：”我明白了，我想我很庆幸你没有帮助我。”</p><p>“你什么意思？”傲慢的专家问到，貌似他的权威受到了威胁：”你不认可我，你是在质疑我吗？”</p><p>小printf：”并不是这样，就像你觉得我是一个累赘，令人恼怒的一样。我是来寻找帮助的，而不是来找骂的。”</p><p>说完之后，小printf飞快的跑出了傲慢专家的办公室。当小printf离开后，这个专家又重新找回了他所擅长领域的权威，同时自我感觉良好。</p><h2 id="第五章"><a href="#第五章" class="headerlink" title="第五章"></a>第五章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-514dd32080271feb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="books.png"></p><p>然后，小printf又走进了另外一个办公室。里面有一个男士，他的座位周围都是精装厚厚的书籍（例如代码大全这种书）。</p><p>小printf：”先生，你有好多书啊！”</p><p>“是的，我想这些都是程序员必看的书籍，如果你没看过这些，你很难成为’大牛’（专业人士）。”</p><p>小printf：”我想我现在还是很菜，请问这些书里面你最喜欢哪本？”</p><p>“哦，是这样的这些书大多数我还没有读过。”</p><p>小printf：”那你现在是个’大牛’吗？”</p><p>“不，我还不是。”这个程序员很骄傲的说：”我其实是一个很垃圾的程序员。”</p><p>小printf：”这太丢人了，我正在努力变强。”</p><p>“你听过’达克效应’吗？”</p><p>小printf：”那是什么？”</p><p>“简单的说就是：能力强的人总是低估自己，能力弱的人总是高估自己。”</p><p>小printf：”也就是说，如果我觉得自己在变强，其实我并没有变强。”</p><p>“是的，你说的非常正确。你很可能在原地踏步。另一方面，我宣扬我是一个很糟糕的程序员，但根据’达克效应’。我是低估了我自己，所以我是一个好的程序员，你怎么看？”</p><p>小printf：”我。。。额”</p><p>“这就是为什么程序员都喜欢自嘲（称自己是码农也算吧？）。当你认为你足够好了，你就放松了，也就没有前进的动力。”（这句话我还是很赞同的👍）</p><p>小printf：”你的意思是：一旦自我感觉良好，也就是正在走向失败，因该时刻觉得自己还不够好。”</p><p>“是的，但是用着这种方式应对所有的事很危险，如果你还没有拿到offer。这种方式会让你显的聪明，但是没有任何实际用途，别人不会因为你显的聪明就雇佣你。”</p><p>小printf：”你的意思是？”</p><p>“比方说：我在网上看到一个我不喜欢的项目。我留言说项目一无是处，但是不明确的指出哪里不好。最后你还可以说这个项目的作者是笨蛋，也没有人管你。”</p><p>小printf：”但是这样做有什么好处呢？”</p><p>“我想让他们知道他们走上歧途了，却又不明确的指出来。这表现的我比他们厉害。然而他们毫无头绪，像雾里看花。没有人能明白我的意思。哇咔咔”</p><p>小printf：”当别人请教你的问题，你不会的时候，你会怎么办？”</p><p>“这种情况下你就说到处都是问题，还有很多的不完善的事情要做，总之就是转移话题。然他们感觉绝望，最后还是要他们自己解决。”</p><p>小printf：”所以这就是你的立场？这是你的一贯作风？你会的问题装作对此无能为力，使得真正无法解决这个问题的人抓狂；当你遇到不会的问题时，你装作很了解，使得别人根据你的建议改善其它的地方，而与真理相行渐远，浪费时间”</p><p>“很多情况下，才能不是最重要的。但口碑很重要。人们雇佣朋友，不被喜欢的人和无关紧要的人会被第一个被炒鱿鱼（😤MLGB）。要不就改变环境，改不了就要适应，适应不了就被淘汰。这就是’社会’。企业中就是这样，学术届没准也是。做这行，你认识谁，学会推销自己，建立自己的声望。这样你才能在企业里站住脚。”</p><p>小printf：”如果在企业中工作是这么恶心，要给别人’使绊’。那么我真不想在这种环境下工作！（黑暗的办公室政治，还好我还没有遇到🙊）”</p><h2 id="第六章"><a href="#第六章" class="headerlink" title="第六章"></a>第六章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-e6af8b89ad81fbc5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="realprog.png"></p><p>到了吃午饭的时间，小printf打断了一个貌似忘记吃午饭的人。他桌子上的三明治已经凉了，但是他还是坐在桌子前面盯着他的屏幕。</p><p>他好像十分的忙，但是没人知道他在做什么。</p><p>小printf：”如果主数据库挂掉了，从数据库也会挂掉吗？”（创建主从数据库是为了减少DOWN机时间，让数据库可以一直处于工作状态中）</p><p>“你运行的所有东西，或早或晚都会挂掉。”</p><p>小printf：”你以往的经历告诉你这一切都会失败？”</p><p>“是的，不仅如此。所有的大系统，都会在特定的时间出现问题。”（就像千年虫问题？🤔）</p><p>小printf：”那么，做一个可靠的系统，都需要做什么？”</p><p>那个人忙于他自己的事情，没有理会小printf。</p><p>小printf又问了一次：”做一个可靠的系统，都需要做什么？”</p><p>那个人正在尝试解决产品中的一个问题，但是小printf还一直问个不停，同时他还没有吃午饭。</p><p>所以他不耐烦甚至粗鲁的吼道：”这根本不可能，编程就是shit💩。”</p><p>小printf倒吸了一口气，半天说不出一句话。</p><p><img src="https://upload-images.jianshu.io/upload_images/2986900-0dffdfea3a86c118.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="trashcan.png"></p><p>小printf💢愤怒的回击道：”我不相信你说的。程序是脆弱的没错，但是程序员可以改善这一点，同时做出更好和有用的东西”</p><p>那个人没有任何回答，他在翻阅文档，尝试重新启动一个新的集群，但是情况却越来越糟糕。</p><p>小printf：”并且你应该相信有好的可靠的程。。”</p><p>“不可能”那个人打断了小printf，接着说道：”我不相信有可靠或者好的的程序！根本不可能！这是我的第一个感觉，因为我正在处理一个垃圾的系统。你没看见我想法设法地让这个东西跑起来吗？事实如此！”</p><p>小printf很震惊的看着他说道：”事实如此？说的好像自己是个专家！是你自己把一切都搞的很糟糕。这世界上有上百万的和久经考验的程序，它们也有bug，也崩溃。但是人们还是需要它们，使用它们。据我所知很多程序是没有问题的。出现问题的原因大多是因为电脑的环境配置问题，或者一个错误的操作造成的。你不认为这才是问题的所在吗？”</p><p>那个人听完哑口无言。</p><h2 id="第七章"><a href="#第七章" class="headerlink" title="第七章"></a>第七章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-fed8b5053bc6ec91.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="frameworks.png"></p><p>小printf来到了第四个地方，遇到了一个人，他的电脑几乎被便签盖满了，没有人知道他在干什么。</p><p>“motor-mvc, quadrangular JS, GoQuery, cometeor, some japanese soundy thing, …”</p><p>小printf打断了他的自言自语说道：”你好，你在干什么？”</p><p>“alchemist, bongodb, mochascript, walktime.js, portasql, …”，哪个男士继续自言自语</p><p>小printf提高了音量又问了一次：”你在干什么？”</p><p>“哦，我正在尝试新的框架，工具和语言。”</p><p>小printf：”哇，你接触的东西好新鲜啊！大多数人还都没有听说过这些。”</p><p>“是的，这个行业跟新很快！”他看了一眼他的手机接着又说到：”看，cardboard.io框架又推出了3.5版本，它宣布不兼容3.4了。于此同时社区中已经有4个衍生版本了。我必须从他们之中挑一个。”</p><p>小printf：”你这么做为了什么？”</p><p>“我是最早的尝鲜者，如果你不保持更新技能树，还是用老掉牙的：COBOL或者MUMPS（两门老掉牙的编程语言🤖）。你还想抓住成功的契机，抢占先机，乘势而起？”</p><p>小printf：”你成功的预测过以后的热门技术吗？”</p><p>“是的！我发现Rails的时候它还很小，我学会Node.js的时候它还没有流行。我是redis，mongodb和riak的内测用户。我是第一批试用vagrant的用户，然后我转去使用docker，但是现在我全身心的关注unikernels。。”</p><p>小printf：”太酷了！你是第一批试用这些的技术的人，你从中得到了什么回报？”</p><p>“额，并没有。当Rails壮大的时候，我就去关注另外的新鲜东西了。同样的，其他的几门技术我也是这样的（他不独宠一个，而是雨露均沾🙈）。我现在把希望寄托在unikernels上。”</p><p>小printf沉思了一会说到：”你用这些框架和工具都解决了什么问题？”</p><p>“我每次都确保不使用不成熟的东西，因为不能用公司做赌注。这一点十分重要，因为如果你使用最新的技术，你就可能招不到人，而不关注新的技术，有可能脱离时代的步伐。所以我们鼓励学习新的技术。”</p><p>小printf：”这非常有趣。”</p><p>“在这个飞速发展的世界中，如果你想参加这场游戏，你需要有先进的技术。否则你就会被时代淘汰，没有人想被时代淘汰。”</p><p>小printf：”不，你误解我的意思了，我的意思是：好的工具是为了解决问题而被制造出来的。但是你却盲目追求新的技术，而不是为了什么实际的目的。”</p><p>听完这些话，哪个人呆住了，小printf跳跃着离开了这个房间。</p><h2 id="第八章"><a href="#第八章" class="headerlink" title="第八章"></a>第八章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-2e6174544c8dac8d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="ops.png"></p><p>小printf来到了下一个办公室，这里又一个疲惫的女员工。桌子上杂乱无章，整个人无精打采，疯狂的打字。</p><p>小printf：”你好。”</p><p>这个女士没有停下了她的手头工作，继续疯狂的打字。</p><p>小printf又打了一遍招呼：”你好？”</p><p>女士这次停下了，拿起一瓶咖啡猛灌了一口。</p><p>“我有一份十分糟糕的工作。”她说：”我是devops（开发，运维，测试于一体的职位）。刚开始的时候还好，原来我大多数时间进行开发，然后抽出一些时间修复bug。但是，情况变的越来越糟糕，bug开始接连不断。为了摆脱这种情况，同时在规定时间内完成。我不得不使用一些’奇技淫巧’。”</p><p>小printf：”你为什么不顾人来帮你？”</p><p>“我很擅长做这些事情。我已经习惯这一切都在我的的掌控之下。还有因为他们已经习惯我可以hold一切，如果我提出我自己无法继续掌控全局的以后，他们很容易认为我在偷懒。”</p><p>小printf：”这真是叫人悲伤的故事。”</p><p>“事实就是这样子。因为你是最熟悉这些问题（bug🔥）的人，你只能变的越来越累，直到你的boss招了一个人顶替你原来的工作，这是唯一出路。但如果你担心其他人修改你写的东西时候遇到问题，你只能帮助别人改一个又一个的bug，当然这些都是你讨厌的事情。直到你对这一切感到麻木。”</p><p>小printf：”你真不幸。”</p><p>这位女士又被叫去工作了。</p><p>小printf自言自语道：”这个女人会被我原来遇到的那些人嘲笑的：那个高级专家（只专注于自己擅长的领域），摇滚开发者（过分追求新技术的人），故做高深的程序员（那个周围都是大头书的装X程序员）。尽管他是这些人里面唯一乐于助人的。或许是因为，她认为一切事情还是亲力亲为的好。”</p><h2 id="第九章"><a href="#第九章" class="headerlink" title="第九章"></a>第九章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-a21f954c630281cd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="architect.png"></p><p>小printf发现在这栋大楼里发现了一个有着巨大落地窗并且宽敞的办公室。这里坐着一个德国老头，他面前堆了一堆的文件。</p><p>“啊！来了一个开发者。”德国老头惊呼道同时招呼小printf说：”快进来！”</p><p>小printf环视四周的窗户，发现上面写满了东西。上面画了各种圆圈，箭头，圆柱和云彩（就是图片中玻璃上的图形）。真是搞不懂这个老头画这些东西有什么用。</p><p>小printf：”窗户上的都是些什么？”</p><p>“哦，这些？这是我们的线上系统！”那个老头随口说到：”我是一个软件架构师。”</p><p>小printf：”什么是软件架构师？”</p><p>“总的来说，就是知道如何构建大型系统并且让系统中的每个部分都非常稳定的人。架构师还会数据库，编程语言，框架，编写程序，协议，封装和降低耦合等知识。”</p><p>小printf：”听起来都叫人兴奋！终于有人能回答我的所有问题了！”小printf瞥了一眼玻璃上的结构图说到：”你们的系统真大，他跑的快吗？”</p><p>“我没法告诉你。”架构师说；”应该会很快吧。”</p><p>小printf：”那它的代码怎么样呢？”</p><p>“我没法告诉你。”</p><p>小printf：”用户喜欢这个系统吗？”</p><p>“这个我恐怕也没法告诉你。”</p><p>小printf：”但是你是软件架构师啊！”</p><p>“我的确是架构师，但是我不是开发者。架构师不做，例如：功能模块，类，整合lib等。这种工作的。架构师最重要的不是写代码。他是指引程序员和开发者的人。如果遇到棘手的，无法解决的问题，架构师才会接手。”</p><p>小printf：”这是为什么呢？”</p><p>“因为我们经验十足。我们了解系统并且能解决它的一切问题。开发者可以根据我们的经验和指导，开发出好的系统。”</p><p>小printf：”但是你不写，不看代码怎么知道这将是个好的系统？”</p><p>“我们相信开发者。”</p><p>小printf：”所以，所你们相信开发者们可以正确的实现你们的想法，但是开发者们没有机会提出他们自己的想法？”</p><p>这个软件架构师明显的愣了一下：”我想。。。”他最终承认了：”你刚才提出的这个问题，其实工作中很多的提议是没有被证实，或者实验的。。。”他停顿，并沉思了一下说道：”有些时候软件架构师看起来既不是软件工程师，也不是架构师（是老师？）。”</p><p>小printf离开了这个房间，结束了他的旅行。走出了这栋楼</p><h2 id="第十章"><a href="#第十章" class="headerlink" title="第十章"></a>第十章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-b4b022ace0fca013.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="charity.png"></p><p>小printf走到外边，发现了一个为慈善机构募集钱的男士。</p><p>“你好”那个男士说道：”你觉得帮助一些需要帮助的人的感觉怎么样？”</p><p>小printf：”那样可能会让我感觉更好，我在那栋建筑（遇到了各种各样的程序员的大楼）呆了一整天，寻求帮助。但是现在，我感觉比以前更加迷惑了。”</p><p>“嗯，我帮你分析下：那些人都是开发者，他们并没有真正帮到你是吗？他们喜欢说”程序员改变世界”，实时也是这样的。”</p><p>小printf：”那为什么我却毫无收获呢？”</p><p>“是这样的，他们最擅长做的事情是帮助把人们的工作变成程序，使人们变的轻松。软件正在吞噬整个世界，使世界改革换面。但是事实上还这还是个旧的世界。因为以这种方式的改变，并不意味着事情变好。我们还是有些根深蒂固的问题（例如：思想的问题，或是缺乏创造性。）。”</p><p>小printf焦急的说：”怎么做才能让我感觉更好？”</p><p>那个难事深思了一会，最后提出让小printf帮助他，为需要帮助的人募捐。因为这个男士认为这种方式可以让他感觉更好。用一下午的时间，小printf把他的问题和他的经历都告诉了这个男士。</p><p>这个男士沉思了很长时间说道：”在个游戏中，他们从解决复杂的问题而得到快乐和他们看重的名声和身份，这种快乐是片刻的。因为最终，如果你解决的问题没有实际价值（为了解决问题而解决问题），忽略了’以人为本’。那么你永远不会的到真正的满足！”（说的真好！）</p><p>他接着又说：”随着你的成长，可能找到一家比之前更好的单位。可能是钱多，或者是因为这个工作更趣，这都很正常。只要你知道你自己想要的是什么！”</p><p>他最后补充道：”最后，当你解决了人们真正面临的问题的时候，你会觉得真正的满足！有的时候根本不需要计算机。”</p><p>“你花费了大量的时间在你的系统上。最重要的是：你忘记当初为什么创建这个系统，反而花费时间在优化系统上面，那么它就变成了一场炫耀的游戏。这才是最可悲的。”</p><p>“开发者经常忘记最开始的初衷（真正有意义的事情）。如果你失去做这件事意义，而是为了解决系统的问题，才花时间在这上面。这就是问题的所在（如果你只是为了做好的系统，而不是解决实际问题，那你就应该自我反思了）”</p><p>小printf不断重复这句话，想要印在脑子里：”只有在解决人们真正面对的问题的时候，才能获得真正的满足！”</p><h2 id="第十一章"><a href="#第十一章" class="headerlink" title="第十一章"></a>第十一章</h2><p><img src="https://upload-images.jianshu.io/upload_images/2986900-8f3efb7c3a53582e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="printf-end.png"></p><p>小printf坐在我的前面，和他聊天让我开始认真思考：我为什么走上编程的道路。小printf之前遇到的每个人，仿佛我将来的某一天会成为他们中的一员（这真是个悲伤的情景）。我被这样的人（小printf之前遇到的那些程序员）鼓励成为像他们一样的程序员。</p><p>我也被拖进，小printf不喜欢的那个，成为’真正程序员’的游戏中。小printf曾说过：相比于’真正的程序员’，我更想成为能够为人们解决真正需要解决的问题的程序员（解决真正问题的程序员，而不是解决编程问题的程序员）。</p><p>今天我呆坐在这里，回顾我的整个编程生涯，我想弄清：成为解决真正问题的程序员，还是一切都这是完成工作。这两者是完全不同的。</p><p>不管怎么样，小printf认为他不需要成为一个真正的程序员。我现在，也是这样认为的！</p><h2 id="我的感受"><a href="#我的感受" class="headerlink" title="我的感受"></a>我的感受</h2><p>翻译完这篇文章，我觉得这篇文章写的非常好，他让我意识到：编程为了什么？到底什么才是真正的程序员。</p><p>自我反思了下。我一只在忙于追求技术栈的数量，一直是为了追求技术（或者说工作）而学习。</p><p>这就好像，我毫无目的收集树枝，猛然的一个点。我低头看手边一困困的树枝，却忘记了我为什么要去捡树枝。我学习python中的框架就是这种感觉，为了工作，我学习flask，bottle，tornado框架。但是，一切都是为了工作。导致我想从零写一个web app都毫无头绪，不知道如何下手。</p><p>对于以后的编程之路：我以后应该以目的为驱动力，不盲目的追求技术。经常问自己，我这么做有什么意义。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Reprint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>f 和 fzf 之类的目录跳转记录</title>
      <link href="/2019/01/05/finder-jumpByz-fzf/"/>
      <url>/2019/01/05/finder-jumpByz-fzf/</url>
      
        <content type="html"><![CDATA[<h2 id="工具下载地址"><a href="#工具下载地址" class="headerlink" title="工具下载地址"></a>工具下载地址</h2><ul><li><a href="https://github.com/liuzheGit/z" target="_blank" rel="noopener">z</a></li><li><a href="https://github.com/junegunn/fzf#installation" target="_blank" rel="noopener">fzf</a><ul><li>windows下 <a href="https://github.com/junegunn/fzf-bin/releases" target="_blank" rel="noopener">fzf</a> 下载 <code>fzf-0.17.4-windows_amd64.zip</code></li><li>windows 安装步骤 <a href="https://github.com/jesse23/with#installation" target="_blank" rel="noopener">installation</a></li></ul></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><h3 id="z"><a href="#z" class="headerlink" title="z"></a>z</h3><ol><li>下载 z.sh 到一个你不经常改动的文件夹内. 我习惯放在 <code>~/repos/workanywhere</code>中 ,然后到你的<code>zshrc</code>或<code>bashrc</code>文件中添加 <code>source ~/repos/workanywhere/z.sh</code>(source的路径是你的文件路径)</li><li>在终端中 <code>source ~/.zshrc</code> </li><li>之后就可以使用 <code>z</code> + 文件夹名 跳转到你去过的文件夹中.</li><li>如果跳转的目录不符合要求就需要用到下一个工具</li></ol><h3 id="fzf"><a href="#fzf" class="headerlink" title="fzf"></a>fzf</h3><blockquote><p>这里只说windows下的 在 mac和linux下 只需要输入命令 然后确定就可以了.</p></blockquote><ol><li>先下载 <code>fzf-0.17.4-windows_amd64.zip</code> 文件</li><li>解压其中的 <code>fzf.exe</code> 到 <code>~/windows/</code> 下(也可以放到 其他PATH环境变量的文件夹下)</li><li>同样在终端中 <code>source ~/.zshrc</code> </li><li>此时可以用<code>fzf</code> + 文件夹名来检索</li></ol><h2 id="better"><a href="#better" class="headerlink" title="better"></a>better</h2><blockquote><p>来自 方方老师的 用 <code>j</code> 和 <code>jj</code> 代替 <code>z</code> 和 <code>fzf</code> 更好的 <code>z</code></p></blockquote><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true">#z&amp;fzf</span><span class="token function">unalias</span> zj<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">[</span><span class="token punctuation">[</span> -z <span class="token string">"<span class="token variable">$*</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>         <span class="token function">cd</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>_z -l 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span> fzf +s <span class="token operator">|</span> <span class="token function">sed</span> 's/^<span class="token punctuation">[</span>0-9,.<span class="token punctuation">]</span>* *//'<span class="token variable">)</span></span>"</span>    <span class="token keyword">else</span>       _last_z_args<span class="token operator">=</span><span class="token string">"<span class="token variable">$@</span>"</span>      _z <span class="token string">"<span class="token variable">$@</span>"</span> <span class="token keyword">fi</span><span class="token punctuation">}</span>jj<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">cd</span> <span class="token string">"<span class="token variable"><span class="token variable">$(</span>_z -l 2<span class="token operator">></span><span class="token operator">&amp;</span>1 <span class="token operator">|</span> <span class="token function">sed</span> 's/^<span class="token punctuation">[</span>0-9,.<span class="token punctuation">]</span>* *//' <span class="token operator">|</span> fzf -q $_last_z_args<span class="token variable">)</span></span>"</span><span class="token punctuation">}</span></code></pre><p>放到你的 zshrc 中.</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何系统的学习 JavaScript(转)</title>
      <link href="/2018/12/28/learn-JavaScript/"/>
      <url>/2018/12/28/learn-JavaScript/</url>
      
        <content type="html"><![CDATA[<p>我来单说系统的学习 JavaScript，因为这也是我一直在思考的问题，我认为至少有以下几个阶段：</p><h2 id="ECMAScript-语法的学习。"><a href="#ECMAScript-语法的学习。" class="headerlink" title="ECMAScript 语法的学习。"></a>ECMAScript 语法的学习。</h2><p> 推荐阅读 《JavaScript高级程序设计》第三版的第 1 页至第 192 页，这部分只涉及 ECMAScript 的语法，目的在于了解 JavaScript这门语言本身。推荐至少阅读两遍以上，然而即便阅读了两遍，依然会对于其中的诸多概念感到困惑，具体包括原型、原型链、静态作用域和动态作用域、执行上下文栈、变量对象、作用域链、this、执行上下文、闭包、按值传递、apply、call、bind、new、arguments、创建对象、继承、隐式类型转换。如果对这些概念没有较为深入的了解，请不要接着往下学习，那如何判断对这些概念的了解是属于深入的呢？其实也很简单，你到掘金或者 segmentfault 以这些关键词搜索相关文章，找到高收藏、高点赞量的文章，如果对这些文章讲的概念，能清楚的明白，就算是达标了。如果没有，应该就这些关键字搜索相关文章深入学习。关于这个部分，我想推荐下我的博客中的深入系列 15篇：mqyqingfeng/Blog ，也许会有所帮助。</p><h2 id="underscore-源码的阅读。"><a href="#underscore-源码的阅读。" class="headerlink" title="underscore 源码的阅读。"></a>underscore 源码的阅读。</h2><p>我们学习了 JavaScript 语言本身，接下来应该是加强对于 JavaScript 这门语言的使用，我推荐阅读 underscore 的源码，相比 jQuery，lodash，更加适合新人阅读。重点通过使用 JavaScript 完成一些功能点的这个过程  熟练使用 JavaScript 的同时，克服对于语言和源码的恐惧。此外，之所以不立刻就去学习 DOM、BOM，是因为 DOM 和 BOM 带来的视觉效果的心理激励远比实现一个数组去重效果要多得多，很容易让人沉溺其中，而忽略了对于语言本身的修炼。</p><h2 id="DOM-和-BOM-的学习。"><a href="#DOM-和-BOM-的学习。" class="headerlink" title="DOM 和 BOM 的学习。"></a>DOM 和 BOM 的学习。</h2><p>如果再不学习这块，估计都按耐不住了……这一部分依然推荐阅读 《JavaScritp高级程序设计》，内容从第 193 页到第 443 页，我觉得关于 DOM 的讲解，高程和权威指南各有千秋，比如对于 clientTop、offsetTop、scrollTop 等与距离相关的属性的讲解，高程通过示意图更加形象，在事件方面，权威指南写了多个事件类型的多个示例代码，如果读者能跟着权威指南实现这一个一个的效果，一定收益良多。在阅读完 DOM、BOM 的内容后，事实上这一阶段才刚刚开始，接下来是学着去写原生组件。或者参考一些好的文章，或者参考 Github 上一些高 star 的项目，自己从零实现实现这些效果，这些效果包括但不止：轮播图、回到顶部、滚动时固定在顶部、懒加载 、预加载、下拉刷新、上拉加载、瀑布流实现 、移动端手势库、拖动……实现这些效果，会帮助你全方位的了解 DOM 的各类事件。不知道为什么，我又想推荐下自己造的一些轮子…… mqyqingfeng/Wheels在这个阶段结束前，希望你已经发布自己造的一些轮子，以及参照轮子的实现过程中至少明白 EventEmitter (自定义事件)以及如何以面向对象的方式组织代码。</p><h2 id="ES6-的学习"><a href="#ES6-的学习" class="headerlink" title="ES6 的学习"></a>ES6 的学习</h2><p>最新的 ECMAScript 语法是肯定需要学习的，尤其是现在的大环境已经普通使用 ES6。这个部分，其实能推荐的书籍并不多，有两本，阮一峰老师的《ES6标准入门》以及 NICHOLAS C. ZAKS 的《深入理解ES6》，这位也是高程的作者。阅读完后，希望你能在以后的项目在尽可能满足业务需求的情况下使用 ES6 的语法书写代码。</p><h2 id="框架的选择"><a href="#框架的选择" class="headerlink" title="框架的选择"></a>框架的选择</h2><p>现在主流的数据驱动的框架，有React、Vue、Angular，对这些框架稍稍了解以后，选择一个最喜欢的框架学习和使用，最好能在业务开发中用到。此外，不要与人争论框架好与坏，都是好框架。学习完基本使用后，希望你能学着深入了解技术栈中的各项技术。以 React 技术栈为例，了解 React 实现的原理，造一个类 React 的简易框架，阅读 Redux、React-redux、React-router 等库的源码……在这个过程中，明白一个框架的优秀之处。</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>相信这个时候的你，早已经熟练的进行项目开发，在项目开发中，保证自己的代码优雅，健壮，可维护性高是对自己也是对同事的负责任。推荐阅读《JavaScript设计模式与开发实践》，相信你看到这里的内容，一定有种似曾相识的感觉，在过往的源码阅读中，一定或多或少的有所接触，明白设计模式，让它更好的指导你进行开发。</p><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>我远没有到达这个部分，但我相信算法在后期一定是非常重要的存在，不清楚，就不推荐了。</p><h2 id="更多"><a href="#更多" class="headerlink" title="更多"></a>更多</h2><p>一定还有更多的东西，需要学习……</p><blockquote><p>最后，做完这所有的学习至少需要 2 年以上的时间，甚至会更多更多，相信你肯定不会真的花 2 年时间只学习 JavaScript，所以我假设的是题主一定会先找到工作，然后在工作之余系统的学习 JavaScript，所以对于 jQuery，webpack，移动端开发之类的就不提了，相信你在工作中一定会学习到这些内容。</p></blockquote><p>此外，不得不说，这样的学习路线，也很适合已经工作一段时间，对于 JavaScript 依然有不安定感的人。最后再推荐一些个人受益良多的书籍：</p><p>1.《你不知道的 JavaScript》上中两卷都已有售<br>2.《JavaScript 忍者秘籍》<br>3.《单页 Web 应用 JavaScript 从前端到后端》<br>4.《JavaScript DOM 编程艺术》第 2 版<br>5. 对了，MDN 是你重要的伙伴。</p><hr><p>还有，如果可以的话，希望你在梳理自己知识的同时，能够将其分享出来，在与大家交流的过程中一定受益匪浅。最最后，我也在路上，与君共勉.</p><blockquote><p>作者：冴羽<br>链接：<a href="https://www.zhihu.com/question/67467219/answer/253992931" target="_blank" rel="noopener">https://www.zhihu.com/question/67467219/answer/253992931</a><br>来源：知乎</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的gitignore整理</title>
      <link href="/2018/12/28/my-gitignore/"/>
      <url>/2018/12/28/my-gitignore/</url>
      
        <content type="html"><![CDATA[<h2 id="目前的"><a href="#目前的" class="headerlink" title="目前的"></a>目前的</h2><pre><code>.DS_Store  node_modules  //包文件*.log  //缓存文件.vscode/  //vs编辑器的配置.cache/  //缓存文件// webstorm 生成的文件.idea*.imloutgen</code></pre>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建Git分支将Hexo博客迁移到其它电脑</title>
      <link href="/2018/12/27/hexo-branch/"/>
      <url>/2018/12/27/hexo-branch/</url>
      
        <content type="html"><![CDATA[<blockquote><p>GitHub+Hexo搭建博客的过程比较平滑，但是它的配置却非常耗时间，一旦电脑出现问题或者需要在另外一台电脑上写博客，那么Hexo博客的迁移非常就让人头疼。下面参考其他博客的方法，整理出一个能在平时就管理重要文件的方法，方便随时迁移</p></blockquote><h2 id="必备文件"><a href="#必备文件" class="headerlink" title="必备文件"></a>必备文件</h2><p>Hexo博客系统中影响迁移的只有一部分文件和文件夹，所以只需要备份它们即可</p><table><thead><tr><th>文件（夹）</th><th>说明</th></tr></thead><tbody><tr><td>scaffolds/</td><td>博客文章的模版</td></tr><tr><td>source/</td><td>所有博客文章，以及about、tags、categories等page</td></tr><tr><td>themes/</td><td>网站的主题</td></tr><tr><td>.gitignore</td><td>在push时需要忽略的文件和文件夹</td></tr><tr><td>_config.yml</td><td>站点配置文件</td></tr><tr><td>package.json</td><td>依赖包的名称和版本号</td></tr></tbody></table><p>我们要做的就是通过各种方式备份这些文件和文件夹，比如说以下两种静态备份方式：</p><ol><li>通过U盘或移动硬盘保存</li><li>通过网盘保存</li></ol><p>上述两种方式可以用于备份不经常改变的文件，可是我们需要备份的比如博客文章、Hexo配置文件和主题配置文件是需要经常更改的，所以需要其它方式动态备份</p><blockquote><p>参考其它博客了解到可以通过创建Hexo博客系统的分支进行备份</p></blockquote><h3 id="创建分支目录"><a href="#创建分支目录" class="headerlink" title="创建分支目录"></a>创建分支目录</h3><p>先新建一个hexo文件夹，作为分支的工作目录，用于保存将要备份的文件和文件夹</p><p><code>$ mkdir hexo</code></p><p>再把GitHub上的Hexo仓库clone到hexo文件夹中</p><p><code>$ git clone git@github.com:liuzheGit/liuzheGit.github.io.git hexo</code></p><p>删除除了.git文件夹的其它所有文件和文件夹，主要是为了得到版本管理的.git。下面命令不会删除隐藏文件和文件夹</p><pre><code>$ cd hexo$ rm -r * </code></pre><p>最后把需要备份的文件和文件夹都复制到hexo文件夹下，hexo的目录结构应该如下</p><pre><code>scaffolds/source/themes/.git/.gitignore_config.ymlpackage.json</code></pre><p>如果使用的主题是从GitHub克隆的，那么主题文件夹下有Git管理文件，需要将它们移除，我使用的是fexo，需要移除的文件如下</p><p><code>$ rm -R themes/fexo/.git*</code></p><h2 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h2><p>创建一个叫hexo的分支</p><p><code>$ git checkout -b hexo</code></p><p>保存所有文件到暂存区</p><p><code>$ git add --all</code></p><p>提交变更</p><p><code>$ git commit -m &quot;创建hexo分支&quot;</code></p><p>推送到GitHub，并用–set-upstream与origin创建关联，将hexo设置为默认分支</p><p><code>$ git push --set-upstream origin hexo</code></p><h1 id="转载者（lttztt）注"><a href="#转载者（lttztt）注" class="headerlink" title="转载者（lttztt）注"></a>转载者（lttztt）注</h1><blockquote><p>我目前就用前面的就能很好的管理我的博客和我的文档了，用hexo分支存放hexo配置和博客markdown文档， 用 master 在github page 上做静态博客服务展示。</p></blockquote><h2 id="合并管理"><a href="#合并管理" class="headerlink" title="合并管理"></a>合并管理</h2><p>现在我们的博客系统有两个需要管理的文件夹，一个是hexo，另一个是username.github.io，每次发表新文章都需要分别对这两个文件夹进行提交管理，显然是很蠢的行为</p><p>因为我们需要手动管理的只是hexo中的文件，而.gitignore之外的文件由Hexo管理，所以可以将这两个文件夹进行合并管理</p><p>之前已经将需要备份的文件加入了hexo分支，所以直接将hexo分支中的.git文件夹复制到username.github.io文件夹中</p><p><code>$ cp -a .git ../liuzheGit.github.io</code></p><p>查看当前的分支，确保处于hexo分支下</p><pre><code>$ cd ../liuzheGit.github.io$ git branch -v</code></pre><p>还需要移除主题目录下的Git管理文件</p><p><code>$ rm -R themes/fexo/.git*</code></p><p>查看Git当前状态，还需要对.gitignore文件进行编辑，确保忽略不备份的文件</p><p><code>$ git status</code></p><p>master分支的文件则需要Hexo进行管理，编辑 _config.yml站点配置文件，设置branch为master</p><pre><code>deploy:    type: git    repo: https://github.com/liuzheGit/liuzheGit.github.io.git    branch: master</code></pre><p>发表文章<br>新建Markdown文章，编辑文章</p><p><code>$ hexo new test</code></p><p>将相关更改推送到hexo分支</p><pre><code>$ git add .$ git commit -m &quot;发表文章test&quot;$ git push origin hexo</code></pre><p>将静态文件推送到master分支</p><pre><code>$ hexo clean # 如果配置文件没有更改，忽略该命令$ hexo g -d</code></pre><p>在GitHub上查看hexo分支如下图所示</p><p>迁移<br>将hexo分支克隆下来</p><p><code>$ git clone -b hexo git@github.com:liuzheGit/liuzheGit.github.io.git</code></p><p>然后安装Hexo依赖</p><p><code>$ npm install</code></p><p>这样就可以简单的将Hexo博客迁移到任何电脑上了 : )</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>原文：<a href="https://blog.csdn.net/white_idiot/article/details/80685990" target="_blank" rel="noopener">https://blog.csdn.net/white_idiot/article/details/80685990</a> </p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows下改键AutoHotKey</title>
      <link href="/2018/12/24/windows%E4%B8%8B%E6%94%B9%E9%94%AEAutoHotKey/"/>
      <url>/2018/12/24/windows%E4%B8%8B%E6%94%B9%E9%94%AEAutoHotKey/</url>
      
        <content type="html"><![CDATA[<h2 id="Win下效率神器-AutoHotKey"><a href="#Win下效率神器-AutoHotKey" class="headerlink" title="Win下效率神器: AutoHotKey"></a>Win下效率神器: AutoHotKey</h2><p><strong>AutoHotkey</strong>是一个windows下的开源、免费、自动化软件工具。它由最初旨在提供键盘快捷键的脚本语言驱动(称为：<strong>热键</strong>)，随着时间的推移演变成一个完整的脚本语言。但你不需要把它想得太深，你只需要知道它可以简化你的重复性工作，一键自动化启动或运行程序等等；以此提高我们的<strong>工作效率</strong>，改善<strong>生活品质</strong>；通过按键映射，鼠标模拟，定义宏等。</p><h2 id="为什么使用AutoHotKey"><a href="#为什么使用AutoHotKey" class="headerlink" title="为什么使用AutoHotKey"></a>为什么使用AutoHotKey</h2><p><strong>caps键</strong>是一个有着天然优势的按键,但是却是一个被设计的最没用的按键(系统默认下), 只是为了切换大小写. (我输入大写字母不会按shift吗?)</p><h2 id="下载安装-AutoHotKey"><a href="#下载安装-AutoHotKey" class="headerlink" title="下载安装 AutoHotKey"></a>下载安装 AutoHotKey</h2><p>进入官网 <a href="http://www.autohotkey.com/" target="_blank" rel="noopener">AutoHokey</a> 点击download  , 之后一路下一步</p><h2 id="脚本"><a href="#脚本" class="headerlink" title="脚本"></a>脚本</h2><p>这里简单说明下脚本中常用符号代表的含义：</p><blockquote><p><strong>#</strong> 号代表 <strong>Win</strong> 键；<br><strong>!</strong> 号代表 <strong>Alt</strong> 键；<br><strong>^</strong> 号代表 <strong>Ctrl</strong> 键；<br><strong>+</strong> 号代表 <strong>shift</strong> 键；<br><strong>::</strong> 号(两个英文冒号)起分隔作用；<br><strong>run</strong>，非常常用 的 AHK 命令之一;<br><strong>;</strong> 号代表 注释后面一行内容；</p></blockquote><p> <strong>run</strong>它的后面是要运行的程序完整路径</p><h2 id="win-下的系统默认-win-快捷键"><a href="#win-下的系统默认-win-快捷键" class="headerlink" title="win 下的系统默认 win 快捷键"></a>win 下的系统默认 win 快捷键</h2><p>Win + E：打开资源管理器；<br>Win + D：显示桌面；<br>Win + F：打开查找对话框；<br>Win + R：打开运行对话框；<br>Win + L：锁定电脑；<br>Win + PauseBreak：打开系统属性对话框;<br>Win + Q: 本地文件/网页等搜索;<br>Win + U: 打开控制面板－轻松使用设置中心;</p><h2 id="我的配置"><a href="#我的配置" class="headerlink" title="我的配置"></a>我的配置</h2><ol><li><p>主要为了 把 caps 改为 ctrl </p><pre><code>;;changeCaps.ahk+Capslock::CapslockCapslock::Ctrl</code></pre><p>把<code>caps键</code>, 改为 <code>ctrl 键</code>,  原来切换 大小写的 改为 <code>shift + capslock</code></p></li><li><p>颜色拾取</p><pre><code>^#z::MouseGetPos, mouseX, mouseY; 获得鼠标所在坐标，把鼠标的 X 坐标赋值给变量 mouseX ，同理 mouseYPixelGetColor, color, %mouseX%, %mouseY%, RGB; 调用 PixelGetColor 函数，获得鼠标所在坐标的 RGB 值，并赋值给 colorStringRight color,color,6; 截取 color（第二个 color）右边的6个字符，因为获得的值是这样的：#RRGGBB，一般我们只需要 RRGGBB 部分。把截取到的值再赋给 color（第一个 color）。clipboard = %color%; 把 color 的值发送到剪贴板return</code></pre><p>用 <code>ctrl + win + z</code> 快速拾取 鼠标位置的 16进制的颜色值.</p></li></ol><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><ul><li><a href="https://ahkcn.github.io/docs/Tutorial.htm#Create" target="_blank" rel="noopener">AHK中文指南</a></li><li><a href="https://www.jeffjade.com/2016/03/11/2016-03-11-autohotkey/" target="_blank" rel="noopener">晚晴幽草轩</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>用node-sass来转译scss文件</title>
      <link href="/2018/12/13/%E7%94%A8node-sass%E6%9D%A5%E8%BD%AC%E8%AF%91scss%E6%96%87%E4%BB%B6/"/>
      <url>/2018/12/13/%E7%94%A8node-sass%E6%9D%A5%E8%BD%AC%E8%AF%91scss%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<p>#用node-sass来转译scss文件</p><p>sass是来之ruby社区的。 所以想要用 sass 需要安装ruby。 但是我不做 ruby的开发， 不想要安装 ruby 。 </p><p><strong>解决办法</strong>： </p><p>Nodejs 的 node-sass 就是来做这样的事的。</p><p>安装 之前需要 配置一下 源 。不然 <code>npm i node-sass</code>的时候 会报错 ：</p><p>配置： 在你的 bash配置中(~/.bashrc 或 ~/.zshrc) 添加 </p><p><code>export SASS_BINARY_SITE=&quot;https://npm.taobao.org/mirrors/node-sass&quot;</code></p><p>这样 就会用淘宝的源安装 node-sass</p><h3 id="项目中-安装-node-sass"><a href="#项目中-安装-node-sass" class="headerlink" title="项目中 安装 node-sass"></a>项目中 安装 node-sass</h3><pre class=" language-sh"><code class="language-sh">npm init -ynpm i -D node-sass</code></pre><p>然后再<code>package.json</code>中 配置<code>script</code>来运行 node-sass ， </p><p>也可以直接 使用 npx node-sass …</p><h3 id="在全局安装-node-sass-错误解决"><a href="#在全局安装-node-sass-错误解决" class="headerlink" title="在全局安装 node-sass 错误解决"></a>在全局安装 node-sass 错误解决</h3><blockquote><p> mac os 系统下需要加 <code>sudo</code> </p></blockquote><p><code>sudo npm i -D node-sass -g</code></p><p>此时 报了错误, 大意还是说 权限不够, 然后到去 找 解决方法: 在百度搜了一大圈发现 全是教配置 淘宝源的, 没有我想要.  只能去google了, 到了 github上 找到node-sass 夏目的 指导页面, 全是英文, 硬着头皮看吧, 终于让我找到了.</p><p> <strong>意思是说:</strong></p><p>如果 你用的是linux 或者 macos系统 , 全局安装<code>node-sass</code>就算你使用 sudo , 但还是会有一个npm的安全功能给阻止, (您应该始终避免运行<code>npm</code>，<code>sudo</code>因为安装脚本可能是无意的恶意)但是 如果你必须要用 的话 需要使用 <code>--unsafe-perm</code> 来解决报错:</p><p><code>$ sudo npm install --unsafe-perm -g node-sass</code></p><p>这样就可以 直接 node-sass 来在所有项目中使用了.</p><p> <a href="https://github.com/sass/node-sass/blob/master/TROUBLESHOOTING.md#linuxosx" target="_blank" rel="noopener">github</a>寻找答案</p><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><pre class=" language-sh"><code class="language-sh">node-sass src/style.scss dist/style.css</code></pre><p>###参数</p><ul><li><p><code>-w</code> 监听文件改动</p></li><li><p><code>-r</code> 递归的监听目录</p></li><li><p><code>--output-style</code> 指定代码编译风格 </p><ul><li><pre><code>* nested：嵌套缩进的css代码，它是默认值。* expanded：没有缩进的、扩展的css代码。 (最直观的)* compact：简洁格式的css代码。 (一行一个)* compressed：压缩后的css代码。 (只有一行)# 生产环境当中，一般使用最后一个选项。</code></pre></li><li></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macos下用Mounty挂载NTFS磁盘报错</title>
      <link href="/2018/12/05/%E5%9C%A8macos%E4%B8%8B%E7%94%A8Mounty%E6%8C%82%E8%BD%BDNTFS%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99/"/>
      <url>/2018/12/05/%E5%9C%A8macos%E4%B8%8B%E7%94%A8Mounty%E6%8C%82%E8%BD%BDNTFS%E7%A3%81%E7%9B%98%E6%8A%A5%E9%94%99/</url>
      
        <content type="html"><![CDATA[<p>从Win系统, 迁移到Mac系统的一大不爽是 之前移动硬盘和U盘的储存设备只能读取,不能写入.</p><h2 id="寻找方案"><a href="#寻找方案" class="headerlink" title="寻找方案"></a>寻找方案</h2><p>在网上在了好多工具, 大部分都是收费的, 这次发现了个轻便的软件可以做到. 就是 <code>Mounty</code>了, 某次愉快的从Win复制过文件后, 再次到mac上来打开Mounty准备挂载U盘时,报错了. 提示我之前没有安全卸载.意思是说磁盘在win下面没有安全删除就拔出来了，导致文件系统中有错误区块，所以在MAC中不能挂载成读写模式.</p><h2 id="解决不能读取安全卸载的U盘"><a href="#解决不能读取安全卸载的U盘" class="headerlink" title="解决不能读取安全卸载的U盘"></a>解决不能读取安全卸载的U盘</h2><ol><li>插入移动硬盘到win下面</li><li>用管理员的<code>powershell</code> 输入 <code>chkdsk /f</code> ,回车</li><li>输入 <code>y</code> 确定</li><li>一次完成</li></ol><blockquote><p>以后还是老老实实 安全卸载的为好.</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scp命令-每天一个linux命令</title>
      <link href="/2018/12/04/scp%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/12/04/scp%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>linux 的 scp 命令是用来在linux间安全的复制文件和目录.<br>scp: 是 <code>secure copy</code> 的缩写, 是基于<code>ssh</code>登录进行安全的远程文件拷贝命令.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p><code>scp [参数] file_source file_target</code></p><p><strong>参数说明(常用)</strong></p><ul><li><code>-r</code>： 递归复制整个目录</li><li><code>-v</code>：详细方式显示输出</li><li><code>-P port</code>：注意是大写的P, port是指定数据传输用到的端口号</li><li><code>-p</code>：保留原文件的修改时间，访问时间和访问权限</li><li><code>-C</code>: 允许压缩。（将-C标志传递给ssh，从而打开压缩功能）</li></ul><p>例如: </p><p><code>scp -r ./file/ username@ip ./targetFile/</code></p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li>本地复制到远程:</li></ol><pre class=" language-shell"><code class="language-shell">    # 文件    scp ./temp/foo.js root@aiminn.top:foo  #这个是复制到foo文件夹内,名称不变    scp ./temp/foo.js root@aimnnn.top:foo/bar.js  #改名为bar.js    # 文件夹    scp -r ./temp/ root@aiminn.top:foo</code></pre><ol start="2"><li>远程复制到本地</li></ol><pre class=" language-shell"><code class="language-shell">    scp root@aiminn.top:home/index.html ./home/    scp -r root@aiminn.top:home/ ./home</code></pre>]]></content>
      
      
      <categories>
          
          <category> Back-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css中添加@charset的作用</title>
      <link href="/2018/12/04/css%E4%B8%AD%E6%B7%BB%E5%8A%A0-charset%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
      <url>/2018/12/04/css%E4%B8%AD%E6%B7%BB%E5%8A%A0-charset%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h2><p>使用UTF-8编码唯一的好处是，国外的用户如果使用Windows XP英文版，浏览UTF-8编码的任何网页，无论是中文、还是日文、韩文、阿拉伯文，都可以正常显示，UTF-8是世界通用的语言编码，而如果用Windows XP英文版的IE6.0浏览gb2312语言编码的网页，则会提示是否安装语言包。因此，可能会失去很多的国外浏览者。使用gb2312编码的好处是，因为程序产生的网页文本使用ANSI编码格式，会比UTF-8文本编码节省一些体积，访问速度会稍微快一点点。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>使用UTF-8编码，有2个要注意：</p><ol><li>是网页的meta部分，必须有这句：</li></ol><p><code>&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=UTF-8&quot;&gt;</code></p><ol start="2"><li>是网页的文本格式，必须保存为UTF-8格式，方法是用记事本打开网页，点击“文件→另存为”，在最后的Encoding，默认是ANSI，改为UTF-8<br>文件也存为utf-8格式。</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>UTF-8为世界统一编码。好处：可以兼容全世界的操作系统，不会出现乱码情况。缺点：体积稍大点。注意：保存网页格式的时候保存为UTF-8，一般情况默认为ANSI编码。</p><p>gb2312编码，好处：体积稍小点。缺点：国外的浏览者可能会出现乱码，获提示安装语言包。</p><p>一般，网站提供给全球看的一般用UTF-8，仅仅针对国内的用gb2312就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css技巧-color的巧用</title>
      <link href="/2018/11/26/css%E6%8A%80%E5%B7%A7-color%E7%9A%84%E5%B7%A7%E7%94%A8/"/>
      <url>/2018/11/26/css%E6%8A%80%E5%B7%A7-color%E7%9A%84%E5%B7%A7%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>这个技巧来自 张鑫旭的css世界的讲解.</p><h2 id="延伸"><a href="#延伸" class="headerlink" title="延伸"></a>延伸</h2><p>具体是: css中 有很多的属性中的颜色值默认的 是<code>color</code>的值, 如: border-color/outline/box-shadow和text-shadow等.</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实际开发的例子: 上传图片的时候,会做美化比如这样:<br><img src="/images/css%E4%B8%8A%E4%BC%A0.png" alt="css图片上传"><br>hover的时候可以整体变个色.<br>这种方方正正、简简单单的图形最适合使用三三两两的CSS代码绘制了。通常， 我们使用width/height外加一个background-color绘制加号的, 核心CSS代码如下: </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.add</span> </span><span class="token punctuation">{</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px dashed <span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-element">:before</span>, <span class="token class">.add</span><span class="token pseudo-element">:after</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* hover的时候 变个色*/</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#06C</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-class">:hover</span><span class="token pseudo-element">:before</span>, <span class="token class">.add</span><span class="token pseudo-class">:hover</span><span class="token pseudo-element">:after</span> </span><span class="token punctuation">{</span>    <span class="token property">background</span><span class="token punctuation">:</span> <span class="token hexcode">#06C</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>功能上没有问题, 可是当我们<code>hover</code>变色的时候, 需要同时重置3处(元素本身以及两个伪元素)颜色. 实际上, 如果这里不适用<code>background-color</code>, 而是使用<code>border</code>来绘制加号, 则代码会简单很多, 如下: </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.add</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#ccc</span><span class="token punctuation">;</span>    <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px dashed<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-element">:before</span> </span><span class="token punctuation">{</span>    <span class="token property">border-top</span><span class="token punctuation">:</span> <span class="token number">10</span>px solid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-element">:after</span> </span><span class="token punctuation">{</span>    <span class="token property">border-left</span><span class="token punctuation">:</span> <span class="token number">10</span>px solid<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/* hover的时候 变个色*/</span><span class="token selector"><span class="token class">.add</span><span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#06C</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到, 使用<code>border</code>实现, 我们hover变色的时候, 只需要重置1处, 也就是重置元素本身的<code>color</code>就可以了, 因为整个图形都是使用border绘制的, 同时颜色缺省, 所以所有图形颜色自动跟着一起变化了.<br>演示效果 <a href="https://demo.cssworld.cn/4/4-1.php" target="_blank" rel="noopener">张鑫旭</a><br><a href="http://js.jirengu.com/sobol/3/edit" target="_blank" rel="noopener">我的演示</a></p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>npm的package.json详解</title>
      <link href="/2018/11/10/npm%E7%9A%84package-json%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/11/10/npm%E7%9A%84package-json%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="npm中package-json详解"><a href="#npm中package-json详解" class="headerlink" title="npm中package.json详解"></a>npm中package.json详解</h2><blockquote><p>参见 <a href="https://blog.csdn.net/naipeng/article/details/53178062" target="_blank" rel="noopener">https://blog.csdn.net/naipeng/article/details/53178062</a></p></blockquote><p>通常我们使用npm init命令来创建一个npm程序时，会自动生成一个<code>package.json</code>文件。<code>package.json</code>文件会描述这个NPM包的所有相关信息，包括作者、简介、包依赖、构建等信息，格式是严格的JSON格式。</p><p><strong>常用命令</strong></p><p>npm i –save packageName   安装依赖包</p><p>npm i –save-dev packageName</p><p>npm i <a href="mailto:webpack@1.2.1" target="_blank" rel="noopener">webpack@1.2.1</a>   安装指定版本的包，版本号用@符号连接</p><p><strong>属性介绍</strong></p><p><strong>name</strong></p><p><code>name</code>和<code>version</code>是package.json中最重要的两个字段，也是发布到NPM平台上的唯一标识，如果没有正确设置这两个字段，包就不能发布和被下载。</p><p><strong>version</strong></p><p>包的版本号。如”1.0.0”。</p><p><strong>description</strong></p><p>包的描述信息，将会在<code>npm search</code>的返回结果中显示，以帮助用户选择合适的包。</p><p><strong>keywords</strong></p><p>包的关键词信息，是一个字符串数组，同上也将显示在<code>npm search</code>的结果中。</p><p><strong>homepage</strong></p><p>包的主页地址。</p><p><strong>bugs</strong></p><p>包的bug跟踪主页地址。</p><p><strong>license</strong></p><p>包的开源协议名称。</p><p><strong>author</strong></p><p>包的作者。</p><p><strong>contributors, maintainers</strong></p><p>包的贡献者，是一个数组。</p><p><strong>files</strong>(较少用)</p><p>包所包含的所有文件，可以取值为文件夹。通常我们还是用<code>.npmignore</code>来去除不想包含到包里的文件。</p><p><strong>main</strong></p><p>包的入口文件。</p><p><strong>bin</strong>(较少用)</p><p>如果你的包里包含可执行文件，通过设置这个字段可以将它们包含到系统的<code>PATH</code>中，这样直接就可以运行，很方便。</p><p><strong>man</strong>(较少用)</p><p>为系统的<code>man</code>命令提供帮助文档。帮助文件的文件名必须以<code>数字</code>结尾，如果是压缩的，需要以<code>.gz</code>结尾。</p><pre><code>&quot;man&quot;: [&quot;./man/foo.1&quot;, &quot;./man/bar.1&quot;, &quot;./man/foo.2&quot; ]</code></pre><p><strong>directories</strong>(较少用)</p><p>CommonJS包所要求的目录结构信息，展示项目的目录结构信息。字段可以是：lib, bin, man, doc, example。值都是字符串。</p><p><strong>repository</strong></p><p>包的仓库地址。</p><pre><code>&quot;repository&quot;: {    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/rainnaZR/es6-react.git&quot;  },</code></pre><p><strong>scripts</strong></p><p>通过设置这个可以使NPM调用一些命令脚本，封装一些功能。</p><pre><code>&quot;scripts&quot;: {&quot;start&quot;: &quot;babel-node src/pages/index.js&quot;,    &quot;build&quot;: &quot;webpack --config config/webpack.config.js&quot;,    &quot;watch&quot;: &quot;webpack-dev-server --config config/webpack.config.js --hot --inline --progress&quot;  }</code></pre><p><strong>config</strong></p><p>添加一些设置，可以供<code>scripts</code>读取用，同时这里的值也会被添加到系统的环境变量中。</p><pre><code>&quot;config&quot;: {  &quot;port&quot;: &quot;8080&quot;}</code></pre><p><code>npm start</code>的时候会读取到<code>npm_package_config_port</code>环境变量。</p><p><strong>dependencies</strong></p><p>指定依赖的其它包，这些依赖是指包发布后正常执行时所需要的，也就是线上需要的包。使用下面的命令来安装：</p><pre><code>npm install --save packageName</code></pre><p>如果是开发中依赖的包，可以在<code>devDependencies</code>设置。</p><p><strong>devDependencies</strong></p><p>这些依赖只有在开发时候才需要。使用下面的命令来安装：</p><pre><code>npm install --save-dev packageName </code></pre><p><strong>peerDependencies</strong></p><p>相关的依赖，如果你的包是插件，而用户在使用你的包时候，通常也会需要这些依赖（插件），那么可以将依赖列到这里。</p><p>如<code>karma</code>, 它的<code>package.json</code>中有设置，依赖下面这些插件：</p><pre><code>&quot;peerDependencies&quot;: {  &quot;karma-jasmine&quot;: &quot;~0.1.0&quot;,  &quot;karma-requirejs&quot;: &quot;~0.2.0&quot;,  &quot;karma-coffee-preprocessor&quot;: &quot;~0.1.0&quot;,  &quot;karma-html2js-preprocessor&quot;: &quot;~0.1.0&quot;,  &quot;karma-chrome-launcher&quot;: &quot;~0.1.0&quot;,  &quot;karma-firefox-launcher&quot;: &quot;~0.1.0&quot;,  &quot;karma-phantomjs-launcher&quot;: &quot;~0.1.0&quot;,  &quot;karma-script-launcher&quot;: &quot;~0.1.0&quot;}</code></pre><p><strong>bundledDependencies</strong></p><p>绑定的依赖包，发布的时候这些绑定包也会被一同发布。</p><p><strong>optionalDependencies</strong>（较少用）</p><p>即使这些依赖没有，也可以正常安装使用。</p><p><strong>engines</strong>（较少用）</p><p>指定包运行的环境。</p><pre><code>&quot;engines&quot;: {  &quot;node&quot;: &quot;&gt;=0.10.3 &lt; 0.12&quot;,  &quot;npm&quot;: &quot;~1.0.20&quot;}</code></pre><p><strong>os</strong>（较少用）</p><p>指定你的包可以在哪些系统平台下运行。</p><pre><code>&quot;os&quot;: [ &quot;darwin&quot;, &quot;linux&quot;, &quot;!win32&quot; ]</code></pre><p><strong>cpu</strong>（较少用）</p><p>可以指定包运行的cpu架构。</p><p><strong>private</strong></p><p>设为<code>true</code>这个包将不会发布到NPM平台下。</p><p><strong>publishConfig</strong>（较少用）</p><p>这个字段用于设置发布时候的一些设定。尤其方便你希望发布前设定指定的<code>tag</code>或<code>registry</code>。</p><p>如下：</p><pre><code>{  &quot;name&quot;: &quot;react&quot;,  &quot;version&quot;: &quot;1.0.0&quot;,  &quot;description&quot;: &quot;Command line instructions&quot;,  &quot;keywords&quot;: [    &quot;react&quot;,    &quot;es6&quot;,    &quot;react with es6&quot;  ],  &quot;homepage&quot;: &quot;https://github.com/rainnaZR/es6-react&quot;,  &quot;bugs&quot;: {    &quot;url&quot;: &quot;https://github.com/rainnaZR/es6-react&quot;,    &quot;email&quot;: &quot;111@163.com&quot;  },  &quot;license&quot;: &quot;ISC&quot;,  &quot;author&quot;: &quot;ZRainna&quot;,  &quot;main&quot;: &quot;src/pages/index.js&quot;,  &quot;directories&quot;: {    &quot;tests&quot;: &quot;tests&quot;,    &quot;lib&quot;:&quot;lib&quot;,    &quot;docs&quot;:&quot;docs&quot;  },  &quot;repository&quot;: {    &quot;type&quot;: &quot;git&quot;,    &quot;url&quot;: &quot;git+https://github.com/rainnaZR/es6-react.git&quot;  },  &quot;scripts&quot;: {&quot;start&quot;: &quot;babel-node src/pages/index.js&quot;,    &quot;build&quot;: &quot;webpack --config config/webpack.config.js&quot;,    &quot;watch&quot;: &quot;webpack-dev-server --config config/webpack.config.js --hot --inline --progress&quot;  },  &quot;babel&quot;: {    &quot;presets&quot;: [      &quot;es2015-node5&quot;    ]  },  &quot;devDependencies&quot;: {    &quot;webpack&quot;: &quot;^1.13.2&quot;,    &quot;webpack-dev-server&quot;: &quot;^1.16.1&quot;  },  &quot;dependencies&quot;: {    &quot;babel-loader&quot;: &quot;^6.2.5&quot;,    &quot;babel-preset-es2015&quot;: &quot;^6.14.0&quot;,    &quot;babel-preset-react&quot;: &quot;^6.11.1&quot;,    &quot;react&quot;: &quot;^15.3.2&quot;,    &quot;react-dom&quot;: &quot;^15.3.2&quot;,    &quot;react-redux&quot;: &quot;^4.4.5&quot;,    &quot;react-router&quot;: &quot;^2.8.1&quot;,    &quot;redux&quot;: &quot;^3.6.0&quot;  }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webstorm中使用filewatch转译es6</title>
      <link href="/2018/11/10/webstorm%E4%B8%AD%E4%BD%BF%E7%94%A8filewatch%E8%BD%AC%E8%AF%91es6/"/>
      <url>/2018/11/10/webstorm%E4%B8%AD%E4%BD%BF%E7%94%A8filewatch%E8%BD%AC%E8%AF%91es6/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>es6的语法也看了不少, 也用了一些, 不过是在vue的vue-cli中直接使用, 不需要自己安装babel. </p><p>可是,有时候自己写个小测试, 不想用框架的cli, 这是就需要自己配置babel了, 也折腾过webpack得loader, 总感觉有问题, 这次就不用webpack, 直接用babel. 是在webstorm中用.</p><h3 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h3><ol><li><p>全局安装babel-cli , 全局安装 的好处在于 在webstrom中选择filewatch的时候, 不用每次再选择项目中的babel-cli的可执行文件了</p><pre class=" language-shell"><code class="language-shell"># 最新的babel-core也集成到了babel-cli中,所以还是直接安装吧sudo npm i babel-cli -g</code></pre></li><li><p>打开webstrom, 新建项目, 然后执行</p></li></ol><pre class=" language-shell"><code class="language-shell">npm init -ynpm i -D babel-preset-env </code></pre><p>此时都安装好了, 可以选择 webstrom的 preferences -&gt; Tools -&gt;File Watchers 然后点击 <code>+</code>号 ,选择 babel, 这里 只需要改动 Program、Arguments 和 Output, 本次 我只是选择了 我自己电脑上的babe-cli的安装路径, 就可用了,  用的是 <code>babel-preset-env</code>规则, 其他的没改,目前够我用了.</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> babel </tag>
            
            <tag> webstrom </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习-异步</title>
      <link href="/2018/11/06/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-%E5%BC%82%E6%AD%A5/"/>
      <url>/2018/11/06/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A0-%E5%BC%82%E6%AD%A5/</url>
      
        <content type="html"><![CDATA[<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><h3 id="pubsub-github"><a href="#pubsub-github" class="headerlink" title="pubsub github"></a>pubsub <a href="https://github.com/cowboy/jquery-tiny-pubsub" target="_blank" rel="noopener">github</a></h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 极小的发布订阅库</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>$<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  $<span class="token punctuation">.</span>subscribe <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o<span class="token punctuation">.</span>on<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  $<span class="token punctuation">.</span>unsubscribe <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o<span class="token punctuation">.</span>off<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span>  $<span class="token punctuation">.</span>publish <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    o<span class="token punctuation">.</span>trigger<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>o<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">(</span>jQuery<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p><code>setTimeout</code>和<code>setInterval</code></p><p>setTimeout除了第一个函数和第二个时间间隔外, 之后的参数作为第一个函数的参数依次传进去.</p><p>下面是一个通过<code>setInterval</code>方法实现网页动画的例子。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> div <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'someDiv'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> opacity <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> fader <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  opacity <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">0.1</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>opacity <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    div<span class="token punctuation">.</span>style<span class="token punctuation">.</span>opacity <span class="token operator">=</span> opacity<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">clearInterval</span><span class="token punctuation">(</span>fader<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> hash <span class="token operator">=</span> window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash<span class="token punctuation">;</span><span class="token keyword">var</span> hashWatcher <span class="token operator">=</span> <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>location<span class="token punctuation">.</span>hash <span class="token operator">!=</span> hash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">updatePage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p><p>为了确保两次执行之间有固定的间隔，可以不用<code>setInterval</code>，而是每次执行结束后，使用<code>setTimeout</code>指定下一次执行的具体时间。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p><h2 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h2><pre class=" language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'textarea'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'keydown'</span><span class="token punctuation">,</span> <span class="token function">debounce</span><span class="token punctuation">(</span>ajaxAction<span class="token punctuation">,</span> <span class="token number">2500</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">debounce</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> timer <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明计时器</span>  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> context <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> args <span class="token operator">=</span> arguments<span class="token punctuation">;</span>    <span class="token function">clearTimeout</span><span class="token punctuation">(</span>timer<span class="token punctuation">)</span><span class="token punctuation">;</span>    timer <span class="token operator">=</span> <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      fn<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> delay<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习8-面向对象编程</title>
      <link href="/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
      <url>/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A08-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<ul><li>为了与普通函数区别，构造函数名字的第一个字母通常大写<ul><li>函数体内部使用<code>this</code>关键字, 代表了所要生成的对象的实例</li><li>生成对象的时候, 必须使用<code>new</code>命令</li></ul></li><li><code>new</code>命令执行构造函数, 推荐后面加括号<code>var v = new V()</code></li><li>避免不使用<code>new</code>命令、直接调用构造函数</li></ul><h2 id="new的原理"><a href="#new的原理" class="headerlink" title="new的原理"></a>new的原理</h2><p>使用<code>new</code>命令时，它后面的函数依次执行下面的步骤。</p><ol><li>创建一个空对象，作为将要返回的对象实例。</li><li>将这个空对象的原型，指向构造函数的<code>prototype</code>属性。</li><li>将这个空对象赋值给函数内部的<code>this</code>关键字。</li><li>开始执行构造函数内部的代码。</li></ol><ul><li>构造函数内部<code>this</code>指的是新创建的空对象</li><li>如果内部有return ,且返回一个对象,则 构造函数返回这个手动返回的对象, 如果没有return 或者return的不是一个对象, 则会被忽略</li><li>如果<code>return</code>语句返回的是一个跟<code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是<code>this</code>对象。这一点需要特别引起注意</li><li>如果对普通函数（内部没有<code>this</code>关键字的函数）使用<code>new</code>命令，则会返回一个空对象</li><li>这是因为<code>new</code>命令总是返回一个对象，要么是实例对象，要么是<code>return</code>语句指定的对象。</li></ul><p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">_new</span><span class="token punctuation">(</span><span class="token comment" spellcheck="true">/* 构造函数 */</span> constructor<span class="token punctuation">,</span> <span class="token comment" spellcheck="true">/* 构造函数参数 */</span> params<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 将 arguments 对象转为数组</span>  <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 取出构造函数</span>  <span class="token keyword">var</span> constructor <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 创建一个空对象，继承构造函数的 prototype 属性</span>  <span class="token keyword">var</span> context <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>constructor<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 执行构造函数</span>  <span class="token keyword">var</span> result <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果返回结果是对象，就直接返回，否则返回 context 对象</span>  <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> result <span class="token operator">===</span> <span class="token string">'object'</span> <span class="token operator">&amp;&amp;</span> result <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">?</span> result <span class="token punctuation">:</span> context<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 实例</span><span class="token keyword">var</span> actor <span class="token operator">=</span> <span class="token function">_new</span><span class="token punctuation">(</span>Person<span class="token punctuation">,</span> <span class="token string">'张三'</span><span class="token punctuation">,</span> <span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="没有用new调用构造函数的处理"><a href="#没有用new调用构造函数的处理" class="headerlink" title="没有用new调用构造函数的处理"></a>没有用new调用构造函数的处理</h3><ol><li><p>new.target法</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'请使用 new 命令调用！'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Uncaught Error: 请使用 new 命令调用！</span></code></pre></li><li><p>内部用严格模式</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fubar</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token string">'use strict'</span><span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>_foo <span class="token operator">=</span> foo<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>_bar <span class="token operator">=</span> bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Fubar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// TypeError: Cannot set property '_foo' of undefined</span></code></pre></li><li><p>返回new调用</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">Fubar</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fubar</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fubar</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>_foo <span class="token operator">=</span> foo<span class="token punctuation">;</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>_bar <span class="token operator">=</span> bar<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">Fubar</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_foo <span class="token comment" spellcheck="true">// 1</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Fubar</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>_foo <span class="token comment" spellcheck="true">// 1</span></code></pre></li><li><p>instanceof法</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> Fubar <span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token keyword">instanceof</span> <span class="token class-name">Fubar</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_foo <span class="token operator">=</span> foo<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>_bar <span class="token operator">=</span> bar<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Fubar</span><span class="token punctuation">(</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li></ol><h2 id="object-create"><a href="#object-create" class="headerlink" title="object.create()"></a>object.create()</h2><p>没有构造函数, 用现有的对象作为模板,生成实例:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> person1 <span class="token operator">=</span> <span class="token punctuation">{</span>  name<span class="token punctuation">:</span> <span class="token string">'张三'</span><span class="token punctuation">,</span>  age<span class="token punctuation">:</span> <span class="token number">38</span><span class="token punctuation">,</span>  greeting<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hi! I\'m '</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> person2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>person1<span class="token punctuation">)</span><span class="token punctuation">;</span>person2<span class="token punctuation">.</span>name <span class="token comment" spellcheck="true">// 张三</span>person2<span class="token punctuation">.</span><span class="token function">greeting</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// Hi! I'm 张三.</span></code></pre><p><code>person1</code>是<code>person2</code>的模板, 后者继承的前者的属性和方法.</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>this</code>都有一个共同点：它总是返回一个对象</p><p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即<code>this</code>的指向是可变的。</p><p>如果<code>this</code>所在的方法不在对象的第一层，这时<code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">{</span>  p<span class="token punctuation">:</span> <span class="token string">'Hello'</span><span class="token punctuation">,</span>  b<span class="token punctuation">:</span> <span class="token punctuation">{</span>    m<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>b<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// undefined</span></code></pre><p>上面代码中，<code>a.b.m</code>方法在<code>a</code>对象的第二层，该方法内部的<code>this</code>不是指向<code>a</code>，而是指向<code>a.b</code>，因为实际执行的是下面的代码。</p><ul><li>使用一个变量固定<code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法</li><li>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的<code>this</code>指向顶层对象，就会报错</li></ul><h3 id="绑定this的方法"><a href="#绑定this的方法" class="headerlink" title="绑定this的方法"></a>绑定this的方法</h3><p>avaScript 提供了<code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换/固定<code>this</code>的指向。</p><blockquote><p><code>call</code>和<code>apply</code>都会立即执行, 而<code>bind</code>则返回一个新的函数</p></blockquote><h4 id="call"><a href="#call" class="headerlink" title="call()"></a>call()</h4><ul><li><p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和<code>undefined</code>，则默认传入全局对象。</p></li><li><p>如果<code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入<code>call</code>方法</p></li></ul><p><code>call</code>方法的一个应用是调用对象的原生方法。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token comment" spellcheck="true">// 覆盖掉继承的 hasOwnProperty 方法</span>obj<span class="token punctuation">.</span>hasOwnProperty <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'toString'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre><p>上面代码中，<code>hasOwnProperty</code>是<code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将<code>hasOwnProperty</code>方法的原始定义放到<code>obj</code>对象上执行，这样无论<code>obj</code>上有没有同名方法，都不会影响结果。</p><h4 id="apply"><a href="#apply" class="headerlink" title="apply()"></a>apply()</h4><p>和<code>call</code>类似, 它接收一个数组作为函数执行时的参数</p><p><strong>用处</strong></p><ol><li><p><strong>将数组的空元素变为undefined</strong></p><p>通过<code>apply</code>方法，利用<code>Array</code>构造函数将数组的空元素变成<code>undefined</code>。</p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [ 'a', undefined, 'b' ]</span></code></pre><p>空元素与<code>undefined</code>的差别在于，数组的<code>forEach</code>方法会跳过空元素，但是不会跳过<code>undefined</code>。</p></li><li><p><strong>转换类似数组的对象</strong></p><p>另外，利用数组对象的<code>slice</code>方法，可以将一个类似数组的对象（比如<code>arguments</code>对象）转为真正的数组。</p><pre class=" language-js"><code class="language-js">Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1]</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// []</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> length<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [1, undefined]</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>slice<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">{</span>length<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [undefined]</span></code></pre><p>上面代码的<code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有<code>length</code>属性，以及相对应的数字键。</p></li></ol><h4 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h4><p><code>bind</code>方法用于将函数体内的<code>this</code>绑定到某个对象，然后返回一个新函数</p><h3 id="参见"><a href="#参见" class="headerlink" title="参见"></a><a href="http://wangdoc.com/javascript/oop/this.html" target="_blank" rel="noopener">参见</a></h3><h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的<code>Object.prototype</code>还是找不到，则返回<code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p><h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><p>修改原型对象时，一般要同时修改<code>constructor</code>属性的指向</p><h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>返回一个布尔值, 表示对象是否是某个构造函数的实例.</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vehicle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>v <span class="token keyword">instanceof</span> <span class="token class-name">Vehicle</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>由于<code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回<code>true</code>。</p><p><code>instanceof</code>运算符的一个用处，是判断值的类型</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>x <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// true</span>y <span class="token keyword">instanceof</span> <span class="token class-name">Object</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>只适用于对象, 不适用于原始类型的值. 如 String .</p><p>对于<code>undefined</code>和<code>null</code>, <code>instanceof</code>总返回<code>false</code>;</p><h2 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h2><p>分两步: </p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 第一步: 在子类的构造函数中调用父类的构造函数, 让子类实例具有父类实例的属性;</span><span class="token keyword">function</span> <span class="token function">Sub</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  Super<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 第二步: 让子类的原型指向父类的原型, 子类继承父类;</span>Sub<span class="token punctuation">.</span>prototype <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Super<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>Sub<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token operator">=</span> Sub<span class="token punctuation">;</span></code></pre><h2 id="参见-1"><a href="#参见-1" class="headerlink" title="参见"></a><a href="http://wangdoc.com/javascript/oop/prototype.html" target="_blank" rel="noopener">参见</a></h2><h2 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h2><p><code>Object.create(Super)</code></p><p>该方法接受一个对象作为参数, 然后以它为原型,  返回一个实例对象. 该实例完全继承原型对象的属性.</p><p>下面三种方式生成的新对象是等价的。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj1 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果想生成的对象没有任何属性. 将Object.create的参数设为<code>null</code>;</p><ul><li>必须给定参数, 且不能是非对象</li><li><code>Object.create</code>方法生成的新对象，动态继承了原型</li></ul><h3 id="in-运算符-和-for-…-in-循环"><a href="#in-运算符-和-for-…-in-循环" class="headerlink" title="in 运算符 和 for … in 循环"></a>in 运算符 和 for … in 循环</h3><p><code>in</code>运算符返回一个布尔值, 表示一个对象是否具有某个属性. 继承的也返回<code>true</code></p><ul><li><code>in</code>运算符常用于检查一个属性是否存在</li></ul><p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用<code>for...in</code>循环</p><p>为了在<code>for...in</code>循环中获得对象自身的属性，可以采用<code>hasOwnProperty</code>方法判断一下。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span> <span class="token keyword">var</span> name <span class="token keyword">in</span> object <span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span> object<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* loop code */</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>如果要拷贝一个对象，需要做到下面两件事情。</p><ul><li>确保拷贝后的对象，与原对象具有同样的原型。</li><li>确保拷贝后的对象，与原对象具有同样的实例属性。</li></ul><p>下面就是根据上面两点，实现的对象拷贝函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">copyObject</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> copy <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">copyOwnPropertiesFrom</span><span class="token punctuation">(</span>copy<span class="token punctuation">,</span> orig<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> copy<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">copyOwnPropertiesFrom</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> source<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object    <span class="token punctuation">.</span><span class="token function">getOwnPropertyNames</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>propKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">var</span> desc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> propKey<span class="token punctuation">)</span><span class="token punctuation">;</span>      Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> target<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另一种更简单的写法，是利用 ES2017 才引入标准的<code>Object.getOwnPropertyDescriptors</code>方法。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">copyObject</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>    Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span><span class="token punctuation">,</span>    Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>orig<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="严格模式-es5引入"><a href="#严格模式-es5引入" class="headerlink" title="严格模式 es5引入"></a>严格模式 es5引入</h2><p><code>&#39;use strict&#39;;</code></p><h3 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h3><ol><li>可在整段的script中</li><li>可以在函数function中</li></ol><p>必须放在第一行,否则失效;(第一行可以是在注释后)</p><h3 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h3><blockquote><p>以下情况会报错</p></blockquote><ul><li>设置字符串<code>length</code>属性</li><li>对只读属性赋值, 或者删除不可配置属性</li><li>只有getter, 没有setter</li><li>对禁止扩展的对象添加新属性</li><li>使用<code>eval</code>和<code>arguments</code>作为标识名</li><li>函数有重名函数</li><li>八进制的前缀<code>0</code>表示法</li><li>变量没有声名,即使用,(正常模式中, 如果一个变量没有声名就赋值,默认是全局变量)</li><li><code>this</code>关键字指向全局对象 </li><li>禁止使用 fn.callee、fn.caller</li><li>禁止使用 arguments.callee / arguments.caller</li><li>禁止删除变量</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习7-包装对象</title>
      <link href="/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A07-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A07-%E5%8C%85%E8%A3%85%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="包装对象-String-Number-Boolean"><a href="#包装对象-String-Number-Boolean" class="headerlink" title="包装对象 String Number Boolean"></a>包装对象 String Number Boolean</h1><p>所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的<code>Number</code>、<code>String</code>、<code>Boolean</code>三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。</p><p><code>Number</code>、<code>String</code>和<code>Boolean</code>如果不作为构造函数调用（即调用时不加<code>new</code>），常常用于将任意类型的值转为数值、字符串和布尔值。</p><pre class=" language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token string">'abc'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "abc"</span><span class="token function">Boolean</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><p>总结一下，这三个对象作为构造函数使用（带有<code>new</code>）时，可以将原始类型的值转为对象；作为普通函数使用时（不带有<code>new</code>），可以将任意类型的值，转为原始类型的值。</p><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p><strong>静态方法</strong> – 定义在对象本身，而不是定义在对象实例的方法</p><p><strong>实例方法</strong></p><h3 id="concat"><a href="#concat" class="headerlink" title="concat()"></a>concat()</h3><p>连接两个字符串, 返回一个新的字符串, 不改变原字符串;</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p><code>slice</code>方法用于从原字符串取出字符串并返回. 不改变原字符串; 包前不包后原则;</p><h3 id="substring-不推荐"><a href="#substring-不推荐" class="headerlink" title="substring() 不推荐"></a>substring() 不推荐</h3><p><code>substring</code>方法用于从原字符串取出子字符串并返回，不改变原字符串，跟<code>slice</code>方法很相像。它的第一个参数表示子字符串的开始位置，第二个位置表示结束位置（返回结果不含该位置）。</p><p>不建议使用, 优先使用<code>slice</code></p><h3 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h3><p><code>substr</code>方法用于从原字符串取出子字符串并返回，不改变原字符串;和 <code>slice</code> 和<code>substring</code>作用一样, 但是第二个参数是 截取的个数.</p><ul><li>如果省略第二个参数，则表示子字符串一直到原字符串的结束。</li><li>如果第一个参数是负数，表示倒数计算的字符位置。如果第二个参数是负数，将被自动转为0，因此会返回空字符串。</li></ul><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf() lastIndexOf()"></a>indexOf() lastIndexOf()</h3><p><code>indexOf</code>方法用于确定一个字符串在另一个字符串中第一次出现的位置，返回结果是匹配开始的位置。如果返回<code>-1</code>，就表示不匹配。 第二个参数表示从该位置开始;</p><h3 id="trim"><a href="#trim" class="headerlink" title="trim()"></a>trim()</h3><p>去除字符串两端的空格. 返回新的, 不改变原来的;</p><p>该方法去除的不仅是空格，还包括制表符（<code>\t</code>、<code>\v</code>）、换行符（<code>\n</code>）和回车符（<code>\r</code>）。</p><h3 id="toLowerCase-toUpperCase"><a href="#toLowerCase-toUpperCase" class="headerlink" title="toLowerCase() toUpperCase()"></a>toLowerCase() toUpperCase()</h3><p><code>toLowerCase</code>方法用于将一个字符串全部转为小写，<code>toUpperCase</code>则是全部转为大写。它们都返回一个新字符串，不改变原字符串。</p><h3 id="split"><a href="#split" class="headerlink" title="split()"></a>split()</h3><p><code>split</code>方法按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组</p><h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><p><code>Math</code>对象的静态属性，提供以下一些数学常数。</p><ul><li><code>Math.E</code>：常数<code>e</code>。</li><li><code>Math.LN2</code>：2 的自然对数。</li><li><code>Math.LN10</code>：10 的自然对数。</li><li><code>Math.LOG2E</code>：以 2 为底的<code>e</code>的对数。</li><li><code>Math.LOG10E</code>：以 10 为底的<code>e</code>的对数。</li><li><code>Math.PI</code>：常数<code>π</code>。</li><li><code>Math.SQRT1_2</code>：0.5 的平方根。</li><li><code>Math.SQRT2</code>：2 的平方根。</li></ul><p><code>Math</code>对象提供以下一些静态方法。</p><ul><li><code>Math.abs()</code>：绝对值</li><li><code>Math.ceil()</code>：向上取整</li><li><code>Math.floor()</code>：向下取整</li><li><code>Math.max()</code>：最大值, 参数中的最大值</li><li><code>Math.min()</code>：最小值</li><li><code>Math.pow()</code>：指数运算</li><li><code>Math.sqrt()</code>：平方根</li><li><code>Math.log()</code>：自然对数</li><li><code>Math.exp()</code>：<code>e</code>的指数</li><li><code>Math.round()</code>：四舍五入</li><li><code>Math.random()</code>：随机数</li></ul><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><h3 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString()"></a><code>toString()</code></h3><p><code>toString</code>方法可以接受一个参数，表示输出的进制。</p><h3 id="toFixed"><a href="#toFixed" class="headerlink" title="toFixed()"></a><code>toFixed()</code></h3><p><code>toFixed</code>方法先将一个数转为指定位数的小数，然后返回这个小数对应的字符串。</p><h3 id="toExponential"><a href="#toExponential" class="headerlink" title="toExponential()"></a><code>toExponential</code>()</h3><p><code>toExponential</code>方法用于将一个数转为科学计数法形式。</p><h3 id="toPrecision"><a href="#toPrecision" class="headerlink" title="toPrecision()"></a><code>toPrecision()</code></h3><p><code>toPrecision</code>方法用于将一个数转为指定位数的有效数字。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习6-Array</title>
      <link href="/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A06-Array/"/>
      <url>/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A06-Array/</url>
      
        <content type="html"><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><p><code>Array</code>作为构造函数，行为很不一致。因此，不建议使用它生成新数组，直接使用数组字面量是更好的做法。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token punctuation">[</span>undefined<span class="token punctuation">,</span> undefined<span class="token punctuation">,</span> undefined<span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 3</span>b<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 3</span>a<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// undefined</span>b<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// undefined</span><span class="token number">0</span> <span class="token keyword">in</span> a <span class="token comment" spellcheck="true">// false</span><span class="token number">0</span> <span class="token keyword">in</span> b <span class="token comment" spellcheck="true">// true</span></code></pre><p>上面代码中，<code>a</code>是一个长度为3的空数组，<code>b</code>是一个三个成员都是<code>undefined</code>的数组。读取键值的时候，<code>a</code>和<code>b</code>都返回<code>undefined</code>，但是<code>a</code>的键位都是空的，<code>b</code>的键位是有值的。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><h3 id="Array-isArray"><a href="#Array-isArray" class="headerlink" title="Array.isArray()"></a>Array.isArray()</h3><p>返回一个布尔值, 表示是否为数组. 可以弥补<code>typeof</code>的不足</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">typeof</span> arr <span class="token comment" spellcheck="true">// object</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span></code></pre><h2 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h2><ul><li><code>push</code> <code>pop</code></li><li><code>shift</code> <code>unshift</code></li><li><code>join</code></li><li><code>concat</code></li><li>reverse</li><li><code>slice</code> </li><li><code>splice</code></li><li><code>sort</code></li><li><code>map</code></li><li><code>forEach</code></li><li><code>filter</code></li><li><code>some</code> <code>every</code></li><li><code>reduce</code> <code>reduceRight</code></li><li><code>indexOf</code> <code>lastIndexOf</code></li></ul><h3 id="其中会改变原数组的有"><a href="#其中会改变原数组的有" class="headerlink" title="其中会改变原数组的有"></a>其中会改变原数组的有</h3><p>push / pop / shift / unshift / reverse / splice / sort</p><h3 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h3><p>提取目标数组的一部分, 返回一个新数组, 原数组不变.</p><p><code>arr.slice(start, end)</code> : 包前不包后原则; 如果没有参数,则返回一个原数组的拷贝;</p><p>es5的伪数组转数组:  为什么要转伪数组呢: 伪数组是类似数组形式的对象,但是没有数组实例的方法.</p><p><code>Array.prototype.slice.call(likeArray)</code></p><h3 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h3><p>用于删除原数组的一部分成员,并在删除的位置添加新的数组成员. 返回值是被删除的元素, 改变原数组.</p><p>第一个参数: 删除的起始位置(0开始), 第二个是被删除的个数, 后面依次是被添加的元素.</p><p>单纯的想插入元素可以把第二个参数设为0;</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><p>排序默认是按照字典排序的, 原数组改变, 小到大;</p><p>如果想按照自定义的排序方式, 可以传入一个函数作为参数;</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">10111</span><span class="token punctuation">,</span> <span class="token number">1101</span><span class="token punctuation">,</span> <span class="token number">111</span><span class="token punctuation">]</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// [10111, 1101, 111];</span>a<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span> a <span class="token operator">-</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// [111, 1101, 10111]</span></code></pre><p>上面代码中，<code>sort</code>的参数函数本身接受两个参数，表示进行比较的两个数组成员。如果该函数的返回值大于<code>0</code>，表示第一个成员排在第二个成员后面；其他情况下，都是第一个元素排在第二个元素前面。</p><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><code>map</code>方法将数组的所有成员依次传入参数函数，然后把每一次的执行结果组成一个新数组返回, 原数组不变</p><p><code>map</code>方法接受一个函数作为参数。该函数调用时，<code>map</code>方法向它传入三个参数：当前成员、当前位置和数组本身。</p><p><code>map</code>还可以接受第二个参数, 用来绑定回调函数的<code>this</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>e<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">,</span> arr<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// ['b', 'c']</span></code></pre><p><code>map</code>方法不会跳过<code>undefined</code>和<code>null</code>，但是会跳过空位。</p><h3 id="forEach-可以被map替代"><a href="#forEach-可以被map替代" class="headerlink" title="forEach()  - 可以被map替代,"></a>forEach()  - 可以被map替代,</h3><p>简单说和<code>map</code>类似, <code>forEach</code>方法不返回值，只用来操作数据。这就是说，如果数组遍历的目的是为了得到返回值，那么使用<code>map</code>方法，否则使用<code>forEach</code>方法。</p><ul><li><p><code>forEach</code>方法无法中断执行</p></li><li><p><code>forEach</code>方法不会跳过<code>undefined</code>和<code>null</code>，但会跳过空位。</p></li></ul><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><code>filter</code>方法用于过滤数组成员, 满足条件的成员组成新数组返回. 不改变原数组;</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">]</span><span class="token punctuation">;</span>arr<span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>Boolean<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// [1, "a"]</span></code></pre><p>上面代码中，<code>filter</code>方法返回数组<code>arr</code>里面所有布尔值为<code>true</code>的成员。</p><p>也可以接受第二个参数, 绑定this</p><h3 id="some-every"><a href="#some-every" class="headerlink" title="some() every()"></a>some() every()</h3><p>返回一个布尔值, 表示判断数组成员是否符合某种条件;</p><p>它们接受一个函数作为参数，所有数组成员依次执行该函数。该函数接受三个参数：当前成员、当前位置和整个数组，然后返回一个布尔值。</p><p><code>some</code>方法只要有一个成员返回<code>true</code>, 则<code>some</code>方法的返回值就是 <code>true</code>, 否则返回<code>false</code>;</p><p><code>every</code>方法是所有成员的返回值都是<code>true</code>，整个<code>every</code>方法才返回<code>true</code>，否则返回<code>false</code>。</p><ul><li>注意，对于空数组，<code>some</code>方法返回<code>false</code>，<code>every</code>方法返回<code>true</code>，回调函数都不会执行。</li><li><code>some</code>和<code>every</code>方法还可以接受第二个参数，用来绑定参数函数内部的<code>this</code>变量。</li></ul><h3 id="reduce-reduceRight"><a href="#reduce-reduceRight" class="headerlink" title="reduce() reduceRight()"></a>reduce() reduceRight()</h3><p><code>reduce</code>方法和<code>reduceRight</code>方法依次处理数组的每个成员，最终累计为一个值。</p><p>一个从左到右, 一个相反.</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1 2</span><span class="token comment" spellcheck="true">// 3 3</span><span class="token comment" spellcheck="true">// 6 4</span><span class="token comment" spellcheck="true">// 10 5</span><span class="token comment" spellcheck="true">//最后结果：15</span></code></pre><p><code>reduce</code>方法和<code>reduceRight</code>方法的第一个参数都是一个函数。该函数接受以下四个参数。</p><ol><li>累积变量，默认为数组的第一个成员</li><li>当前变量，默认为数组的第二个成员</li><li>当前位置（从0开始）</li><li>原数组</li></ol><p>这四个参数之中，只有前两个是必须的，后两个则是可选的。</p><p><strong>第二参数可选, 代表累计变量的初值</strong> : 处理空数组时尤其有用</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> cur<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> prev <span class="token operator">+</span> cur<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// TypeError: Reduce of empty array with no initial value</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>add<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 1</span></code></pre><p>上面代码中，由于空数组取不到初始值，<code>reduce</code>方法会报错。这时，加上第二个参数，就能保证总是会返回一个值。</p><p>由于这两个方法会遍历数组，所以实际上还可以用来做一些遍历相关的操作。比如，找出字符长度最长的数组成员。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">findLongest</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> entries<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>longest<span class="token punctuation">,</span> entry<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> entry<span class="token punctuation">.</span>length <span class="token operator">></span> longest<span class="token punctuation">.</span>length <span class="token operator">?</span> entry <span class="token punctuation">:</span> longest<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">findLongest</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'aaa'</span><span class="token punctuation">,</span> <span class="token string">'bb'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "aaa"</span></code></pre><p>上面代码中，<code>reduce</code>的参数函数会将字符长度较长的那个数组成员，作为累积值。这导致遍历所有成员之后，累积值就是字符长度最长的那个成员。</p><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf() lastIndexOf()"></a>indexOf() lastIndexOf()</h3><p><code>indexOf</code>方法返回给定元素在数组中第一次出现的位置，如果没有出现则返回<code>-1</code></p><p><code>indexOf</code>方法还可以接受第二个参数，表示搜索的开始位置</p><p><code>lastIndexOf</code>方法返回给定元素在数组中最后一次出现的位置，如果没有出现则返回<code>-1</code></p><ul><li>注意，这两个方法不能用来搜索<code>NaN</code>的位置，即它们无法确定数组成员是否包含<code>NaN</code><ul><li>这是因为这两个方法内部，使用严格相等运算符（<code>===</code>）进行比较，而<code>NaN</code>是唯一一个不等于自身的值。</li></ul></li></ul><h2 id="参见"><a href="#参见" class="headerlink" title="参见"></a><a href="http://wangdoc.com/javascript/stdlib/array.html" target="_blank" rel="noopener">参见</a></h2>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习5-属性描述对象</title>
      <link href="/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A05-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A05-%E5%B1%9E%E6%80%A7%E6%8F%8F%E8%BF%B0%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<ul><li><p>如果属性已经存在，<code>Object.defineProperty()</code>方法相当于更新该属性的属性描述对象。</p></li><li><p>如果一次性定义或修改多个属性，可以使用<code>Object.defineProperties()</code>方法。</p></li><li><p>注意，一旦定义了取值函数<code>get</code>（或存值函数<code>set</code>），就不能将<code>writable</code>属性设为<code>true</code>，或者同时定义<code>value</code>属性，否则会报错。</p></li><li><p><code>Object.defineProperty()</code>和<code>Object.defineProperties()</code>参数里面的属性描述对象，<code>writable</code>、<code>configurable</code>、<code>enumerable</code>这三个属性的默认值都为<code>false</code>。</p></li><li><p>对于<code>writeable</code>为<code>false</code>的 在严格模式下,修改值报错,但是普通模式不报错,会默认失效.</p></li><li><p>如果原型对象的某个属性的<code>writable</code>为<code>false</code>，那么子对象将无法自定义这个属性。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> proto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  value<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span>  writable<span class="token punctuation">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proto<span class="token punctuation">)</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'b'</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span>foo <span class="token comment" spellcheck="true">// 'a'</span></code></pre></li><li><p>但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制。原因是这种情况下，原型链会被完全忽视。</p></li></ul><h2 id="元属性"><a href="#元属性" class="headerlink" title="元属性"></a>元属性</h2><p>属性描述对象的各个属性称为“元属性”，因为它们可以看作是控制属性的属性。</p><h2 id="enumberable"><a href="#enumberable" class="headerlink" title="enumberable"></a>enumberable</h2><p>如果一个属性的<code>enumerable</code>为<code>false</code>，下面三个操作不会取到该属性。</p><ul><li><code>for..in</code>循环</li><li><code>Object.keys</code>方法</li><li><code>JSON.stringify</code>方法</li></ul><p><code>JSON.stringify</code>方法会排除<code>enumerable</code>为<code>false</code>的属性，有时可以利用这一点。如果对象的 JSON 格式输出要排除某些属性，就可以把这些属性的<code>enumerable</code>设为<code>false</code>。</p><h2 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h2><p>有时，我们需要将一个对象的所有属性，拷贝到另一个对象，可以用下面的方法实现。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> extend <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> property <span class="token keyword">in</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    to<span class="token punctuation">[</span>property<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">from</span><span class="token punctuation">[</span>property<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> to<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// {a: 1}</span></code></pre><p>上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。</p><pre><code>extend({}, {  get a() { return 1 }})// {a: 1}</code></pre><p>为了解决这个问题，我们可以通过<code>Object.defineProperty</code>方法来拷贝属性。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> extend <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>to<span class="token punctuation">,</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> property <span class="token keyword">in</span> <span class="token keyword">from</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token keyword">from</span><span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>property<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">continue</span><span class="token punctuation">;</span>    Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>      to<span class="token punctuation">,</span>      property<span class="token punctuation">,</span>      Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token keyword">from</span><span class="token punctuation">,</span> property<span class="token punctuation">)</span>    <span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> to<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">extend</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token keyword">get</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// { get a(){ return 1 } })</span></code></pre><p>上面代码中，<code>hasOwnProperty</code>那一行用来过滤掉继承的属性，否则会报错，因为<code>Object.getOwnPropertyDescriptor</code>读不到继承属性的属性描述对象。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习4-标准库</title>
      <link href="/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A04-%E6%A0%87%E5%87%86%E5%BA%93/"/>
      <url>/2018/11/05/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A04-%E6%A0%87%E5%87%86%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="Object对象"><a href="#Object对象" class="headerlink" title="Object对象"></a>Object对象</h1><p>JavaScript原生提供的<code>Object</code>.其他对象都继承自<code>Object</code>对象.</p><p><code>Object</code>对象的原生方法分成两类：<code>Object</code>本身的方法与<code>Object</code>的实例方法。</p><ul><li><p>本身的方法: 定义在Object对象的方法</p><p><code>Object.print = function (o) { console.log(o) };</code></p></li><li><p>实例方法: 定义在Object.prototype 原型的方法, 可以被实例直接使用</p></li></ul><h2 id="Object"><a href="#Object" class="headerlink" title="Object()"></a>Object()</h2><p>本身是一个函数, 如果参数是空, 则返回空对象;</p><ul><li><p><code>Object</code>函数的参数是各种原始类型的值，转换成对象就是原始类型值对应的包装对象。</p></li><li><p>如果<code>Object</code>方法的参数是一个对象，它总是返回该对象，即不用转换。</p><p>利用这一点，可以写一个判断变量是否为对象的函数。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">isObjcet</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">===</span> <span class="token function">Object</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token function">isObject</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">isObject</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// false</span></code></pre></li></ul><h3 id="验证实例是否是构造函数的实例-instanceof"><a href="#验证实例是否是构造函数的实例-instanceof" class="headerlink" title="验证实例是否是构造函数的实例 - instanceof"></a>验证实例是否是构造函数的实例 - instanceof</h3><p><code>instanceof</code>运算符用来验证，一个对象是否为指定的构造函数的实例。<code>obj instanceof Object</code>返回<code>true</code>，就表示<code>obj</code>对象是<code>Object</code>的实例。</p><h2 id="Object-构造函数"><a href="#Object-构造函数" class="headerlink" title="Object 构造函数"></a>Object 构造函数</h2><p><code>Object</code>构造函数的首要用途，是直接通过它来生成新对象。</p><blockquote><p>注意，通过<code>var obj = new Object()</code>的写法生成新对象，与字面量的写法<code>var obj = {}</code>是等价的。或者说，后者只是前者的一种简便写法。</p></blockquote><h2 id="Object-和-new-Object"><a href="#Object-和-new-Object" class="headerlink" title="Object 和 new Object"></a>Object 和 new Object</h2><p>用法相似,但两者作用完全不同, <code>Object(value)</code>是将value转化为对象, <code>new Object(value)</code>,则表示生成一个对象, 值是value;</p><h2 id="Object的静态方法"><a href="#Object的静态方法" class="headerlink" title="Object的静态方法"></a>Object的静态方法</h2><p>所谓“静态方法”，是指部署在<code>Object</code>对象自身的方法。</p><h3 id="Object-keys-和Object-getOwnPropretyNames"><a href="#Object-keys-和Object-getOwnPropretyNames" class="headerlink" title="Object.keys() 和Object.getOwnPropretyNames()"></a><code>Object.keys()</code> 和<code>Object.getOwnPropretyNames()</code></h3><p>都是用来遍历对象属性的. 括号中是要遍历的对象, 返回一个数组,包含对象自身的属性. 一般来说二者返回的是一样的,只有涉及不可枚举对象时, <code>keys()</code>只返回可以枚举的, 另一个还返回不可枚举的.</p><blockquote><p>一般使用<code>keys()</code>, 获取属性个数可以<code>Object.keys().length</code></p></blockquote><h2 id="Object的实例方法"><a href="#Object的实例方法" class="headerlink" title="Object的实例方法"></a>Object的实例方法</h2><p>定义在<code>Object.prototype</code>的方法,可以被每个实例直接使用的方法.</p><h3 id="Object-prototype-valueOf"><a href="#Object-prototype-valueOf" class="headerlink" title="Object.prototype.valueOf"></a><code>Object.prototype.valueOf</code></h3><p><code>valueOf</code>方法的作用是返回一个对象的“值”，默认情况下返回对象本身。<code>valueOf</code>方法的主要用途<br>是，JavaScript 自动类型转换时会默认调用这个方法.</p><h3 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString"></a><code>Object.prototype.toString</code></h3><p><code>toString</code>方法的作用是返回一个对象的字符串形式，默认情况下返回类型字符串。</p><blockquote><p>对于一个对象调用<code>toString</code>方法，会返回字符串<code>[object Object]</code>，该字符串说明对象的类型。</p></blockquote><p><strong>数组、字符串、函数、Date 对象都分别部署了自定义的<code>toString</code>方法，覆盖了<code>Object.prototype.toString</code>方法。</strong></p><pre class=" language-js"><code class="language-js"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "1,2,3"</span><span class="token string">'123'</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "123"</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token number">123</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// "function () {</span><span class="token comment" spellcheck="true">//   return 123;</span><span class="token comment" spellcheck="true">// }"</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// "Tue May 10 2016 09:11:31 GMT+0800 (CST)"</span></code></pre><p>由此可见, 为了防止自定义<code>toString</code>属性, 覆盖掉<code>Object.prototype.toString</code>方法，所以为了得到类型字符串，最好直接使用<code>Object.prototype.toString</code>方法。通过函数的<code>call</code>方法，可以在任意值上调用这个方法，帮助我们判断这个值的类型。</p><p><code>Object.prototype.toString.call(value)</code></p><p>上面的方法,不同数据类型的<code>Object.prototype.toString</code>方法返回值如下。</p><ul><li>数值：返回<code>[object Number]</code>。</li><li>字符串：返回<code>[object String]</code>。</li><li>布尔值：返回<code>[object Boolean]</code>。</li><li>undefined：返回<code>[object Undefined]</code>。</li><li>null：返回<code>[object Null]</code>。</li><li>数组：返回<code>[object Array]</code>。</li><li>arguments 对象：返回<code>[object Arguments]</code>。</li><li>函数：返回<code>[object Function]</code>。</li><li>Error 对象：返回<code>[object Error]</code>。</li><li>Date 对象：返回<code>[object Date]</code>。</li><li>RegExp 对象：返回<code>[object RegExp]</code>。</li><li>其他对象：返回<code>[object Object]</code>。</li></ul><p>这就是说，<code>Object.prototype.toString</code>可以看出一个值到底是什么类型。</p><p><strong>利用这个特性，可以写出一个比<code>typeof</code>运算符更准确的类型判断函数。</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> type <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token keyword">var</span> s <span class="token operator">=</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>toString<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/\[object (.*?)\]/</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toLowerCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "object"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "array"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "number"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "null"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "undefined"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token regex">/abcd/</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "regex"</span><span class="token function">type</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// "date"</span></code></pre><h2 id="详见"><a href="#详见" class="headerlink" title="详见"></a><a href="http://wangdoc.com/javascript/stdlib/object.html" target="_blank" rel="noopener">详见</a></h2>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>html的lang到底怎么写</title>
      <link href="/2018/11/02/html%E7%9A%84lang%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%86%99/"/>
      <url>/2018/11/02/html%E7%9A%84lang%E5%88%B0%E5%BA%95%E6%80%8E%E4%B9%88%E5%86%99/</url>
      
        <content type="html"><![CDATA[<p>单一的 zh 和 zh-CN 均属于废弃用法。</p><p>如何标记的例子：</p><ol><li>简体中文页面：html lang=zh-cmn-Hans</li><li>繁体中文页面：html lang=zh-cmn-Hant</li><li>英语页面：html lang=en</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>es6这些就够了</title>
      <link href="/2018/10/31/es6%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/"/>
      <url>/2018/10/31/es6%E8%BF%99%E4%BA%9B%E5%B0%B1%E5%A4%9F%E4%BA%86/</url>
      
        <content type="html"><![CDATA[<p>刚开始用vue或者react，很多时候我们都会把ES6这位大兄dei加入我们的技术栈中。但是ES6那么多那么多特性，我们真的需要全部都掌握吗？秉着二八原则，掌握好常用的、有用的这个可以让我们的开发快速起飞。</p><p>接下来我们就聊聊ES6那些可爱的新特性吧。</p><h2 id="1-变量声明const和let"><a href="#1-变量声明const和let" class="headerlink" title="1.变量声明const和let"></a>1.变量声明const和let</h2><p>在ES6之前，我们都是用var关键字声明变量。无论声明在何处，都会被视为声明在函数的最顶部(不在函数内即在全局作用域的最顶部)。这就是函数变量提升例如:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> test <span class="token operator">=</span> <span class="token string">'hello man'</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>以上的代码实际上是：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">var</span> test <span class="token comment" spellcheck="true">// 变量提升，函数最顶部 </span>  <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    test <span class="token operator">=</span> <span class="token string">'hello man'</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//此处访问 test 值为 undefined</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//此处访问 test 值为 undefined</span><span class="token punctuation">}</span></code></pre><p>所以不用关心flag是否为 true or false。实际上，无论如何 test 都会被创建声明。 </p><p>接下来ES6主角登场：</p><p>我们通常用 let 和 const 来声明，let 表示变量、const 表示常量。let 和 const 都是块级作用域。怎么理解这个块级作用域？ </p><ul><li>在一个函数内部</li><li>在一个代码块内部</li></ul><blockquote><p>说白了只要在{}花括号内的代码块即可以认为 let 和 const 的作用域。 </p></blockquote><p>看以下代码：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">aa</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> test <span class="token operator">=</span> <span class="token string">'hello man'</span>   <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//test 在此处访问不到</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>test<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>let 的作用域是在它所在当前代码块，但不会被提升到当前函数的最顶部。 </p><p>再来说说 const </p><p>const 声明的变量必须提供一个值，而且会被认为是常量，意思就是它的值被设置完成后就不能再修改了。 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'lux'</span> name <span class="token operator">=</span> <span class="token string">'joe'</span> <span class="token comment" spellcheck="true">// 再次赋值此时会报错 </span></code></pre><p>还有，如果 const 的是一个对象，对象所包含的值是可以被修改的。抽象一点儿说，就是对象所指向的地址不能改变，而变量成员是可以修改的。 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> student <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'cc'</span> <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 没毛病</span>student<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'yy'</span> <span class="token comment" spellcheck="true">// 如果这样子就会报错了</span>student <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'yy'</span> <span class="token punctuation">}</span> <span class="token function">说说TDZ</span><span class="token punctuation">(</span>暂时性死区<span class="token punctuation">)</span>，想必你早有耳闻。<span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 报错 </span>  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token string">'lala'</span> <span class="token punctuation">}</span></code></pre><p>我们都知道，JS引擎扫描代码时，如果发现变量声明，用 var 声明变量时会将声明提升到函数或全局作用域的顶部。但是 let 或者 const，会将声明关进一个小黑屋也是TDZ(暂时性死区)，只有执行到变量声明这句语句时，变量才会从小黑屋被放出来，才能安全使用这个变量。 </p><p>哦了，说一道面试题</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     funcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>funcs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>这样的面试题是大家很常见，很多同学一看就知道输出十次10</p><p>但是如果我们想依次输出0到9呢？</p><p>有两种解决方法，直接看一下代码：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ES5知识，我们可以利用“立即调用函数”解决这个问题</span><span class="token keyword">var</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   funcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>    <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">)</span><span class="token punctuation">}</span>funcs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 再来看看es6怎么处理的</span><span class="token keyword">const</span> funcs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   funcs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span>funcs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>func <span class="token operator">=</span><span class="token operator">></span> <span class="token function">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> </code></pre><p>达到相同的效果，ES6 简洁的解决方案是不是更让你心动！！！</p><h2 id="2-字符串"><a href="#2-字符串" class="headerlink" title="2.字符串"></a>2.字符串</h2><p>先聊聊模板字符串</p><p>ES6模板字符简直是开发者的福音啊，解决了 ES5 在字符串功能上的痛点。</p><p>第一个用途，基本的字符串格式化。将表达式嵌入字符串中进行拼接。用${}来界定。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//ES5</span><span class="token keyword">var</span> name <span class="token operator">=</span> <span class="token string">'lux'</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span> <span class="token operator">+</span> name<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//es6</span><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'lux'</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//hello lux </span></code></pre><p>第二个用途，在ES5时我们通过反斜杠()来做多行字符串或者字符串一行行拼接。ES6反引号(``)直接搞定。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// ES5</span><span class="token keyword">var</span> msg <span class="token operator">=</span> "Hi \ <span class="token template-string"><span class="token string">``</span></span><span class="token template-string"><span class="token string">`man!"`</span></span><span class="token template-string"><span class="token string">``</span></span><span class="token comment" spellcheck="true">// ES6</span><span class="token keyword">const</span> template <span class="token operator">=</span> <span class="token template-string"><span class="token string">`&lt;div> &lt;span>hello world&lt;/span>&lt;/div>`</span></span></code></pre><p>对于字符串 ES6+ 当然也提供了很多厉害也很有意思的方法 说几个常用的。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 1.includes：判断是否包含然后直接返回布尔值</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hahay'</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">includes</span><span class="token punctuation">(</span><span class="token string">'y'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true </span><span class="token comment" spellcheck="true">// 2.repeat: 获取字符串重复n次</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'he'</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 'hehehe' </span><span class="token comment" spellcheck="true">//如果你带入小数, Math.floor(num) 来处理</span><span class="token comment" spellcheck="true">// s.repeat(3.1) 或者 s.repeat(3.9) 都当做成 s.repeat(3) 来处理</span><span class="token comment" spellcheck="true">// 3. startsWith 和 endsWith 判断是否以 给定文本 开始或者结束</span><span class="token keyword">const</span> str <span class="token operator">=</span> <span class="token string">'hello world!'</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">startsWith</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">'!'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true </span><span class="token comment" spellcheck="true">// 4. padStart 和 padEnd 填充字符串，应用场景：时分秒</span><span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span> <span class="token keyword">const</span> now <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> hours <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">getHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> minutes <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">getMinutes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> seconds <span class="token operator">=</span> now<span class="token punctuation">.</span><span class="token function">getSeconds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hours<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>minutes<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>seconds<span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span> </code></pre><p>关于模板字符串现在比较常出现的面试题有两道。同学们不妨写试试看？</p><ul><li><p>模拟一个模板字符串的实现。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> address <span class="token operator">=</span> <span class="token string">'北京海淀区'</span> <span class="token keyword">let</span> name <span class="token operator">=</span> <span class="token string">'lala'</span> <span class="token keyword">let</span> str <span class="token operator">=</span> <span class="token string">'${name}在${address}上班...'</span> <span class="token comment" spellcheck="true">// 模拟一个方法 myTemplate(str) 最终输出 'lala在北京海淀区上班...'</span><span class="token keyword">function</span> <span class="token function">myTemplate</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// try it</span><span class="token punctuation">}</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">myTemplate</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// lala在北京海淀区上班... </span></code></pre></li><li><p>实现标签化模板(自定义模板规则)。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> name <span class="token operator">=</span> <span class="token string">'cc'</span> <span class="token keyword">const</span> gender <span class="token operator">=</span> <span class="token string">'male'</span> <span class="token keyword">const</span> hobby <span class="token operator">=</span> <span class="token string">'basketball'</span> <span class="token comment" spellcheck="true">// 实现tag最终输出 '姓名：**cc**，性别：**male**，爱好：**basketball**'</span><span class="token keyword">function</span> <span class="token function">tag</span><span class="token punctuation">(</span>strings<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// do it</span><span class="token punctuation">}</span><span class="token keyword">const</span> str <span class="token operator">=</span> tag<span class="token template-string"><span class="token string">`姓名：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，性别：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>gender<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">，爱好：</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>hobby<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// '姓名：**cc**，性别：**male**，爱好：**basketball**' </span></code></pre></li></ul><h2 id="3-函数"><a href="#3-函数" class="headerlink" title="3.函数"></a>3.函数</h2><p>函数默认参数</p><p>在ES5我们给函数定义参数默认值是怎么样？</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">action</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>   num <span class="token operator">=</span> num <span class="token operator">||</span> <span class="token number">200</span>   <span class="token comment" spellcheck="true">//当传入num时，num为传入的值</span>  <span class="token comment" spellcheck="true">//当没传入参数时，num即有了默认值200</span>  <span class="token keyword">return</span> num <span class="token punctuation">}</span></code></pre><p>但细心观察的同学们肯定会发现，num传入为0的时候就是false，但是我们实际的需求就是要拿到num = 0，此时num = 200 明显与我们的实际想要的效果明显不一样</p><p>ES6为参数提供了默认值。在定义函数时便初始化了这个参数，以便在参数没有被传递进去时使用。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">action</span><span class="token punctuation">(</span>num <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0 </span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//200 </span><span class="token function">action</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//300 </span></code></pre><p>箭头函数</p><p>ES6很有意思的一部分就是函数的快捷写法。也就是箭头函数。</p><p>箭头函数最直观的三个特点。</p><ul><li>不需要 function 关键字来创建函数 </li><li>省略 return 关键字 </li><li>继承当前上下文的 this 关键字 </li></ul><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//例如：</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>x <span class="token operator">=</span><span class="token operator">></span> x <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//等同于：</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>说个小细节。</p><p>当你的函数有且仅有一个参数的时候，是可以省略掉括号的。当你函数返回有且仅有一个表达式的时候可以省略{} 和 return；例如:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> people <span class="token operator">=</span> name <span class="token operator">=</span><span class="token operator">></span> <span class="token string">'hello'</span> <span class="token operator">+</span> name <span class="token comment" spellcheck="true">//参数name就没有括号</span>作为参考<span class="token keyword">var</span> people <span class="token operator">=</span> <span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   <span class="token keyword">const</span> fullName <span class="token operator">=</span> <span class="token string">'hello'</span> <span class="token operator">+</span> name   <span class="token keyword">return</span> fullName <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//如果缺少()或者{}就会报错</span></code></pre><p>要不整一道笔试题？哈哈哈哈哈哈哈哈。我不管我先上代码了</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 请使用ES6重构以下代码</span><span class="token keyword">var</span> calculate <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> x <span class="token operator">!=</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> x <span class="token operator">=</span> <span class="token number">0</span> <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> y <span class="token operator">!=</span> <span class="token string">'number'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> y <span class="token operator">=</span> <span class="token number">6</span> <span class="token punctuation">}</span>   <span class="token keyword">var</span> dwt <span class="token operator">=</span> x <span class="token operator">%</span> y   <span class="token keyword">var</span> result   <span class="token keyword">if</span> <span class="token punctuation">(</span>dwt <span class="token operator">==</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span> result <span class="token operator">=</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>   <span class="token keyword">if</span> <span class="token punctuation">(</span>dwt <span class="token operator">!=</span> z<span class="token punctuation">)</span> <span class="token punctuation">{</span> result <span class="token operator">=</span> <span class="token boolean">false</span> <span class="token punctuation">}</span>   <span class="token keyword">return</span> result <span class="token punctuation">}</span><span class="token keyword">const</span> calculate <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>   x <span class="token operator">=</span> <span class="token keyword">typeof</span> x <span class="token operator">!==</span> <span class="token string">'number'</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> x   y <span class="token operator">=</span> <span class="token keyword">typeof</span> y <span class="token operator">!==</span> <span class="token string">'number'</span> <span class="token operator">?</span> <span class="token number">6</span> <span class="token punctuation">:</span> y   <span class="token keyword">return</span> x <span class="token operator">%</span> y <span class="token operator">===</span> z <span class="token punctuation">}</span></code></pre><h2 id="4-拓展的对象功能"><a href="#4-拓展的对象功能" class="headerlink" title="4.拓展的对象功能"></a>4.拓展的对象功能</h2><p>对象初始化简写</p><p>ES5我们对于对象都是以键值对的形式书写，是有可能出现键值对重名的。例如：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">people</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">{</span>     name<span class="token punctuation">:</span> name<span class="token punctuation">,</span>    age<span class="token punctuation">:</span> age  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>键值对重名，ES6可以简写如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">people</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> <span class="token punctuation">{</span>     name<span class="token punctuation">,</span>    age  <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>ES6 同样改进了为对象字面量方法赋值的语法。ES5为对象添加方法：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'lux'</span><span class="token punctuation">,</span>   getName<span class="token punctuation">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ES6通过省略冒号与 function 关键字，将这个语法变得更简洁 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'lux'</span><span class="token punctuation">,</span>   getName <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ES6 对象提供了 Object.assign()这个方法来实现浅复制。 </p><p>Object.assign() 可以把任意多个源对象自身可枚举的属性拷贝给目标对象，然后返回目标对象。第一参数即为目标对象。在实际项目中，我们为了不改变源对象。一般会把目标对象传为{} </p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> objA <span class="token operator">=</span> <span class="token punctuation">{</span> name<span class="token punctuation">:</span> <span class="token string">'cc'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span> <span class="token punctuation">}</span> <span class="token keyword">const</span> objB <span class="token operator">=</span> <span class="token punctuation">{</span> address<span class="token punctuation">:</span> <span class="token string">'beijing'</span> <span class="token punctuation">}</span> <span class="token keyword">const</span> objC <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 这个为目标对象 </span><span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>objC<span class="token punctuation">,</span> objA<span class="token punctuation">,</span> objB<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 我们将 objA objB objC obj 分别输出看看</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>objA<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { name: 'cc', age: 18 } </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>objB<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { address: 'beijing' } </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>objC<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { name: 'cc', age: 18, address: 'beijing' } </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { name: 'cc', age: 18, address: 'beijing' } </span><span class="token comment" spellcheck="true">// 是的，目标对象ObjC的值被改变了。</span><span class="token comment" spellcheck="true">// so，如果objC也是你的一个源对象的话。请在objC前面填在一个目标对象{}</span></code></pre><p>Object.assign({}, objC, objA, objB)</p><h2 id="5-更方便的数据访问–解构"><a href="#5-更方便的数据访问–解构" class="headerlink" title="5.更方便的数据访问–解构"></a>5.更方便的数据访问–解构</h2><p>数组和对象是JS中最常用也是最重要表示形式。为了简化提取信息，ES6新增了解构，这是将一个数据结构分解为更小的部分的过程</p><p>ES5我们提取对象中的信息形式如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'lux'</span><span class="token punctuation">,</span>   age<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token keyword">const</span> name <span class="token operator">=</span> people<span class="token punctuation">.</span>name <span class="token keyword">const</span> age <span class="token operator">=</span> people<span class="token punctuation">.</span>age console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>name <span class="token operator">+</span> <span class="token string">' --- '</span> <span class="token operator">+</span> age<span class="token punctuation">)</span> </code></pre><p>是不是觉得很熟悉，没错，在ES6之前我们就是这样获取对象信息的，一个一个获取。现在，解构能让我们从对象或者数组里取出数据存为变量，例如</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//对象</span><span class="token keyword">const</span> people <span class="token operator">=</span> <span class="token punctuation">{</span>   name<span class="token punctuation">:</span> <span class="token string">'lux'</span><span class="token punctuation">,</span>   age<span class="token punctuation">:</span> <span class="token number">20</span> <span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token punctuation">{</span> name<span class="token punctuation">,</span> age <span class="token punctuation">}</span> <span class="token operator">=</span> people console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> --- </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//数组</span><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'blue'</span><span class="token punctuation">]</span> <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> second<span class="token punctuation">]</span> <span class="token operator">=</span> color console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//'red' </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>second<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//'blue' </span></code></pre><p>要不来点儿面试题，看看自己的掌握情况？</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 请使用 ES6 重构一下代码</span><span class="token comment" spellcheck="true">// 第一题</span><span class="token keyword">var</span> jsonParse <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>jsonParse <span class="token comment" spellcheck="true">// 第二题</span><span class="token keyword">var</span> body <span class="token operator">=</span> request<span class="token punctuation">.</span>body <span class="token keyword">var</span> username <span class="token operator">=</span> body<span class="token punctuation">.</span>username <span class="token keyword">var</span> password <span class="token operator">=</span> body<span class="token punctuation">.</span>password <span class="token comment" spellcheck="true">// 1.</span><span class="token keyword">import</span> <span class="token punctuation">{</span> jsonParse <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'body-parser'</span> <span class="token comment" spellcheck="true">// 2.</span><span class="token keyword">const</span> <span class="token punctuation">{</span> body<span class="token punctuation">,</span> body<span class="token punctuation">:</span> <span class="token punctuation">{</span> username<span class="token punctuation">,</span> password <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token operator">=</span> request </code></pre><h2 id="6-Spread-Operator-展开运算符"><a href="#6-Spread-Operator-展开运算符" class="headerlink" title="6.Spread Operator 展开运算符"></a>6.Spread Operator 展开运算符</h2><p>ES6中另外一个好玩的特性就是Spread Operator 也是三个点儿…接下来就展示一下它的用途。</p><p>组装对象或者数组</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//数组</span><span class="token keyword">const</span> color <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'red'</span><span class="token punctuation">,</span> <span class="token string">'yellow'</span><span class="token punctuation">]</span> <span class="token keyword">const</span> colorful <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span>color<span class="token punctuation">,</span> <span class="token string">'green'</span><span class="token punctuation">,</span> <span class="token string">'pink'</span><span class="token punctuation">]</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>colorful<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//[red, yellow, green, pink] </span><span class="token comment" spellcheck="true">//对象</span><span class="token keyword">const</span> alp <span class="token operator">=</span> <span class="token punctuation">{</span> fist<span class="token punctuation">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> second<span class="token punctuation">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span> <span class="token keyword">const</span> alphabets <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>alp<span class="token punctuation">,</span> third<span class="token punctuation">:</span> <span class="token string">'c'</span> <span class="token punctuation">}</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>alphabets<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//{ "fist": "a", "second": "b", "third": "c" }</span></code></pre><p>有时候我们想获取数组或者对象除了前几项或者除了某几项的其他项</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//数组</span><span class="token keyword">const</span> number <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token keyword">const</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> number console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//2,3,4,5 </span><span class="token comment" spellcheck="true">//对象</span><span class="token keyword">const</span> user <span class="token operator">=</span> <span class="token punctuation">{</span>   username<span class="token punctuation">:</span> <span class="token string">'lux'</span><span class="token punctuation">,</span>   gender<span class="token punctuation">:</span> <span class="token string">'female'</span><span class="token punctuation">,</span>   age<span class="token punctuation">:</span> <span class="token number">19</span><span class="token punctuation">,</span>   address<span class="token punctuation">:</span> <span class="token string">'peking'</span> <span class="token punctuation">}</span><span class="token keyword">const</span> <span class="token punctuation">{</span> username<span class="token punctuation">,</span> <span class="token operator">...</span>rest <span class="token punctuation">}</span> <span class="token operator">=</span> user console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>rest<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//{"address": "peking", "age": 19, "gender": "female" }</span></code></pre><p>对于 Object 而言，还可以用于组合成新的 Object 。(ES2017 stage-2 proposal) 当然如果有重复的属性名，右边覆盖左边</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> first <span class="token operator">=</span> <span class="token punctuation">{</span>   a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>   b<span class="token punctuation">:</span> <span class="token number">2</span><span class="token punctuation">,</span>   c<span class="token punctuation">:</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token punctuation">}</span><span class="token keyword">const</span> second <span class="token operator">=</span> <span class="token punctuation">{</span>   c<span class="token punctuation">:</span> <span class="token number">3</span><span class="token punctuation">,</span>   d<span class="token punctuation">:</span> <span class="token number">4</span> <span class="token punctuation">}</span><span class="token keyword">const</span> total <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>second <span class="token punctuation">}</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>total<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { a: 1, b: 2, c: 3, d: 4 } </span></code></pre><h2 id="7-import-和-export"><a href="#7-import-和-export" class="headerlink" title="7.import 和 export"></a>7.import 和 export</h2><p>import导入模块、export导出模块</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//全部导入</span><span class="token keyword">import</span> people <span class="token keyword">from</span> <span class="token string">'./example'</span> <span class="token comment" spellcheck="true">//有一种特殊情况，即允许你将整个模块当作单一对象进行导入</span><span class="token comment" spellcheck="true">//该模块的所有导出都会作为对象的属性存在</span><span class="token keyword">import</span> <span class="token operator">*</span> <span class="token keyword">as</span> example <span class="token keyword">from</span> <span class="token string">"./example.js"</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span>name<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span>age<span class="token punctuation">)</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>example<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//导入部分</span><span class="token keyword">import</span> <span class="token punctuation">{</span>name<span class="token punctuation">,</span> age<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./example'</span> <span class="token comment" spellcheck="true">// 导出默认, 有且只有一个默认</span><span class="token keyword">export</span> <span class="token keyword">default</span> App <span class="token comment" spellcheck="true">// 部分导出</span><span class="token keyword">export</span> <span class="token keyword">class</span> <span class="token class-name">App</span> extend Component <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> </code></pre><p>以前有人问我，导入的时候有没有大括号的区别是什么。下面是我在工作中的总结：</p><ol><li><p>当用export default people导出时，就用 import people 导入（不带大括号） </p></li><li><p>一个文件里，有且只能有一个export default。但可以有多个export。 </p></li><li><p>当用export name 时，就用import { name }导入（记得带上大括号） </p></li><li><p>当一个文件里，既有一个export default people, 又有多个export name 或者 export age时，导入就用 import people, { name, age } </p></li><li><p>当一个文件里出现n多个 export 导出很多模块，导入时除了一个一个导入，也可以用import * as example </p></li></ol><h2 id="8-Promise"><a href="#8-Promise" class="headerlink" title="8. Promise"></a>8. Promise</h2><blockquote><p>在promise之前代码过多的回调或者嵌套，可读性差、耦合度高、扩展性低。通过Promise机制，扁平化的代码机构，大大提高了代码可读性；用同步编程的方式来编写异步代码，保存线性的代码逻辑，极大的降低了代码耦合性而提高了程序的可扩展性。</p></blockquote><p>说白了就是用同步的方式去写异步代码。</p><p>发起异步请求</p><pre class=" language-js"><code class="language-js"><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api/todos'</span><span class="token punctuation">)</span>  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>res <span class="token operator">=</span><span class="token operator">></span> res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>     <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>data <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> data <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token punctuation">.</span><span class="token keyword">catch</span><span class="token punctuation">(</span>err <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token punctuation">{</span> err <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><p>今天看到一篇关于面试题的很有意思。</p><pre class=" language-js"><code class="language-js"><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">executor</span><span class="token punctuation">(</span>resolve<span class="token punctuation">)</span> <span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span><span class="token punctuation">(</span> <span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span> <span class="token punctuation">;</span> i<span class="token operator">&lt;</span><span class="token number">10000</span> <span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>     i <span class="token operator">==</span> <span class="token number">9999</span> <span class="token operator">&amp;&amp;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><a href="https://zhuanlan.zhihu.com/p/25407758" target="_blank" rel="noopener">Excuse me？这个前端面试在搞事！</a></p><p>当然以上promise的知识点，这个只是冰山一角。需要更多地去学习了解一下。</p><h2 id="9-Generators"><a href="#9-Generators" class="headerlink" title="9.Generators"></a>9.Generators</h2><p>生成器（ generator）是能返回一个迭代器的函数。生成器函数也是一种函数，最直观的表现就是比普通的function多了个星号*，在其函数体内可以使用yield关键字,有意思的是函数会在每个yield后暂停。</p><p>这里生活中有一个比较形象的例子。咱们到银行办理业务时候都得向大厅的机器取一张排队号。你拿到你的排队号，机器并不会自动为你再出下一张票。也就是说取票机“暂停”住了，直到下一个人再次唤起才会继续吐票。</p><p>OK。说说迭代器。当你调用一个generator时，它将返回一个迭代器对象。这个迭代器对象拥有一个叫做next的方法来帮助你重启generator函数并得到下一个值。next方法不仅返回值，它返回的对象具有两个属性：done和value。value是你获得的值，done用来表明你的generator是否已经停止提供值。继续用刚刚取票的例子，每张排队号就是这里的value，打印票的纸是否用完就这是这里的done。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 生成器</span><span class="token keyword">function</span> <span class="token operator">*</span><span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>   <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>   <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 生成器能像正规函数那样被调用，但会返回一个迭代器</span><span class="token keyword">let</span> iterator <span class="token operator">=</span> <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 1 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 2 </span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 3 </span></code></pre><p>那生成器和迭代器又有什么用处呢？</p><p>围绕着生成器的许多兴奋点都与异步编程直接相关。异步调用对于我们来说是很困难的事，我们的函数并不会等待异步调用完再执行，你可能会想到用回调函数，（当然还有其他方案比如Promise比如Async/await）。</p><p>生成器可以让我们的代码进行等待。就不用嵌套的回调函数。使用generator可以确保当异步调用在我们的generator函数运行一下行代码之前完成时暂停函数的执行。</p><p>那么问题来了，咱们也不能手动一直调用next()方法，你需要一个能够调用生成器并启动迭代器的方法。就像这样子的</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span>taskDef<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">//taskDef即一个生成器函数 </span>  <span class="token comment" spellcheck="true">// 创建迭代器，让它在别处可用</span>  <span class="token keyword">let</span> task <span class="token operator">=</span> <span class="token function">taskDef</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 启动任务</span>  <span class="token keyword">let</span> result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 递归使用函数来保持对 next() 的调用</span>  <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 如果还有更多要做的</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span> <span class="token punctuation">{</span>       result <span class="token operator">=</span> task<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 开始处理过程</span>    <span class="token function">step</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>生成器与迭代器最有趣、最令人激动的方面，或许就是可创建外观清晰的异步操作代码。你不必到处使用回调函数，而是可以建立貌似同步的代码，但实际上却使用 yield 来等待异步操作结束。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>ES6新特性远不止于此，但对于我们日常的开发来说。这算不上全部，但是能算得上是高频使用了。当然还有很有好玩有意思的特性。比如一些数组的新方法、class…等等。包括用set处理数组去重问题等等。我和我的小伙伴们都惊呆了!</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习3-语法</title>
      <link href="/2018/10/29/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A03-%E8%AF%AD%E6%B3%95/"/>
      <url>/2018/10/29/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A03-%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="表达式和语句的区别"><a href="#表达式和语句的区别" class="headerlink" title="表达式和语句的区别"></a>表达式和语句的区别</h2><ul><li>表达式一般都有值，语句可能有也可能没有</li><li>语句一般会改变环境（声明、赋值）</li></ul><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p><strong>规则</strong></p><ul><li>第一个字符可以是Unicode字母或$和____符号或者中文</li><li>后面的自身除了这些还能是数字。</li></ul><h2 id="if-else语句"><a href="#if-else语句" class="headerlink" title="if else语句"></a>if else语句</h2><ul><li><code>{}</code>在语句只有一句的时候可以省略，我不喜欢省略</li><li>if中 赋值操作只有是true 的时候 才会执行 if后面<code>{}</code>中的语句</li></ul><h2 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h2><h3 id="短路逻辑-amp-amp"><a href="#短路逻辑-amp-amp" class="headerlink" title="短路逻辑&amp;&amp;"></a>短路逻辑&amp;&amp;</h3><p><code>A &amp;&amp; B &amp;&amp; C &amp;&amp; D</code>取第一个假值或者D，并不会取true/false</p><h3 id="短路逻辑"><a href="#短路逻辑" class="headerlink" title="短路逻辑||"></a>短路逻辑||</h3><p><code>A || B || D || D</code>取第一个真值或者D，并不会取true/false</p><h2 id="数据类型的转换"><a href="#数据类型的转换" class="headerlink" title="数据类型的转换"></a>数据类型的转换</h2><p>JavaScript 是一种动态类型语言，变量没有类型限制，可以随时赋予任意值。</p><h3 id="强制转换-Number-String-Bookean"><a href="#强制转换-Number-String-Bookean" class="headerlink" title="强制转换 (Number(), String(), Bookean())"></a>强制转换 (Number(), String(), Bookean())</h3><h4 id="Number"><a href="#Number" class="headerlink" title="Number()"></a>Number()</h4><ol><li><p>原始类型</p></li><li><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 数值：转换后还是原来的值</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token number">324</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 324</span><span class="token comment" spellcheck="true">// 字符串：如果可以被解析为数值，则转换为相应的数值</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'324'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 324</span><span class="token comment" spellcheck="true">// 字符串：如果不可以被解析为数值，返回 NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">'324abc'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token comment" spellcheck="true">// 空字符串转为0</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span><span class="token comment" spellcheck="true">// 布尔值：true 转成 1，false 转成 0</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 1</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span><span class="token comment" spellcheck="true">// undefined：转成 NaN</span><span class="token function">Number</span><span class="token punctuation">(</span>undefined<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token comment" spellcheck="true">// null：转成0</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span></code></pre></li><li><p>对象: <code>Number</code>方法的参数是对象时，将返回<code>NaN</code>，除非是包含单个数值的数组。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// NaN</span><span class="token function">Number</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 5</span></code></pre></li></ol><h4 id="String"><a href="#String" class="headerlink" title="String()"></a>String()</h4><ol><li><p>原始类型</p><ul><li><strong>数值</strong>：转为相应的字符串。</li><li><strong>字符串</strong>：转换后还是原来的值。</li><li><strong>布尔值</strong>：<code>true</code>转为字符串<code>&quot;true&quot;</code>，<code>false</code>转为字符串<code>&quot;false&quot;</code>。</li><li><strong>undefined</strong>：转为字符串<code>&quot;undefined&quot;</code>。</li><li><strong>null</strong>：转为字符串<code>&quot;null&quot;</code>。</li></ul></li><li><p>对象 :参数如果是对象，返回一个类型字符串；如果是数组，返回该数组的字符串形式。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">{</span>a<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Object]"</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "1,2,3"</span></code></pre></li></ol><h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean()"></a>Boolean()</h4><p>除了以下五个值的转换结果为<code>false</code>，其他的值全部为<code>true</code>。</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>-0</code>或<code>+0</code></li><li><code>NaN</code></li><li><code>&#39;&#39;</code>（空字符串）</li></ul><p><strong>注意，所有对象（包括空对象）的转换结果都是<code>true</code>，甚至连<code>false</code>对应的布尔对象<code>new Boolean(false)</code>也是<code>true</code></strong></p><h4 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h4><p><strong>由于自动转换具有不确定性</strong>，而且不易除错，建议在预期为布尔值、数值、字符串的地方，全部使用<code>Boolean</code>、<code>Number</code>和<code>String</code>函数进行显式转换。</p><h2 id="错误处理机制"><a href="#错误处理机制" class="headerlink" title="错误处理机制"></a>错误处理机制</h2><p>JavaScript 原生提供<code>Error</code>构造函数，所有抛出的错误都是这个构造函数的实例。</p><h3 id="原生错误类型"><a href="#原生错误类型" class="headerlink" title="原生错误类型"></a>原生错误类型</h3><p><code>Error</code>实例对象是最一般的错误类型, 在它的基础上, JavaScript还定义了其他6种错误对象: </p><ol><li>SyntaxError : 语法错误</li><li>RefrenceError: 引用一个不存在的变量的错误<ul><li>另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者<code>this</code>赋值。</li></ul></li><li>RangeError: 一个超出有效范围时的错误, 有几种: <ul><li>数组长度为负</li><li><code>Number</code>对象的参数超出范围</li><li>函数堆栈超过最大值</li></ul></li><li>TypeError: 对象是变量或参数不是预期类型时发生的错误。</li><li>URIErrorURI 相关函数的参数不正确时抛出的错误</li><li>EvalError对象: <code>eval</code>函数没有被正确执行时，会抛出<code>EvalError</code>错误 (已不再使用)</li></ol><h3 id="throw语句"><a href="#throw语句" class="headerlink" title="throw语句"></a>throw语句</h3><p><code>throw</code>语句的作用是手动中断程序执行，抛出一个错误。有错程序就会中断;</p><h3 id="try…catch结构"><a href="#try…catch结构" class="headerlink" title="try…catch结构"></a>try…catch结构</h3><p>简单说就是在try语句中抛出的错误会被后面的catch语句所捕获, 并且把错误当作参数传给catch;</p><pre class=" language-js"><code class="language-js"><span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'出错了!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">e</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> e<span class="token punctuation">.</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>stack<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// Error: 出错了!</span><span class="token comment" spellcheck="true">//   at &lt;anonymous>:3:9</span><span class="token comment" spellcheck="true">//   ...</span></code></pre><p><code>catch</code>代码块捕获错误之后，程序不会中断，会按照正常流程继续执行下去。</p><p><code>catch</code>代码块之中，还可以再抛出错误，甚至使用嵌套的<code>try...catch</code>结构。</p><p>为了捕捉不同类型的错误，<code>catch</code>代码块之中可以加入判断语句。</p><h3 id="finally代码块"><a href="#finally代码块" class="headerlink" title="finally代码块"></a>finally代码块</h3><p><code>try...catch</code>结构允许在最后添加一个<code>finally</code>代码块，表示不管是否出现错误，都必需在最后运行的语句。</p><h2 id="编码风格"><a href="#编码风格" class="headerlink" title="编码风格"></a>编码风格</h2><ul><li><p>建议总是使用大括号表示区块。</p></li><li><p>用空格区分不同的括号 </p><ul><li><p>函数调用不要空格</p></li><li><p>表达式间用空格</p><ul><li><p>表示函数调用时，函数名与左括号之间没有空格。</p></li><li><p>表示函数定义时，函数名与左括号之间没有空格。</p></li><li><p>其他情况时，前面位置的语法元素与左括号之间，都有一个空格。</p></li></ul></li></ul></li><li><p>分号表示一条语句的结束, 所以不要省略结尾的分号;</p></li><li><p>不使用分号的情况</p><ul><li>for和while循环 结尾没有分号</li><li>if, switch, try 结尾没有分号</li><li>函数声明 没有分号</li></ul></li><li><p>避免全局变量, 不得不用时, 用首字母大写区分;</p></li><li><p>for () 循环 的 空号内部如果用 var i = 0; 会产生一个全局的变量i</p></li><li><p>比较用 <code>===</code>严格相等</p></li><li><p>所有的<code>++</code>运算符都可以用<code>+= 1</code>代替</p></li><li><p><code>switch...case</code>结构要求在每个<code>case</code>的最后一行必须是 <code>break</code>语句;</p></li></ul><h2 id="console对象和控制台"><a href="#console对象和控制台" class="headerlink" title="console对象和控制台"></a>console对象和控制台</h2><h3 id="console"><a href="#console" class="headerlink" title="console"></a>console</h3><blockquote><p><code>console</code>对象是 JavaScript 的原生对象</p></blockquote><h3 id="console-log-console-info"><a href="#console-log-console-info" class="headerlink" title="console.log() , console.info()"></a>console.log() , console.info()</h3><p><code>console.log</code>方法的第一个参数有三个占位符（<code>%s</code>），第二、三、四个参数会在显示时，依次替换掉这个三个占位符。</p><p><code>console.log</code>方法支持以下占位符，不同类型的数据必须使用对应的占位符。</p><ul><li><code>%s</code> 字符串</li><li><code>%d</code> 整数</li><li><code>%i</code> 整数</li><li><code>%f</code> 浮点数</li><li><code>%o</code> 对象的链接</li><li><code>%c</code> CSS 格式字符串</li></ul><p><code>console.info</code>是<code>console.log</code>方法的别名，用法完全一样。只不过<code>console.info</code>方法会在输出信息的前面，加上一个<strong>蓝色图标</strong>。</p><p><code>console.debug</code>方法与<code>console.log</code>方法类似，会在控制台输出调试信息。但是，默认情况下，<code>console.debug</code>输出的<strong>信息不会显示</strong>，只有在打开显示级别在<code>verbose</code>的情况下，才会显示。</p><h3 id="console-warn-，console-error"><a href="#console-warn-，console-error" class="headerlink" title="console.warn()，console.error()"></a>console.warn()，console.error()</h3><p><code>warn</code>方法和<code>error</code>方法也是在控制台输出信息，它们与<code>log</code>方法的不同之处在于，<code>warn</code>方法输出信息时，在最前面加一个<strong>黄色三角</strong>，表示警告；<code>error</code>方法输出信息时，在最前面加一个<strong>红色的叉</strong>，表示出错。同时，还会高亮显示输出文字和错误发生的堆栈。其他方面都一样。</p><h3 id="console-table"><a href="#console-table" class="headerlink" title="console.table()"></a>console.table()</h3><p>对于复合类型的数据, <code>console.table</code> 方法可以将其转为<strong>表格显示</strong>.</p><h3 id="console-count"><a href="#console-count" class="headerlink" title="console.count()"></a>console.count()</h3><p><code>count</code>方法用于计数，输出它被调用了多少次。</p><h3 id="console-dir-，console-dirxml"><a href="#console-dir-，console-dirxml" class="headerlink" title="console.dir()，console.dirxml()"></a>console.dir()，console.dirxml()</h3><p><code>dir</code>方法用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p><h3 id="console-assert"><a href="#console-assert" class="headerlink" title="console.assert()"></a>console.assert()</h3><p><code>console.assert</code>方法主要用于程序运行过程中，进行条件判断，如果不满足条件，就显示一个错误，但不会中断程序执行。这样就相当于提示用户，内部状态不正确。</p><h3 id="console-time-，console-timeEnd"><a href="#console-time-，console-timeEnd" class="headerlink" title="console.time()，console.timeEnd()"></a>console.time()，console.timeEnd()</h3><p>这两个方法用于计时，可以算出一个操作所花费的准确时间。</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token string">'Array initialize'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> array<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">timeEnd</span><span class="token punctuation">(</span><span class="token string">'Array initialize'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Array initialize: 1914.481ms</span></code></pre><p><code>time</code>方法表示计时开始，<code>timeEnd</code>方法表示计时结束。它们的参数是计时器的名称。调用<code>timeEnd</code>方法之后，控制台会显示“计时器名称: 所耗费的时间”。</p><h3 id="console-group-，console-groupEnd-，console-groupCollapsed"><a href="#console-group-，console-groupEnd-，console-groupCollapsed" class="headerlink" title="console.group()，console.groupEnd()，console.groupCollapsed()"></a>console.group()，console.groupEnd()，console.groupCollapsed()</h3><p><code>console.group</code>和<code>console.groupEnd</code>这两个方法用于将显示的信息分组。它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开</p><h3 id="console-trace-，console-clear"><a href="#console-trace-，console-clear" class="headerlink" title="console.trace()，console.clear()"></a>console.trace()，console.clear()</h3><p><code>console.trace</code>方法显示当前执行的代码在堆栈中的调用路径。</p><p><code>console.clear</code>方法用于清除当前控制台的所有输出.</p><h3 id="控制台命令行API"><a href="#控制台命令行API" class="headerlink" title="控制台命令行API"></a>控制台命令行API</h3><h4 id><a href="#" class="headerlink" title="$_"></a><code>$_</code></h4><p>返回上一个表达式的值</p><h4 id="0-4"><a href="#0-4" class="headerlink" title="$0-$4"></a><code>$0</code>-<code>$4</code></h4><p>控制台保存了最近5个在 Elements 面板选中的 DOM 元素，<code>$0</code>代表倒数第一个（最近一个），<code>$1</code>代表倒数第二个，以此类推直到<code>$4</code>。</p><h4 id="selector"><a href="#selector" class="headerlink" title="$(selector)"></a><code>$(selector)</code></h4><p><code>$(selector)</code>返回第一个匹配的元素，等同于<code>document.querySelector()</code>。如果页面脚本中有<code>$</code>的定义,则会覆盖,如 jquery,则会用jqeury实现的;</p><h4 id="selector-1"><a href="#selector-1" class="headerlink" title="$(selector)"></a><code>$(selector)</code></h4><p><code>$$(selector)</code>返回选中的 DOM 对象，等同于<code>document.querySelectorAll</code>。</p><h4 id="x-path"><a href="#x-path" class="headerlink" title="$x(path)"></a><code>$x(path)</code></h4><p><code>$x(path)</code>方法返回一个数组，包含匹配特定 XPath 表达式的所有 DOM 元素</p><h4 id="inspect-object"><a href="#inspect-object" class="headerlink" title="inspect(object)"></a><code>inspect(object)</code></h4><p><code>inspect(object)</code>方法打开相关面板，并选中相应的元素，显示它的细节。如<code>inspect(document)</code>会在Elements面板显示<code>document</code>元素</p><h4 id="keys-object-，values-object"><a href="#keys-object-，values-object" class="headerlink" title="keys(object)，values(object)"></a>keys(object)<code>，</code>values(object)</h4><p><code>keys(object)</code>方法返回一个数组，包含<code>object</code>的所有键名。</p><p><code>values(object)</code>方法返回一个数组，包含<code>object</code>的所有键值。</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法:"></a>其他方法:</h4><p>命令行 API 还提供以下方法。</p><ul><li><code>clear()</code>：清除控制台的历史。</li><li><code>copy(object)</code>：复制特定 DOM 元素到剪贴板。</li><li><code>dir(object)</code>：显示特定对象的所有属性，是<code>console.dir</code>方法的别名。</li><li><code>dirxml(object)</code>：显示特定对象的 XML 形式，是<code>console.dirxml</code>方法的别名。</li></ul><h4 id="debugger-语句"><a href="#debugger-语句" class="headerlink" title="debugger 语句"></a>debugger 语句</h4><p><code>debugger</code>语句主要用于除错，作用是设置断点。如果有正在运行的除错工具，程序运行到<code>debugger</code>语句时会自动停下。如果没有除错工具，<code>debugger</code>语句不会产生任何结果，JavaScript 引擎自动跳过这一句。</p><p>Chrome 浏览器中，当代码运行到<code>debugger</code>语句时，就会暂停运行，自动打开脚本源码界面。</p><h2 id="具体查看-console"><a href="#具体查看-console" class="headerlink" title="具体查看 console"></a>具体查看 <a href="http://wangdoc.com/javascript/features/console.html" target="_blank" rel="noopener">console</a></h2>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习2-运算符</title>
      <link href="/2018/10/29/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
      <url>/2018/10/29/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A02-%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="10种算术运算符"><a href="#10种算术运算符" class="headerlink" title="10种算术运算符"></a>10种算术运算符</h2><ul><li><strong>加法运算符</strong>：<code>x + y</code></li><li><strong>减法运算符</strong>： <code>x - y</code></li><li><strong>乘法运算符</strong>： <code>x * y</code></li><li><strong>除法运算符</strong>：<code>x / y</code></li><li><strong>指数运算符</strong>：<code>x ** y</code></li><li><strong>余数运算符</strong>：<code>x % y</code></li><li><strong>自增运算符</strong>：<code>++x</code> 或者 <code>x++</code></li><li><strong>自减运算符</strong>：<code>--x</code> 或者 <code>x--</code></li><li><strong>数值运算符</strong>： <code>+x</code></li><li><strong>负数值运算符</strong>：<code>-x</code></li></ul><h3 id="加法"><a href="#加法" class="headerlink" title="加法"></a>加法</h3><ul><li><p>JavaScript 允许非数值的相加</p></li><li><p>两个字符串相加，这时加法运算符会变成连接运算符，返回一个新的字符串，将两个原字符串连接在一起。</p></li><li><p>一个运算子是字符串，另一个运算子是非字符串，这时非字符串会转成字符串，再连接在一起。</p></li><li><p>加法运算符是在运行时决定，到底是执行相加，还是执行连接。根据不同的运算子导致不一样的语法行为叫重载</p></li><li><pre class=" language-js"><code class="language-js"><span class="token string">'3'</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">5</span> <span class="token comment" spellcheck="true">// "345"</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token string">'5'</span> <span class="token comment" spellcheck="true">// "75"</span></code></pre></li><li><p>除了加法运算符，其他算术运算符（比如减法、除法和乘法）都不会发生重载。它们的规则是：所有运算子一律转为数值，再进行相应的数学运算。</p></li></ul><h3 id="对象的相加"><a href="#对象的相加" class="headerlink" title="对象的相加"></a>对象的相加</h3><p>如果运算子是对象, 必须先转为原始类型的值,再相加, 对象转原始值规则: </p><ol><li><p>先调用对象的<code>valueOf</code>, 对象的<code>valueOf</code>方法总是返回对象自身</p></li><li><p>这时再自动调用对象的<code>toString</code>方法，将其转为字符串。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> p<span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>obj<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// { p: 1 }</span>obj<span class="token punctuation">.</span><span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "[object Object]"</span></code></pre></li></ol><p>知道了这个规则以后，就可以自己定义<code>valueOf</code>方法或<code>toString</code>方法，得到想要的结果。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>  valueOf<span class="token punctuation">:</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span>obj <span class="token operator">+</span> <span class="token number">2</span> <span class="token comment" spellcheck="true">// 3</span></code></pre><h3 id="余数"><a href="#余数" class="headerlink" title="余数 (%)"></a>余数 (%)</h3><p>运算结果的正负号由第一个运算子的正负号决定。</p><p>所以，为了得到负数的正确余数值，可以先使用绝对值函数。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 错误的写法</span><span class="token keyword">function</span> <span class="token function">isOdd</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span><span class="token comment" spellcheck="true">// 正确的写法</span><span class="token keyword">function</span> <span class="token function">isOdd</span><span class="token punctuation">(</span>n<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">abs</span><span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span><span class="token function">isOdd</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false      </span></code></pre><h3 id="自增自减"><a href="#自增自减" class="headerlink" title="自增自减"></a>自增自减</h3><ul><li><p>自增和自减运算符，是一元运算符，只需要一个运算子。它们的作用是将运算子首先转为数值，然后加上1或者减去1。它们会修改原始变量。</p></li><li><p>运算之后，变量的值发生变化，这种效应叫做运算的副作用（side effect）。自增和自减运算符是仅有的两个具有副作用的运算符，其他运算符都不会改变变量的值。</p></li></ul><p>自增和自减运算符有一个需要注意的地方，就是放在变量之后，会先返回变量操作前的值，再进行自增/自减操作；放在变量之前，会先进行自增/自减操作，再返回变量操作后的值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>x<span class="token operator">++</span> <span class="token comment" spellcheck="true">// 1</span><span class="token operator">++</span>y <span class="token comment" spellcheck="true">// 2</span></code></pre><h3 id="数值运算符-负值运算符"><a href="#数值运算符-负值运算符" class="headerlink" title="数值运算符/负值运算符"></a>数值运算符/负值运算符</h3><blockquote><p>数值运算符号和负数值运算符，都会返回一个新的值，而不会改变原始变量的值。</p></blockquote><p>数值运算符（<code>+</code>）同样使用加号，但它是一元运算符（只需要一个操作数），而加法运算符是二元运算符（需要两个操作数）。</p><p><strong>数值运算符的作用在于可以将任何值转为数值（与<code>Number</code>函数的作用相同）</strong></p><pre class=" language-js"><code class="language-js"><span class="token operator">+</span><span class="token boolean">true</span> <span class="token comment" spellcheck="true">// 1</span><span class="token operator">+</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// 0</span><span class="token operator">+</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// NaN</span></code></pre><p>负数值运算符（<code>-</code>），也同样具有将一个值转为数值的功能，只不过得到的值正负相反。连用两个负数值运算符(需要用括号, 不然是自减运算符)，等同于数值运算符。</p><h3 id="指数运算符"><a href="#指数运算符" class="headerlink" title="指数运算符 (**)"></a>指数运算符 (**)</h3><p>指数运算符（<code>**</code>）完成指数运算，前一个运算子是底数，后一个运算子是指数。</p><p>指数运算符是右结合, 即多个指数运算符连用时,先进行最右边的计算.</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 相当于 2 ** (3 ** 2)</span><span class="token number">2</span> <span class="token operator">**</span> <span class="token number">3</span> <span class="token operator">**</span> <span class="token number">2</span>   <span class="token comment" spellcheck="true">// 512</span></code></pre><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符 (=)"></a>赋值运算符 (=)</h3><p>下面是与算术运算符的结合。</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 等同于 x = x + y</span>x <span class="token operator">+</span><span class="token operator">=</span> y<span class="token comment" spellcheck="true">// 等同于 x = x - y</span>x <span class="token operator">-</span><span class="token operator">=</span> y<span class="token comment" spellcheck="true">// 等同于 x = x * y</span>x <span class="token operator">*</span><span class="token operator">=</span> y<span class="token comment" spellcheck="true">// 等同于 x = x / y</span>x <span class="token operator">/</span><span class="token operator">=</span> y<span class="token comment" spellcheck="true">// 等同于 x = x % y</span>x <span class="token operator">%</span><span class="token operator">=</span> y<span class="token comment" spellcheck="true">// 等同于 x = x ** y</span>x <span class="token operator">**</span><span class="token operator">=</span> y</code></pre><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><p>JavaScript 一共提供了8个比较运算符。</p><ul><li><code>&gt;</code> 大于运算符</li><li><code>&lt;</code> 小于运算符</li><li><code>&lt;=</code> 小于或等于运算符</li><li><code>&gt;=</code> 大于或等于运算符</li><li><code>==</code> 相等运算符</li><li><code>===</code> 严格相等运算符</li><li><code>!=</code> 不相等运算符</li><li><code>!==</code> 严格不相等运算符</li></ul><h3 id="字符串的比较"><a href="#字符串的比较" class="headerlink" title="字符串的比较"></a>字符串的比较</h3><p>按照字典顺序进行比较( 实际上是比较Unicode码点)</p><h3 id="非字符串的比较"><a href="#非字符串的比较" class="headerlink" title="非字符串的比较"></a>非字符串的比较</h3><p><strong>如果运算子都不是字符串</strong></p><ol><li><p>都是原始类型的值, 则先转成数值在比较</p></li><li><pre class=" language-js"><code class="language-js"><span class="token number">5</span> <span class="token operator">></span> <span class="token string">'4'</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 等同于 5 > Number('4')</span><span class="token comment" spellcheck="true">// 即 5 > 4</span><span class="token boolean">true</span> <span class="token operator">></span> <span class="token boolean">false</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 等同于 Number(true) > Number(false)</span><span class="token comment" spellcheck="true">// 即 1 > 0</span><span class="token number">2</span> <span class="token operator">></span> <span class="token boolean">true</span> <span class="token comment" spellcheck="true">// true</span><span class="token comment" spellcheck="true">// 等同于 2 > Number(true)</span><span class="token comment" spellcheck="true">// 即 2 > 1</span></code></pre></li><li><p>NaN 和 任何值比较都 返回 <code>false</code></p></li></ol><p><strong>对象</strong></p><p>如果运算子是对象，会转为原始类型的值，再进行比较。</p><p>对象转换成原始类型的值，算法是先调用<code>valueOf</code>方法；如果返回的还是对象，再接着调用<code>toString</code>方法</p><h3 id="严格相等运算符"><a href="#严格相等运算符" class="headerlink" title="严格相等运算符 (===)"></a>严格相等运算符 (===)</h3><p>JavaScript有提供了两种相等运算符: <code>==</code>和<code>===</code></p><blockquote><p>相等运算符(<code>==</code>)是比较两个值是否相等,严格相等运算符(<code>===</code>)比较的是他们是否为’同一个值’, 不是同一类型, <code>===</code> 返回<code>false</code> ,<code>==</code>会先转为同一类型,在比较</p></blockquote><ul><li><p>NaN和任何值都不相等(包括自身)</p></li><li><p>正<code>0</code>等于负<code>0</code></p></li><li><p>符合类型(对象, 数组, 函数)比较是, 不是比它们值是否相等, 而是比较它们是否是同一个地址</p></li><li><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// false</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  <span class="token comment" spellcheck="true">// false</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token operator">===</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// false</span></code></pre></li><li><p>如果两个变量引用同一个对象，则它们相等。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> v1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> v2 <span class="token operator">=</span> v1<span class="token punctuation">;</span>v1 <span class="token operator">===</span> v2 <span class="token comment" spellcheck="true">// true</span></code></pre></li><li><p><code>undefined</code>和<code>null</code>与自身严格相等</p></li><li><p>由于变量声明后默认值是<code>undefined</code>，因此两个只声明未赋值的变量是相等的。</p></li></ul><h3 id="相等运算符"><a href="#相等运算符" class="headerlink" title="相等运算符 (==)"></a>相等运算符 (==)</h3><blockquote><p> 它遇到相同类型的数据时, 与<code>===</code>完全一样, 比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。</p></blockquote><p><strong>下面分成四种情况，讨论不同类型的值互相比较的规则</strong></p><ol><li><p><strong>原始类型</strong>的值会转换成数值再进行比较</p></li><li><p><strong>对象与原始类型值比较</strong> 对象转换成原始类型的值,再比较</p></li><li><p><strong>undefined 和 null</strong> 与其他类型数值比较返回 <code>false</code>,互与自身则返回<code>true</code></p></li><li><p><strong>相等运算符的缺点</strong></p></li><li><pre class=" language-js"><code class="language-js"><span class="token number">0</span> <span class="token operator">==</span> <span class="token string">''</span>             <span class="token comment" spellcheck="true">// true</span><span class="token number">0</span> <span class="token operator">==</span> <span class="token string">'0'</span>            <span class="token comment" spellcheck="true">// true</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token boolean">true</span>           <span class="token comment" spellcheck="true">// false</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token boolean">false</span>          <span class="token comment" spellcheck="true">// false</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token string">'false'</span>    <span class="token comment" spellcheck="true">// false</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token string">'0'</span>        <span class="token comment" spellcheck="true">// true</span><span class="token boolean">false</span> <span class="token operator">==</span> undefined  <span class="token comment" spellcheck="true">// false</span><span class="token boolean">false</span> <span class="token operator">==</span> <span class="token keyword">null</span>       <span class="token comment" spellcheck="true">// false</span><span class="token keyword">null</span> <span class="token operator">==</span> undefined   <span class="token comment" spellcheck="true">// true</span><span class="token string">' \t\r\n '</span> <span class="token operator">==</span> <span class="token number">0</span>     <span class="token comment" spellcheck="true">// true</span></code></pre><p>因此建议不要使用相等运算符, 最好只使用严格相等运算符</p></li></ol><h2 id="布尔运算符"><a href="#布尔运算符" class="headerlink" title="布尔运算符"></a>布尔运算符</h2><p>布尔运算符用于将表达式转为布尔值，一共包含四个运算符。</p><ul><li>取反运算符：<code>!</code></li><li>且运算符：<code>&amp;&amp;</code></li><li>或运算符：<code>||</code></li><li>三元运算符：<code>?:</code></li></ul><h3 id="取反运算符"><a href="#取反运算符" class="headerlink" title="取反运算符 (!)"></a>取反运算符 (!)</h3><p>对于非布尔值, 取反会将其 转为布尔值, 以下6个值取反后为 <code>true</code>, 其他值都为<code>false</code>:</p><ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>NaN</code></li><li>空字符串（<code>&#39;&#39;</code>）</li></ul><blockquote><p>如果对一个值连续做两次取反运算，等于将其转为对应的布尔值，与<code>Boolean</code>函数的作用相同。这是一种常用的类型转换的写法。</p></blockquote><h3 id="且运算符-amp-amp"><a href="#且运算符-amp-amp" class="headerlink" title="且运算符 (&amp;&amp;)"></a>且运算符 (&amp;&amp;)</h3><p>规则: 如果一个运算子的布尔值为 <code>true</code>, 则返回第二个运算子的值(注意是值, 不是布尔值); 如果第一个运算子的布尔值为<code>false</code>, 则直接返回一第一个子运算符的值, 不再对第二个运算子求值</p><pre class=" language-js"><code class="language-js"><span class="token string">'t'</span> <span class="token operator">&amp;&amp;</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// ""</span><span class="token string">'t'</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'f'</span> <span class="token comment" spellcheck="true">// "f"</span><span class="token string">'t'</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 3</span><span class="token string">''</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'f'</span> <span class="token comment" spellcheck="true">// ""</span><span class="token string">''</span> <span class="token operator">&amp;&amp;</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// ""</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span> x <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 0</span>x <span class="token comment" spellcheck="true">// 1</span></code></pre><p>这种只通过第一个表达式的值，控制是否运行第二个表达式的机制，就称为“短路”（short-cut）。有些程序员喜欢用它取代<code>if</code>结构，比如下面是一段<code>if</code>结构的代码，就可以用且运算符改写。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">if</span> <span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 等价于</span>i <span class="token operator">&amp;&amp;</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>且运算符可以多个连用，这时返回第一个布尔值为<code>false</code>的表达式的值。如果所有表达式的布尔值都为<code>true</code>，则返回最后一个表达式的值。</p><pre class=" language-js"><code class="language-js"><span class="token boolean">true</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'foo'</span> <span class="token operator">&amp;&amp;</span> <span class="token string">''</span> <span class="token operator">&amp;&amp;</span> <span class="token number">4</span> <span class="token operator">&amp;&amp;</span> <span class="token string">'foo'</span> <span class="token operator">&amp;&amp;</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">// ''</span><span class="token number">1</span> <span class="token operator">&amp;&amp;</span> <span class="token number">2</span> <span class="token operator">&amp;&amp;</span> <span class="token number">3</span><span class="token comment" spellcheck="true">// 3</span></code></pre><h3 id="或运算符"><a href="#或运算符" class="headerlink" title="或运算符 (||)"></a>或运算符 (||)</h3><p>规则 : 如果第一个运算子的布尔值为 <code>true</code> , 则返回第一个运算子的值, 且不再对第二个运算子求值; 如果第一个运算子的布尔值为 <code>false</code> , 则返回第二个运算子的值;</p><pre class=" language-js"><code class="language-js"><span class="token string">'t'</span> <span class="token operator">||</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// "t"</span><span class="token string">'t'</span> <span class="token operator">||</span> <span class="token string">'f'</span> <span class="token comment" spellcheck="true">// "t"</span><span class="token string">''</span> <span class="token operator">||</span> <span class="token string">'f'</span> <span class="token comment" spellcheck="true">// "f"</span><span class="token string">''</span> <span class="token operator">||</span> <span class="token string">''</span> <span class="token comment" spellcheck="true">// ""</span></code></pre><p>短路规则也适用: </p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token boolean">true</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// true</span>x <span class="token comment" spellcheck="true">// 1</span></code></pre><p>或运算符可以多个连用，这时返回第一个布尔值为<code>true</code>的表达式的值。如果所有表达式都为<code>false</code>，则返回最后一个表达式的值。</p><pre class=" language-js"><code class="language-js"><span class="token boolean">false</span> <span class="token operator">||</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token string">''</span> <span class="token operator">||</span> <span class="token number">4</span> <span class="token operator">||</span> <span class="token string">'foo'</span> <span class="token operator">||</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true">// 4</span><span class="token boolean">false</span> <span class="token operator">||</span> <span class="token number">0</span> <span class="token operator">||</span> <span class="token string">''</span><span class="token comment" spellcheck="true">// ''</span></code></pre><p>或运算符常用于为一个变量设置默认值。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">saveText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span> <span class="token punctuation">{</span>  text <span class="token operator">=</span> text <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 或者写成</span><span class="token function">saveText</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>text <span class="token operator">||</span> <span class="token string">''</span><span class="token punctuation">)</span></code></pre><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符 (? :)"></a>三元运算符 (? :)</h3><p>三元条件运算符由问号（?）和冒号（:）组成，分隔三个表达式。它是 JavaScript 语言唯一一个需要三个运算子的运算符。</p><ul><li>通常来说，三元条件表达式与<code>if...else</code>语句具有同样表达效果，前者可以表达的，后者也能表达。但是两者具有一个重大差别，<code>if...else</code>是语句，没有返回值；三元条件表达式是表达式，具有返回值。</li></ul><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token boolean">true</span> <span class="token operator">?</span> <span class="token string">'T'</span> <span class="token punctuation">:</span> <span class="token string">'F'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，<code>console.log</code>方法的参数必须是一个表达式，这时就只能使用三元条件表达式。如果要用<code>if...else</code>语句，就必须改变整个代码写法了。</p><h3 id="二进制运算符-没看"><a href="#二进制运算符-没看" class="headerlink" title="二进制运算符 (没看)"></a>二进制运算符 (没看)</h3><h3 id="其他运算符和运算顺序"><a href="#其他运算符和运算顺序" class="headerlink" title="其他运算符和运算顺序"></a>其他运算符和运算顺序</h3><ol><li><p>void运算符: 主要用途是在浏览器的书签工具, 以及在超链接中插入代码防止网页跳转</p></li><li><pre class=" language-js"><code class="language-js"><span class="token operator">&lt;</span>script<span class="token operator">></span><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Hello World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token operator">&lt;</span><span class="token operator">/</span>script<span class="token operator">></span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"http://example.com"</span> onclick<span class="token operator">=</span><span class="token string">"f(); return false;"</span><span class="token operator">></span>点击<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span><span class="token comment" spellcheck="true">// void运算符可以取代上面的写法。</span><span class="token operator">&lt;</span>a href<span class="token operator">=</span><span class="token string">"javascript: void(f())"</span><span class="token operator">></span>文字<span class="token operator">&lt;</span><span class="token operator">/</span>a<span class="token operator">></span></code></pre><p>下面是一个更实际的例子，用户点击链接提交表单，但是不产生页面跳转。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>javascript: void(document.form.submit())<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  提交<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">></span></span></code></pre></li><li><p>逗号运算符: 用于对两个表达式求值, 并返回后一个表达式; </p><ul><li><p>逗号运算符的一个用途是，在返回一个值之前，进行一些辅助操作</p></li><li><pre class=" language-js"><code class="language-js"><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span> <span class="token comment" spellcheck="true">// "b"</span><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token operator">++</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>x <span class="token comment" spellcheck="true">// 1</span>y <span class="token comment" spellcheck="true">// 10</span></code></pre></li></ul></li></ol><h3 id="运算优先级"><a href="#运算优先级" class="headerlink" title="运算优先级"></a>运算优先级</h3><p>这五个运算符的优先级从高到低依次为：小于等于（<code>&lt;=</code>)、严格相等（<code>===</code>）、或（<code>||</code>）、三元（<code>?:</code>）、等号（<code>=</code>）</p><h3 id="圆括号的作用"><a href="#圆括号的作用" class="headerlink" title="圆括号的作用"></a>圆括号的作用</h3><p>圆括号 <code>()</code>用来提高运算的优先级, 它的优先级最高;</p><p><strong>圆括号不是运算符，而是一种语法结构。</strong></p><p>它一共有两种用法：</p><ul><li>一种是把表达式放在圆括号之中，提升运算的优先级；</li><li>另一种是跟在函数的后面，作用是调用函数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript基础复习1-前言+数据类型</title>
      <link href="/2018/10/28/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A01-%E5%89%8D%E8%A8%80+%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2018/10/28/JavaScript%E5%9F%BA%E7%A1%80%E5%A4%8D%E4%B9%A01-%E5%89%8D%E8%A8%80+%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h1><h2 id="前言和基础语法"><a href="#前言和基础语法" class="headerlink" title="前言和基础语法"></a>前言和基础语法</h2><ul><li><p>脚本语言:不具备编写操作系统的能力</p></li><li><p>JavaScript 也是一种嵌入式（embedded）语言。</p></li><li><p>变量就是给值起名</p></li><li><p>JavaScript引擎的工作方式是:先解释代码.在一行行执行.</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> a<span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 结果是显示undefined 表示变量a 已声明但还未赋值</span></code></pre></li><li><p>标识符, JavaScript引擎遇到非法标识符就会报错</p></li><li><p>标识符命名规则如下。</p><ul><li><p>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</p></li><li><p>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</p></li><li><p>中文是合法的标识符,可以作为变量名</p></li><li><blockquote><p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p></blockquote></li></ul></li><li><p>注释: 源码中被 JavaScript 引擎忽略的部分就叫做注释</p><ul><li>单行注释: <code>//</code></li><li>多行注释放到: <code>/*</code>和<code>*/</code>之间</li></ul></li><li><p>由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p></li><li><p>需要注意的是，<code>--&gt;</code>只有在行首，才会被当成单行注释，否则会当作正常的运算。</p><ul><li><pre class=" language-js"><code class="language-js">n <span class="token operator">--</span><span class="token operator">></span> <span class="token number">0</span><span class="token template-string"><span class="token string">`实际上会当作`</span></span>n<span class="token operator">--</span> <span class="token operator">></span> <span class="token number">0</span></code></pre></li></ul></li><li><p>对于<code>var</code>命令来说，JavaScript 的区块<code>{}</code>不构成单独的作用域（scope）。</p><ul><li>区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等。</li></ul></li><li><p>if 结构 是根据一个布尔值执行不同的语句, “布尔值”往往由一个条件表达式产生, 必须放在圆括号中,表示对表达式求值.</p></li><li><p>三元运算符: <code>(条件)? {表达式1}:{表达式2}</code> 条件为true ,执行表达式1 ,否则执行表达式2</p><ul><li><pre class=" language-js"><code class="language-js">  <span class="token keyword">var</span> msg <span class="token operator">=</span> <span class="token string">'数字'</span> <span class="token operator">+</span> n <span class="token operator">+</span> <span class="token string">'是'</span> <span class="token operator">+</span> <span class="token punctuation">(</span>n <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">===</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token string">'偶数'</span> <span class="token punctuation">:</span> <span class="token string">'奇数'</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul></li><li><p>for循环</p><ul><li><code>for</code>语句后面的括号里面，有三个表达式。<ul><li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li><li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li><li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li></ul></li></ul></li><li><p>do…while需要注意</p><ul><li><code>do...while</code>循环至少运行一次，这是这种结构最大的特点</li><li><code>while</code>语句后面的分号注意不要省略</li></ul></li><li><p><code>break</code>语句用于跳出代码块或循环。</p></li><li><p><code>continue</code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p></li><li><p>break和continue注意: 如果存在多重循环，不带参数的<code>break</code>语句和<code>continue</code>语句都只针对最内层循环。</p></li><li><p><strong>标签(label)</strong>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。:</p><pre class=" language-js"><code class="language-js">label<span class="token punctuation">:</span>  语句</code></pre><ul><li>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环</li><li>示例 : <a href="http://wangdoc.com/javascript/basic/grammar.html" target="_blank" rel="noopener">阮一峰JavaScript-基础语法</a></li></ul></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><blockquote><p>JavaScript有7中数据类型: number(数值), string(字符串), boolean(布尔值), null, undefined, object(对象), Symbol</p></blockquote><ul><li><p>数值和字符串和布尔值 合成为 原始类型,他们最基本,无法再细分了.</p></li><li><p>对象称为合成类型的值,因为一个对象往往是多个原始类型的值的合成，可以看作是一个存放各种值的容器。</p></li><li><p><code>undefined</code>和<code>null</code>可以看成是两个特殊值</p></li><li><p>对象分为三个子类:</p><ul><li>狭义的对象(object)</li><li>数组(array)</li><li>函数(function)</li></ul><blockquote><p>函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p></blockquote></li><li><p><code>typeof</code>运算符可以返回一个值的数据类型。</p><ul><li><p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p></li><li><p>函数返回<code>function</code></p></li><li><p><code>undefined</code>返回<code>undefined</code></p></li><li><p><code>NaN</code> 返回 <code>number</code></p></li><li><p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p></li><li><pre class=" language-js"><code class="language-js">v<span class="token comment" spellcheck="true">// ReferenceError: v is not defined</span><span class="token keyword">typeof</span> v<span class="token comment" spellcheck="true">// "undefined"</span><span class="token comment" spellcheck="true">// 错误的写法</span><span class="token keyword">if</span> <span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// ReferenceError: v is not defined</span><span class="token comment" spellcheck="true">// 正确的写法</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> v <span class="token operator">===</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre></li><li><p>对象返回<code>object</code></p></li><li><p><code>null</code>返回 <code>object</code></p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">typeof</span> window <span class="token comment" spellcheck="true">// "object"</span><span class="token keyword">typeof</span> <span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// "object"</span><span class="token keyword">typeof</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token comment" spellcheck="true">// "object"</span></code></pre></li><li><p>数组也是<code>object</code> 是一种特殊的对象. <code>instanceof</code>可以判断是否是数组</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> o <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// false</span>a <span class="token keyword">instanceof</span> <span class="token class-name">Array</span> <span class="token comment" spellcheck="true">// true</span></code></pre></li></ul></li></ul><h3 id="null-undefined-boolean"><a href="#null-undefined-boolean" class="headerlink" title="null-undefined-boolean"></a>null-undefined-boolean</h3><ul><li><code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</li><li>函数无返回值时, 默认返回<code>undefined</code></li><li>下列运算符会返回布尔值：<ul><li>前置逻辑运算符： <code>!</code> (Not)</li><li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li><li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li></ul></li><li>以下6个值会被JavaScript引擎自动转化为布尔值时,转为false,其他的都是true<ul><li><code>undefined</code></li><li><code>null</code></li><li><code>false</code></li><li><code>0</code></li><li><code>&#39; &#39;</code>或<code>&quot; &quot;</code>(空字符串)</li><li><code>NaN</code></li></ul></li><li>空数组<code>[]</code>和空对象<code>{}</code>都是<code>true</code></li></ul><h2 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h2><ul><li><p>JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p><ul><li><p>十进制: 没有前导0的数值</p></li><li><p>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</p></li><li><p>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</p></li><li><p>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</p></li><li><blockquote><p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。</p></blockquote></li></ul></li><li><p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token number">5</span> <span class="token operator">-</span> <span class="token string">'x'</span> <span class="token comment" spellcheck="true">// NaN</span></code></pre></li><li><p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p></li><li><p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p></li></ul><h3 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h3><ul><li><p><code>parseInt</code>方法用于将字符串转为整数</p><ul><li><p>如果字符串头部有空格，空格会被自动去除</p></li><li><p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p></li><li><p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p></li><li><p>如果字符串的第一个字符不能转化为数字（后面跟着数字的正负号除外），返回<code>NaN</code>。</p></li></ul></li><li><p><code>parseInt</code>还接受第二个参数(默认是十进制), 表示被解析的值得进制</p></li><li><p><code>parseFloat</code>方法用于将一个字符串转为浮点数</p><ul><li><code>parseFloat</code>会将空字符串转为<code>NaN</code></li><li>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</li></ul></li><li><p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p><ul><li>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</li></ul></li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><blockquote><p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号.当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p></blockquote><ul><li><p>字符串如果想要输入多行, 可以在每一行尾部使用 反斜杠 <code>\</code>,但是输出还是单行的</p></li><li><p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p></li><li><pre class=" language-js"><code class="language-js"><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*line 1line 2line 3*/</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">'\n'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// "line 1</span><span class="token comment" spellcheck="true">// line 2</span><span class="token comment" spellcheck="true">// line 3"</span></code></pre></li><li><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p></li><li><p>需要用反斜杠转义的特殊字符，主要有下面这些。</p><ul><li><code>\0</code> ：null（<code>\u0000</code>）</li><li><code>\b</code> ：后退键（<code>\u0008</code>）</li><li><code>\f</code> ：换页符（<code>\u000C</code>）</li><li><code>\n</code> ：换行符（<code>\u000A</code>）</li><li><code>\r</code> ：回车键（<code>\u000D</code>）</li><li><code>\t</code> ：制表符（<code>\u0009</code>）</li><li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li><li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li><li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li><li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li></ul></li><li><p>反斜杠还有三种特殊用法。</p><p>（1）<code>\HHH</code></p><p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p><p>（2）<code>\xHH</code></p><p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p><p>（3）<code>\uXXXX</code></p><p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p></li><li><p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略</p></li><li><p>转义符转义自身<code>\\</code> 输出<code>\</code></p></li><li><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。超出返回<code>undefined</code></p></li></ul><h3 id="base64-转码"><a href="#base64-转码" class="headerlink" title="base64 转码"></a>base64 转码</h3><blockquote><p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p></blockquote><p>JavaScript 原生提供两个 Base64 相关的方法。</p><ul><li><code>btoa()</code>：任意值转为 Base64 编码</li><li><code>atob()</code>：Base64 编码转为原来的值</li></ul><blockquote><p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p></blockquote><pre class=" language-js"><code class="language-js"><span class="token function">btoa</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 报错</span></code></pre><p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">b64Encode</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">btoa</span><span class="token punctuation">(</span><span class="token function">encodeURIComponent</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">b64Decode</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> <span class="token function">decodeURIComponent</span><span class="token punctuation">(</span><span class="token function">atob</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">b64Encode</span><span class="token punctuation">(</span><span class="token string">'你好'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "JUU0JUJEJUEwJUU1JUE1JUJE"</span><span class="token function">b64Decode</span><span class="token punctuation">(</span><span class="token string">'JUU0JUJEJUEwJUU1JUE1JUJE'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// "你好"</span></code></pre><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><blockquote><p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p></blockquote><ul><li><p>对象的属性之间用逗号分隔, 最后一个属性后面可加可不加.</p></li><li><p>对象的属性值如果引用的是对象,则是不同对象的属性引用同一个对象,是同一块内存地址,改一个,影响另一个,</p></li><li><p>如果引用是原始类型的值, 则是值的拷贝, 互不影响</p></li><li><p>行首是大括号开头的 是表达式还是语句?</p><pre class=" language-js"><code class="language-js"><span class="token punctuation">{</span> foo<span class="token punctuation">:</span> <span class="token number">123</span> <span class="token punctuation">}</span></code></pre><ul><li><p>为了避免歧义, V8引擎规定, 如果行首是大括号, 一律解释为对象. 为了避免歧义, 最好在大括号前加上圆括号.</p></li><li><p>这种差异在<code>eval</code>语句(作用是对字符串求值) 中体现明显: </p><pre class=" language-js"><code class="language-js"><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'{foo: 123}'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 123</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">'({foo: 123})'</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// {foo: 123}</span></code></pre><p>上面代码中, 如果没有圆括号, <code>eval</code>将其理解为代码块, 加上括号后理解成一个对象.</p></li></ul></li><li><p><strong>属性的读取</strong></p><ul><li><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p></li><li><p>使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p><ul><li>方括号例外: 数字键可以不加引号, 因为会自动转化为字符串</li><li>数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</li></ul></li><li><p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p></li><li><p>查看一个对象的所有属性, 用 <code>Object.keys</code></p></li><li><p>属性的删除用 <code>delete</code>, 成功删除返回 <code>true</code> 在没有被删除属性时也会返回 <code>true</code>   </p></li><li><pre class=" language-js"><code class="language-js"><span class="token template-string"><span class="token string">`delete object.name  // true`</span></span>        </code></pre></li><li><p><code>delete</code>只有一种情况会返回 <code>false</code> : 属性存在, 但不得删除</p></li><li><p><code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性</p></li></ul></li><li><p>用 <code>in</code>查看属性是否从存在 (键名)  <code>&#39;name&#39; in object</code></p><ul><li>继承的也会返回 <code>true</code></li><li>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</li></ul></li><li><p>属性的遍历 <code>for in</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'键名：'</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'键值：'</span><span class="token punctuation">,</span> obj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><ul><li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li><li>它不仅遍历对象自身的属性，还遍历继承的属性(必须是可遍历的)。</li></ul></li></ul><ul><li><strong>with</strong>操作同一个对象的多个属性时，提供一些书写的方便。</li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><blockquote><p>函数是一段可以反复调用的代码块</p></blockquote><h3 id="函数声明"><a href="#函数声明" class="headerlink" title="函数声明"></a>函数声明</h3><p>有三种</p><ul><li>function命令</li><li>函数表达式</li><li>Function构造函数</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mvc思想</title>
      <link href="/2018/10/26/mvc%E6%80%9D%E6%83%B3/"/>
      <url>/2018/10/26/mvc%E6%80%9D%E6%83%B3/</url>
      
        <content type="html"><![CDATA[<h2 id="起源"><a href="#起源" class="headerlink" title="起源"></a>起源</h2><p>2010年, Backbone.js出现.</p><h2 id="单词"><a href="#单词" class="headerlink" title="单词"></a>单词</h2><ul><li>increase 加</li><li>decrease 减</li><li>square 平方</li><li>cube 立方</li></ul><h2 id="意大利面条"><a href="#意大利面条" class="headerlink" title="意大利面条"></a>意大利面条</h2><blockquote><p>思想是: 用动态页面,: 获取数据 &gt; 更新数据 &gt; 更改数据 &gt; 更新数据.</p></blockquote><h2 id="一些程序员想出了解决办法"><a href="#一些程序员想出了解决办法" class="headerlink" title="一些程序员想出了解决办法"></a>一些程序员想出了解决办法</h2><p><strong>一些程序员通过自己的总结，发现这些代码总是可以分成三类：</strong></p><ol><li>专门操作远程数据的代码（fetchDb 和 saveDb 等等）</li><li>专门呈现页面元素的代码（innerHTML 等等）</li><li>其他控制逻辑的代码（点击某按钮之后做啥的代码）</li></ol><p><strong>为什么分成这三类呢？因为我们前端抄袭了后端的分类思想，后端代码也经常分为三类：</strong></p><ol><li>专门操作 MySQL 数据库的代码</li><li>专门渲染 HTML 的代码</li><li>其他控制逻辑的代码（用户请求首页之后去读数据库，然后渲染 HTML 作为响应等等）</li></ol><p><strong>这些思路经过慢慢的演化，最终被广大程序员完善为 MVC 思想。</strong></p><ol><li>M 专门负责数据</li><li>V 专门负责表现</li><li>C 负责其他逻辑</li></ol><p><strong>如果我们来反思一下，会发现这个分类是无懈可击的：</strong></p><ol><li>每个网页都有数据</li><li>每个网页都有表现（具体为 HTML）</li><li>每个网页都有其他逻辑</li></ol><h2 id="未改造前例子1"><a href="#未改造前例子1" class="headerlink" title="未改造前例子1"></a>未改造前<a href="https://jsbin.com/noraye/8/edit?html,js,output" target="_blank" rel="noopener">例子1</a></h2><h2 id="第一次MVC改造-例子2"><a href="#第一次MVC改造-例子2" class="headerlink" title="第一次MVC改造 例子2"></a>第一次MVC改造 <a href="https://jsbin.com/yuwopuf/3/edit?js,output" target="_blank" rel="noopener">例子2</a></h2><p>就分为三部分</p><ol><li><p>控制数据库数据的获取和更新,需要一个data对象来本地存储</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> model <span class="token operator">=</span> <span class="token punctuation">{</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> <span class="token keyword">null</span><span class="token punctuation">,</span>    name<span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">,</span>    number<span class="token punctuation">:</span> <span class="token number">0</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">fetch</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`/books/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">update</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> id <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">.</span>id    <span class="token keyword">return</span> axios<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token template-string"><span class="token string">`/books/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>id<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">`</span></span><span class="token punctuation">,</span>newData<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token operator">=</span> response<span class="token punctuation">.</span>data<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>把操作页面显示的分离出来</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> view <span class="token operator">=</span> <span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>  template<span class="token punctuation">:</span> <span class="token template-string"><span class="token string">`  &lt;div>    书名：《__name__》，    数量：&lt;span id="number">__number__&lt;/span>  &lt;/div>  &lt;div class="actions">    &lt;button id="increaseByOne">加1&lt;/button>    &lt;button id="decreaseByOne">减1&lt;/button>    &lt;button id="square">平方&lt;/button>    &lt;button id="cube">立方&lt;/button>    &lt;button id="reset">归零&lt;/button>  &lt;/div>  `</span></span><span class="token punctuation">,</span>  <span class="token function">render</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">html</span><span class="token punctuation">(</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>template<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'__number__'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>number<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token string">'__name__'</span><span class="token punctuation">,</span> data<span class="token punctuation">.</span>name<span class="token punctuation">)</span>    <span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre></li><li><p>控制器 主要 运用 把事件用数据化的思维进行绑定, 把更新数据分离成一个<code>updateModel</code> 方法, 绑定事件用到了bind绑定当前的conteroller作用域,而不是window</p></li><li><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> controller <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">{</span>view<span class="token punctuation">,</span> model<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>view <span class="token operator">=</span> view<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>model <span class="token operator">=</span> model<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>view<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">bindEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">fetchModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  events<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span> selector<span class="token punctuation">:</span> <span class="token string">'#increaseByOne'</span><span class="token punctuation">,</span> fnName<span class="token punctuation">:</span> <span class="token string">'add'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span> selector<span class="token punctuation">:</span> <span class="token string">'#decreaseByOne'</span><span class="token punctuation">,</span> fnName<span class="token punctuation">:</span> <span class="token string">'minus'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span> selector<span class="token punctuation">:</span> <span class="token string">'#square'</span><span class="token punctuation">,</span> fnName<span class="token punctuation">:</span> <span class="token string">'square'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span> selector<span class="token punctuation">:</span> <span class="token string">'#cube'</span><span class="token punctuation">,</span> fnName<span class="token punctuation">:</span> <span class="token string">'cube'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token punctuation">{</span> type<span class="token punctuation">:</span> <span class="token string">'click'</span><span class="token punctuation">,</span> selector<span class="token punctuation">:</span> <span class="token string">'#reset'</span><span class="token punctuation">,</span> fnName<span class="token punctuation">:</span> <span class="token string">'reset'</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token function">bindEvents</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>events<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>view<span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span>event<span class="token punctuation">.</span>type<span class="token punctuation">,</span> event<span class="token punctuation">.</span>selector<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">[</span>event<span class="token punctuation">.</span>fnName<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">add</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token punctuation">{</span>number<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">.</span>number <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">minus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token punctuation">{</span>number<span class="token punctuation">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">.</span>number <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">square</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token punctuation">{</span>number<span class="token punctuation">:</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">cube</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token punctuation">{</span>number<span class="token punctuation">:</span> Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">.</span>number<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">reset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">let</span> newData <span class="token operator">=</span> <span class="token punctuation">{</span>number<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">updateModel</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span>newData<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>          console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">)</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>view<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token function">fetchModel</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span><span class="token function">fetch</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>view<span class="token punctuation">.</span><span class="token function">render</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>model<span class="token punctuation">.</span>data<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>controller<span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">{</span>view<span class="token punctuation">,</span> model<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>最后 把mvc 调用一下</p></li><li><pre><code>controller.init({view, model})</code></pre></li><li><p>前置代码(后台)</p></li><li><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 用到axios ajax库, 和 jquery来操作dom</span>axios<span class="token punctuation">.</span>interceptors<span class="token punctuation">.</span>response<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>response<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> <span class="token punctuation">{</span>config<span class="token punctuation">:</span> <span class="token punctuation">{</span>url<span class="token punctuation">,</span> method<span class="token punctuation">,</span> data<span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> response  data <span class="token operator">=</span> JSON<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>data<span class="token operator">||</span><span class="token string">'{}'</span><span class="token punctuation">)</span>  <span class="token keyword">let</span> row <span class="token operator">=</span> <span class="token punctuation">{</span>    id<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> name<span class="token punctuation">:</span> <span class="token string">'JavaScript高级程序设计'</span><span class="token punctuation">,</span> number<span class="token punctuation">:</span> <span class="token number">2</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span><span class="token punctuation">(</span>url <span class="token operator">===</span> <span class="token string">'/books/1'</span> <span class="token operator">&amp;&amp;</span> method <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    response<span class="token punctuation">.</span>data <span class="token operator">=</span> row  <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>url <span class="token operator">===</span> <span class="token string">'/books/1'</span> <span class="token operator">&amp;&amp;</span> method <span class="token operator">===</span> <span class="token string">'put'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    response<span class="token punctuation">.</span>data <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>row<span class="token punctuation">,</span> data<span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> response<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ol><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>一个页面或模块只需要 model view controller 三个对象<br>第二个页面就需要再来 model2 view2 controller2 三个对象<br>第三个页面就需要再来 model3 view3 controller3 三个对象<br>……<br>第N个页面就需要再来 modelN viewN controllerN 三个对象</p><p>你每次写一个 model 都要写很类似的代码<br>你每次写一个 view 都要写很类似的代码<br>你每次写一个 controller 都要写很类似的代码</p><p>为什么不利用模板代码（俗称面向对象）把重复的代码写到一个类呢（JS里面就是把「共有属性」放到原型里）</p><p><a href="https://jsbin.com/sodojac/5/edit?js,output" target="_blank" rel="noopener">代码</a></p><p><strong>理解</strong></p><ul><li>Model中的data参数有时不需要{},有时需要</li><li>View 中 <code>for in</code>的用法</li><li>array的map方法是有返回值的forEach.</li><li>vue这个框架 data中的数据提升可. 例如: vue.name === vue.data.name;</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> mvc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack中babel-loader的配置过程</title>
      <link href="/2018/10/25/webpack%E4%B8%ADbabel-loader%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/"/>
      <url>/2018/10/25/webpack%E4%B8%ADbabel-loader%E7%9A%84%E9%85%8D%E7%BD%AE%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="真理-官网才是王道"><a href="#真理-官网才是王道" class="headerlink" title="真理: 官网才是王道"></a>真理: 官网才是王道</h2><h3 id="回合1"><a href="#回合1" class="headerlink" title="回合1"></a>回合1</h3><blockquote><p>此次的是在网上看的blog做的 <a href="https://segmentfault.com/a/1190000006178770#articleHeader4" target="_blank" rel="noopener">地址</a> 其实博客写的很好,只是 webpack更新了.所以还是要向官网看齐.</p></blockquote><pre class=" language-shell"><code class="language-shell">npm i -D webpack webpack-clinpm i -D babel-loader babel-corenpm i -D babel-preset-env </code></pre><p>此时编辑我的js文件(用es6的语法). 然后 用webpack编译</p><pre class=" language-shell"><code class="language-shell">npx webpack   //报错</code></pre><p>错误如下: </p><pre><code>Module build failed (from ./node_modules/babel-loader/lib/index.js):Error: Cannot find module &#39;@babel/core&#39; babel-loader@8 requires Babel 7.x (the package &#39;@babel/core&#39;). If you&#39;d like to use Babel 6.x (&#39;babel-core&#39;), you should install &#39;babel-loader@7&#39;.</code></pre><p>好像是让我安装babel-loader@7, 那就安装吧:</p><pre class=" language-shell"><code class="language-shell">npm i -D babel-loader@7</code></pre><p>此时在编译 没问题了</p><p>主要代码:</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// .babelrc</span><span class="token punctuation">{</span>  <span class="token string">"presets"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">"env"</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// package.json 中的 部分</span> <span class="token string">"devDependencies"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"babel-core"</span><span class="token punctuation">:</span> <span class="token string">"^6.26.3"</span><span class="token punctuation">,</span>    <span class="token string">"babel-loader"</span><span class="token punctuation">:</span> <span class="token string">"^7.1.5"</span><span class="token punctuation">,</span>    <span class="token string">"babel-preset-env"</span><span class="token punctuation">:</span> <span class="token string">"^1.7.0"</span><span class="token punctuation">,</span>    <span class="token string">"webpack"</span><span class="token punctuation">:</span> <span class="token string">"^4.23.0"</span><span class="token punctuation">,</span>    <span class="token string">"webpack-cli"</span><span class="token punctuation">:</span> <span class="token string">"^3.1.2"</span>  <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// webpack.config.js中的部分</span>mode<span class="token punctuation">:</span> <span class="token string">'development'</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">//此行不加 webpack会提示你要添加mode</span>module<span class="token punctuation">:</span> <span class="token punctuation">{</span>    rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>      <span class="token punctuation">{</span>        test<span class="token punctuation">:</span> <span class="token regex">/\.js$/</span><span class="token punctuation">,</span>        exclude<span class="token punctuation">:</span> <span class="token regex">/node_modules/</span><span class="token punctuation">,</span>        loader<span class="token punctuation">:</span> <span class="token string">"babel-loader"</span>      <span class="token punctuation">}</span>    <span class="token punctuation">]</span>  <span class="token punctuation">}</span></code></pre><h3 id="回合2"><a href="#回合2" class="headerlink" title="回合2"></a>回合2</h3><blockquote><p>跟着官网来呗 <a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a></p></blockquote><h4 id="安装有两个版本-都可用"><a href="#安装有两个版本-都可用" class="headerlink" title="安装有两个版本 都可用"></a>安装有两个版本 都可用</h4><ul><li><p>one</p><pre><code>// webpack 4.x | babel-loader 8.x | babel 7.xnpm install -D babel-loader @babel/core @babel/preset-env webpack</code></pre><ul><li><p>two</p><pre><code>// webpack 4.x | babel-loader 7.x | babel 6.xnpm install -D babel-loader@7 babel-core babel-preset-env webpack</code></pre></li></ul></li></ul><p><strong>webpack.config.js配置</strong></p><pre class=" language-js"><code class="language-js">module<span class="token punctuation">:</span> <span class="token punctuation">{</span>  rules<span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span>      test<span class="token punctuation">:</span> <span class="token regex">/\.m?js$/</span><span class="token punctuation">,</span>      exclude<span class="token punctuation">:</span> <span class="token regex">/(node_modules|bower_components)/</span><span class="token punctuation">,</span>      use<span class="token punctuation">:</span> <span class="token punctuation">{</span>        loader<span class="token punctuation">:</span> <span class="token string">'babel-loader'</span><span class="token punctuation">,</span>        options<span class="token punctuation">:</span> <span class="token punctuation">{</span>          presets<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token string">'@babel/preset-env'</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><p>一次成功. yes!~~  更多用法详见官网 <a href="https://github.com/babel/babel-loader" target="_blank" rel="noopener">babel-loader</a></p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>node.js简单练习-阮一峰</title>
      <link href="/2018/10/23/node-js%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0-%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
      <url>/2018/10/23/node-js%E7%AE%80%E5%8D%95%E7%BB%83%E4%B9%A0-%E9%98%AE%E4%B8%80%E5%B3%B0/</url>
      
        <content type="html"><![CDATA[<p>一直想自己写接口玩玩,今天公司不忙就在网上找找有没有合适的练手的demo,发现阮一峰老师有写过此类教程.<br>github地址: <a href="https://github.com/ruanyf/jstraining/tree/master/demos#simple-app" target="_blank" rel="noopener">ruanyf/jstrining</a><br>这个项目是一个很全面的教程,我此次只练习的一部分,大家喜欢可以都试试.</p><h1 id="阮一峰的笔记内容"><a href="#阮一峰的笔记内容" class="headerlink" title="阮一峰的笔记内容"></a>阮一峰的笔记内容</h1><h2 id="Simple-App"><a href="#Simple-App" class="headerlink" title="Simple App"></a>Simple App</h2><h3 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h3><ol><li>学会使用 Node 编写简单的前端应用。</li></ol><h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>（1）新建一个目录</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> simple-app-demo$ <span class="token function">cd</span> simple-app-demo</code></pre><p>（2）在该目录下，新建一个<code>package.json</code>文件。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> init -y</code></pre><p><code>package.json</code>是项目的配置文件。</p><p>（3）安装<code>jquery</code>、<code>webpack</code>、<code>webpack-cli</code>这三个模块。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -S jquery$ <span class="token function">npm</span> <span class="token function">install</span> -S webpack webpack-cli</code></pre><p>打开<code>package.json</code>文件，会发现<code>jquery</code>、<code>webpack</code>和<code>webpack-cli</code>都加入了<code>dependencies</code>字段，并且带有版本号。</p><p>（4）在项目根目录下，新建一个网页文件<code>index.html</code>。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h1</span><span class="token punctuation">></span></span>Hello World<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h1</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bundle.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">></span></span></code></pre><p>（5）在项目根目录下，新建一个脚本文件<code>app.js</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> $ <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'jquery'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">$</span><span class="token punctuation">(</span><span class="token string">'h1'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">css</span><span class="token punctuation">(</span><span class="token punctuation">{</span> color<span class="token punctuation">:</span> <span class="token string">'red'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码中，<code>require</code>方法是 Node 特有的模块加载命令。</p><p>（6）打开<code>package.json</code>，在<code>scripts</code>字段里面，添加一行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"build"</span><span class="token punctuation">:</span> <span class="token string">"webpack --mode production ./app.js -o ./bundle.js"</span><span class="token punctuation">,</span>  <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"...."</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>（7） 在项目根目录下，执行下面的命令，将脚本打包。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> run build</code></pre><p>执行完成，可以发现项目根目录下，新生成了一个文件<code>bundle.js</code>。</p><p>（8）浏览器打开<code>index.html</code>，可以发现<code>Hello World</code>变成了红色。</p><h3 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h3><ol><li>修改样式，将标题变为蓝色，然后重新编译生成打包文件。</li></ol><h2 id="REST-API"><a href="#REST-API" class="headerlink" title="REST API"></a>REST API</h2><h3 id="实验目的-1"><a href="#实验目的-1" class="headerlink" title="实验目的"></a>实验目的</h3><ol><li>熟悉 REST API 的基本用法</li></ol><h3 id="操作步骤-1"><a href="#操作步骤-1" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>（1） 命令行进入<code>demos/rest-api-demo</code>目录，执行下面的命令。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -S json-server</code></pre><p>（2） 在项目根目录下，新建一个 JSON 文件<code>db.json</code>。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"posts"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"title"</span><span class="token punctuation">:</span> <span class="token string">"json-server"</span><span class="token punctuation">,</span> <span class="token string">"author"</span><span class="token punctuation">:</span> <span class="token string">"typicode"</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"comments"</span><span class="token punctuation">:</span> <span class="token punctuation">[</span>    <span class="token punctuation">{</span> <span class="token string">"id"</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"body"</span><span class="token punctuation">:</span> <span class="token string">"some comment"</span><span class="token punctuation">,</span> <span class="token string">"postId"</span><span class="token punctuation">:</span> <span class="token number">1</span> <span class="token punctuation">}</span>  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token string">"profile"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token string">"name"</span><span class="token punctuation">:</span> <span class="token string">"typicode"</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>（3） 打开<code>package.json</code>，在<code>scripts</code>字段添加一行。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token string">"scripts"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>  <span class="token string">"server"</span><span class="token punctuation">:</span> <span class="token string">"json-server db.json"</span><span class="token punctuation">,</span>  <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"..."</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre><p>（4） 命令行下执行下面的命令，启动服务。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> run server</code></pre><p>（5）打开 Chrome 浏览器的 Postman 应用。依次向<code>http://127.0.0.1:3000/posts</code>、<code>http://127.0.0.1:3000/posts/1</code>发出<code>GET</code>请求，查看结果。</p><p>（6）向<code>http://127.0.0.1:3000/comments</code>发出<code>POST</code>请求。注意，数据体<code>Body</code>要选择<code>x-www-form-urlencoded</code>编码，然后依次添加下面两个字段。</p><pre class=" language-javascript"><code class="language-javascript">body<span class="token punctuation">:</span> <span class="token string">"hello world"</span>postId<span class="token punctuation">:</span> <span class="token number">1</span></code></pre><p>发出该请求后，再向<code>http://127.0.0.1:3000/comments</code>发出<code>GET</code>请求，查看结果。</p><p>（7） 向<code>http://127.0.0.1:3000/comments/2</code>发出<code>PUT</code>请求，数据体<code>Body</code>要选择<code>x-www-form-urlencoded</code>编码，然后添加下面的字段。</p><pre class=" language-javascript"><code class="language-javascript">body<span class="token punctuation">:</span> <span class="token string">"hello react"</span></code></pre><p>发出该请求后，再向<code>http://127.0.0.1:3000/comments</code>发出<code>GET</code>请求，查看结果。</p><p>（8）向<code>http://127.0.0.1:3000/comments/2</code>发出<code>delete</code>请求。</p><p>发出该请求后，再向<code>http://127.0.0.1:3000/comments</code>发出<code>GET</code>请求，查看结果。</p><h2 id="Express"><a href="#Express" class="headerlink" title="Express"></a>Express</h2><h3 id="实验目的-2"><a href="#实验目的-2" class="headerlink" title="实验目的"></a>实验目的</h3><ol><li>学会 Express 搭建 Web 应用的基本用法。</li></ol><h3 id="操作步骤-2"><a href="#操作步骤-2" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>（1）进入<code>demos/express-demo</code>目录，命令行执行下面的命令，安装依赖。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> demos/express-demo$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>（2）打开<code>app1.js</code>，尝试看懂这个脚本。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> express    <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> app        <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码调用<code>express</code>，生成一个 Web 应用的实例。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'&lt;h1>Hello World&lt;/h1>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token string">'/home'</span><span class="token punctuation">,</span> router<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码新建了一个路由对象，该对象指定访问根路由（<code>/</code>）时，返回<code>Hello World</code>。然后，将该路由加载在<code>/home</code>路径，也就是说，访问<code>/home</code>会返回<code>Hello World</code>。</p><p><code>router.get</code>方法的第二个参数是一个回调函数，当符合指定路由的请求进来，会被这个函数处理。该函数的两个参数，<code>req</code>和<code>res</code>都是Express 内置的对象，分别表示用户的请求和 Web 服务器的回应。<code>res.send</code>方法就表示服务器回应所送出的内容。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> port <span class="token operator">=</span> process<span class="token punctuation">.</span>env<span class="token punctuation">.</span>PORT <span class="token operator">||</span> <span class="token number">8080</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Magic happens on port '</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码指定了外部访问的端口，如果环境变量没有指定，则端口默认为<code>8080</code>。最后两行是启动应用，并输出一行提示文字。</p><p>（3）在命令行下，启动这个应用。</p><pre class=" language-bash"><code class="language-bash">$ node app1.js</code></pre><p>浏览器访问<code>localhost:8080/home</code>，看看是否输出<code>Hello World</code>。</p><p>然后，命令行下按 Ctrl + C，退出这个进程。</p><p>（4）通过环境变量，自定义启动端口。</p><p>假定我们指定必须启动在<code>7070</code>端口，命令行可以这样操作。</p><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># Linux &amp; Mac</span>$ PORT<span class="token operator">=</span>7070 node app1.js<span class="token comment" spellcheck="true"># windows cmd / (git cmd)</span>$ <span class="token keyword">set</span> PORT<span class="token operator">=</span>7070$ node app1.js<span class="token comment" spellcheck="true"># windows powershell</span>$ <span class="token variable">$env</span>:PORT<span class="token operator">=</span>7070$ node app1.js</code></pre><p>浏览器就可以访问<code>localhost:7070/home</code>了。</p><p>然后，命令行下按 Ctrl + C，退出这个进程。</p><p>思考题：Node 应用能否直接在<code>80</code>端口启动？</p><p>（5）打开<code>app2.js</code>，查看新增的那个路由。</p><pre class=" language-javascript"><code class="language-javascript">router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/:name'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'&lt;h1>Hello '</span> <span class="token operator">+</span> req<span class="token punctuation">.</span>params<span class="token punctuation">.</span>name <span class="token operator">+</span> <span class="token string">'&lt;/h1>'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码新增了一个路由，这个路由的路径是一个命名参数<code>:name</code>，可以从<code>req.params.name</code>拿到这个传入的参数。</p><p>在命令行下，启动这个应用。</p><pre class=" language-bash"><code class="language-bash">$ node app2.js</code></pre><p>浏览器访问<code>localhost:8080/home/张三</code>，看看是否输出<code>Hello 张三</code>。</p><p>然后，命令行下按 Ctrl + C，退出这个进程。</p><p>（6）打开<code>app3.js</code>，先查看页面头部新增的两行代码。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> express    <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> app        <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 新增代码...</span><span class="token keyword">var</span> bodyParser <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'body-parser'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>bodyParser<span class="token punctuation">.</span><span class="token function">urlencoded</span><span class="token punctuation">(</span><span class="token punctuation">{</span> extended<span class="token punctuation">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// ...</span></code></pre><p>上面代码中，<code>body-parser</code>模块的作用，是对<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等 HTTP 方法的数据体进行解析。<code>app.use</code>用来将这个模块加载到当前应用。有了这两句，就可以处理<code>POST</code>、<code>PUT</code>、<code>DELETE</code>等请求了。</p><p>下面查看新增的那个路由。</p><pre class=" language-javascript"><code class="language-javascript">router<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> name <span class="token operator">=</span> req<span class="token punctuation">.</span>body<span class="token punctuation">.</span>name<span class="token punctuation">;</span>  res<span class="token punctuation">.</span><span class="token function">json</span><span class="token punctuation">(</span><span class="token punctuation">{</span>message<span class="token punctuation">:</span> <span class="token string">'Hello '</span> <span class="token operator">+</span> name<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上面代码表示，如果收到了<code>/</code>路径（实际上是<code>/home</code>路径）的<code>POST</code>请求，先从数据体拿到<code>name</code>字段，然后返回一段 JSON 信息。</p><p>在命令行下，启动这个应用。</p><pre class=" language-bash"><code class="language-bash">$ node app3.js</code></pre><p>然后，在 Chrome 浏览器的 Postman 插件里面，向<code>http://127.0.0.1:8080/home</code>发出一个<code>POST</code>请求。数据体的编码方法设为<code>x-www-form-urlencoded</code>，里面设置一个<code>name</code>字段，值可以随便取，假定设为<code>Alice</code>。也就是说，发出这样一个请求。</p><pre><code>POST /home HTTP/1.1Host: 127.0.0.1:8080Content-Type: application/x-www-form-urlencodedname=Alice</code></pre><p>如果一切正常，服务器会返回一段 JSON 信息。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"message"</span><span class="token punctuation">:</span> <span class="token string">"Hello Alice"</span><span class="token punctuation">}</span></code></pre><p>（7）打开<code>app4.js</code>，查看在所有路由之前新增的那个函数。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">var</span> router <span class="token operator">=</span> express<span class="token punctuation">.</span><span class="token function">Router</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 新增的代码</span>router<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">,</span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'There is a requesting.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>router<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span></code></pre><p><code>router.use</code>的作用是加载一个函数。这个函数被称为中间件，作用是在请求被路由匹配之前，先进行一些处理。上面这个中间件起到 logging 的作用，每收到一个请求，就在命令行输出一条记录。请特别注意，这个函数内部的<code>next()</code>，它代表下一个中间件，表示将处理过的请求传递给下一个中间件。这个例子只有一个中间件，就进入路由匹配处理（实际上，<code>bodyparser</code>、<code>router</code>本质都是中间件，整个 Express 的设计哲学就是不断对 HTTP 请求加工，然后返回一个 HTTP 回应）。</p><h3 id="练习-1"><a href="#练习-1" class="headerlink" title="练习"></a>练习</h3><ol><li><p>请增加一个中间件，服务器每次收到用户请求，会在服务器的控制台打印出收到请求的时间。</p></li><li><p>URL 的查询字符串，比如<code>localhost:8080?name=Alice</code>里面的<code>name</code>，可以用<code>req.query.name</code>拿到。请修改一个路由，使之可以收到查询字符串，然后输出<code>&#39;Hello &#39; + req.query.name</code>。</p></li></ol><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><h3 id="实验目的-3"><a href="#实验目的-3" class="headerlink" title="实验目的"></a>实验目的</h3><ol><li>学会使用 ESLint 进行代码检查。</li></ol><h3 id="操作步骤-3"><a href="#操作步骤-3" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>（1）进入<code>demos/eslint-demo</code>目录，安装 ESLint。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> demos/eslint-demo$ <span class="token function">npm</span> <span class="token function">install</span> eslint --save-dev</code></pre><p>（2）通常，我们会使用别人已经写好的代码检查规则，这里使用的是 Airbnb 公司的规则。所以，还要安装 ESLint 这个规则模块。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> eslint-plugin-import eslint-config-airbnb-base --save-dev</code></pre><p>上面代码中，<code>eslint-plugin-import</code>是运行这个规则集必须的，所以也要一起安装。</p><p>（3）ESLint 的配置文件是<code>.eslintrc.json</code>，放置在项目的根目录下面。新建这个文件，在里面指定使用 Airbnb 的规则。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"extends"</span><span class="token punctuation">:</span> <span class="token string">"airbnb-base"</span><span class="token punctuation">}</span></code></pre><p>（4）打开项目的<code>package.json</code>，在<code>scripts</code>字段里面添加三个脚本。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// ...</span>  <span class="token string">"scripts"</span> <span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"test"</span><span class="token punctuation">:</span> <span class="token string">"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span class="token punctuation">,</span>    <span class="token string">"lint"</span><span class="token punctuation">:</span> <span class="token string">"eslint **/*.js"</span><span class="token punctuation">,</span>    <span class="token string">"lint-html"</span><span class="token punctuation">:</span> <span class="token string">"eslint **/*.js -f html -o ./reports/lint-results.html"</span><span class="token punctuation">,</span>    <span class="token string">"lint-fix"</span><span class="token punctuation">:</span> <span class="token string">"eslint --fix **/*.js"</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token comment" spellcheck="true">// ...</span><span class="token punctuation">}</span></code></pre><p>除了原有的<code>test</code>脚本，上面代码新定义了三个脚本，它们的作用如下。</p><ul><li><code>lint</code>：检查所有<code>js</code>文件的代码</li><li><code>lint-html</code>：将检查结果写入一个网页文件<code>./reports/lint-results.html</code></li><li><code>lint-fix</code>：自动修正某些不规范的代码</li></ul><p>（5）运行静态检查命令。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> run lint  1:5  error    Unexpected var, use <span class="token keyword">let</span> or const instead  no-var  2:5  warning  Unexpected console statement              no-console✖ 2 problems <span class="token punctuation">(</span>1 error, 1 warning<span class="token punctuation">)</span></code></pre><p>正常情况下，该命令会从<code>index.js</code>脚本里面，检查出来两个错误：一个是不应该使用<code>var</code>命令，另一个是不应该在生产环境使用<code>console.log</code>方法。</p><p>（6）修正错误。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> run lint-fix</code></pre><p>运行上面的命令以后，再查看<code>index.js</code>，可以看到<code>var x = 1;</code>被自动改成了<code>const x = 1;</code>。这样就消除了一个错误，但是还留下一个错误。</p><p>（7）修改规则。</p><p>由于我们想要允许使用<code>console.log</code>方法，因此可以修改<code>.eslintrc.json</code>，改变<code>no-console</code>规则。请将<code>.eslintrc.json</code>改成下面的样子。</p><pre class=" language-javascript"><code class="language-javascript"><span class="token punctuation">{</span>  <span class="token string">"extends"</span><span class="token punctuation">:</span> <span class="token string">"airbnb-base"</span><span class="token punctuation">,</span>  <span class="token string">"rules"</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">"no-console"</span><span class="token punctuation">:</span> <span class="token string">"off"</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>再运行<code>npm run lint</code>，就不会报错了。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> run lint</code></pre><h1 id="我的收获"><a href="#我的收获" class="headerlink" title="我的收获"></a>我的收获</h1><p>其实这次我的目的就是来找找写接口的demo,其中的npm库<code>json-server</code>就符合我的目的,配置一份本地测试数据库的模拟JSON文件,以后就不用自己写在页面中的模拟假数据了.</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> nodejs </tag>
            
            <tag> eslint </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git原理入门[转]-阮一峰</title>
      <link href="/2018/10/23/Git%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8-%E8%BD%AC-%E9%98%AE%E4%B8%80%E5%B3%B0/"/>
      <url>/2018/10/23/Git%E5%8E%9F%E7%90%86%E5%85%A5%E9%97%A8-%E8%BD%AC-%E9%98%AE%E4%B8%80%E5%B3%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Git-原理入门"><a href="#Git-原理入门" class="headerlink" title="Git 原理入门"></a>Git 原理入门</h1><p>Git 是最流行的版本管理工具，也是程序员的必备技能之一。</p><p>即使天天使用它，很多人也未必了解它的原理。Git 为什么可以管理版本？<code>git add</code>、<code>git commit</code>这些基本命令，到底在做什么，你说得清楚吗？</p><p>这篇文章用一个实例，解释 Git 的运行过程，帮助你理解 Git 的原理。</p><h2 id="一、初始化"><a href="#一、初始化" class="headerlink" title="一、初始化"></a>一、初始化</h2><p>首先，让我们创建一个项目目录，并进入该目录。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">mkdir</span> git-demo-project$ <span class="token function">cd</span> git-demo-project</code></pre><p>我们打算对该项目进行版本管理，第一件事就是使用<code>git init</code>命令，进行初始化。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> init</code></pre><p><code>git init</code>命令只做一件事，就是在项目根目录下创建一个<code>.git</code>子目录，用来保存版本信息。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span> .gitbranches/configdescriptionHEADhooks/info/objects/refs/</code></pre><p>上面命令显示，<code>.git</code>内部还有一些子目录，这里先不解释它们的含义。</p><h2 id="二、保存对象"><a href="#二、保存对象" class="headerlink" title="二、保存对象"></a>二、保存对象</h2><p>接下来，新建一个空文件<code>test.txt</code>。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">touch</span> test.txt</code></pre><p>然后，把这个文件加入 Git 仓库，也就是为<code>test.txt</code>的当前内容创建一个副本。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> hash-object -w test.txte69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre><p>上面代码中，<code>git hash-object</code>命令把<code>test.txt</code>的当前内容压缩成二进制文件，存入 Git。压缩后的二进制文件，称为一个 Git 对象，保存在<code>.git/objects</code>目录。</p><p>这个命令还会计算当前内容的 SHA1 哈希值（长度40的字符串），作为该对象的文件名。下面看一下这个新生成的 Git 对象文件。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">ls</span> -R .git/objects.git/objects/e6:9de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre><p>上面代码可以看到，<code>.git/objects</code>下面多了一个子目录，目录名是哈希值的前2个字符，该子目录下面有一个文件，文件名是哈希值的后38个字符。</p><p>再看一下这个文件的内容。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cat</span> .git/objects/e6/9de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre><p>上面代码输出的文件内容，都是一些二进制字符。你可能会问，<code>test.txt</code>是一个空文件，为什么会有内容？这是因为二进制对象里面还保存一些元数据。</p><p>如果想看该文件原始的文本内容，要用<code>git cat-file</code>命令。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p e69de29bb2d1d6434b8b29ae775ad8c2e48c5391</code></pre><p>因为原始文件是空文件，所以上面的命令什么也看不到。现在向<code>test.txt</code>写入一些内容。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">'hello world'</span> <span class="token operator">></span> test.txt</code></pre><p>因为文件内容已经改变，需要将它再次保存成 Git 对象。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> hash-object -w test.txt3b18e512dba79e4c8300dd08aeb37f8e728b8dad</code></pre><p>上面代码可以看到，随着内容改变，<code>test.txt</code>的哈希值已经变了。同时，新文件<code>.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad</code>也已经生成了。现在可以看到文件内容了。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p 3b18e512dba79e4c8300dd08aeb37f8e728b8dadhello world</code></pre><h2 id="三、暂存区"><a href="#三、暂存区" class="headerlink" title="三、暂存区"></a>三、暂存区</h2><p>文件保存成二进制对象以后，还需要通知 Git 哪些文件发生了变动。所有变动的文件，Git 都记录在一个区域，叫做“暂存区”（英文叫做 index 或者 stage）。等到变动告一段落，再统一把暂存区里面的文件写入正式的版本历史。</p><p><code>git update-index</code>命令用于在暂存区记录一个发生变动的文件。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> update-index --add --cacheinfo 100644 \3b18e512dba79e4c8300dd08aeb37f8e728b8dad test.txt</code></pre><p>上面命令向暂存区写入文件名<code>test.txt</code>、二进制对象名（哈希值）和文件权限。</p><p><code>git ls-files</code>命令可以显示暂存区当前的内容。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> ls-files --stage100644 3b18e512dba79e4c8300dd08aeb37f8e728b8dad 0    test.txt</code></pre><p>上面代码表示，暂存区现在只有一个文件<code>test.txt</code>，以及它的二进制对象名和权限。知道了二进制对象名，就可以在<code>.git/objects</code>子目录里面读出这个文件的内容。</p><p><code>git status</code>命令会产生更可读的结果。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> status要提交的变更：    新文件：   test.txt</code></pre><p>上面代码表示，暂存区里面只有一个新文件<code>test.txt</code>，等待写入历史。</p><h2 id="四、git-add-命令"><a href="#四、git-add-命令" class="headerlink" title="四、git add 命令"></a>四、git add 命令</h2><p>上面两步（保存对象和更新暂存区），如果每个文件都做一遍，那是很麻烦的。Git 提供了<code>git add</code>命令简化操作。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> add --all</code></pre><p>上面命令相当于，对当前项目所有变动的文件，执行前面的两步操作。</p><h2 id="五、commit-的概念"><a href="#五、commit-的概念" class="headerlink" title="五、commit 的概念"></a>五、commit 的概念</h2><p>暂存区保留本次变动的文件信息，等到修改了差不多了，就要把这些信息写入历史，这就相当于生成了当前项目的一个快照（snapshot）。</p><p>项目的历史就是由不同时点的快照构成。Git 可以将项目恢复到任意一个快照。快照在 Git 里面有一个专门名词，叫做 commit，生成快照又称为完成一次提交。</p><p>下文所有提到“快照”的地方，指的就是 commit。</p><h2 id="六、完成提交"><a href="#六、完成提交" class="headerlink" title="六、完成提交"></a>六、完成提交</h2><p>首先，设置一下用户名和 Email，保存快照的时候，会记录是谁提交的。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> config user.name <span class="token string">"用户名"</span> $ <span class="token function">git</span> config user.email <span class="token string">"Email 地址"</span></code></pre><p>接下来，要保存当前的目录结构。前面保存对象的时候，只是保存单个文件，并没有记录文件之间的目录关系（哪个文件在哪里）。</p><p><code>git write-tree</code>命令用来将当前的目录结构，生成一个 Git 对象。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> write-treec3b8bb102afeca86037d5b5dd89ceeb0090eae9d</code></pre><p>上面代码中，目录结构也是作为二进制对象保存的，也保存在<code>.git/objects</code>目录里面，对象名就是哈希值。</p><p>让我们看一下这个文件的内容。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p c3b8bb102afeca86037d5b5dd89ceeb0090eae9d100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    test.txt</code></pre><p>可以看到，当前的目录里面只有一个<code>test.txt</code>文件。</p><p>所谓快照，就是保存当前的目录结构，以及每个文件对应的二进制对象。上一个操作，目录结构已经保存好了，现在需要将这个目录结构与一些元数据一起写入版本历史。</p><p><code>git commit-tree</code>命令用于将目录树对象写入版本历史。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"first commit"</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree c3b8bb102afeca86037d5b5dd89ceeb0090eae9dc9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</code></pre><p>上面代码中，提交的时候需要有提交说明，<code>echo &quot;first commit&quot;</code>就是给出提交说明。然后，<code>git commit-tree</code>命令将元数据和目录树，一起生成一个 Git 对象。现在，看一下这个对象的内容。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> cat-file -p c9053865e9dff393fd2f7a92a18f9bd7f2caa7fatree c3b8bb102afeca86037d5b5dd89ceeb0090eae9dauthor ruanyf <span class="token operator">&lt;</span>yifeng.ruan@gmail.com<span class="token operator">></span> 1538889134 +0800committer ruanyf <span class="token operator">&lt;</span>yifeng.ruan@gmail.com<span class="token operator">></span> 1538889134 +0800first commit</code></pre><p>上面代码中，输出结果的第一行是本次快照对应的目录树对象（tree），第二行和第三行是作者和提交人信息，最后是提交说明。</p><p><code>git log</code>命令也可以用来查看某个快照信息。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> log --stat c9053865e9dff393fd2f7a92a18f9bd7f2caa7facommit c9053865e9dff393fd2f7a92a18f9bd7f2caa7faAuthor: ruanyf <span class="token operator">&lt;</span>yifeng.ruan@gmail.com<span class="token operator">></span>Date:   Sun Oct 7 13:12:14 2018 +0800    first commit test.txt <span class="token operator">|</span> 1 + 1 <span class="token function">file</span> changed, 1 insertion<span class="token punctuation">(</span>+<span class="token punctuation">)</span></code></pre><h2 id="七、git-commit-命令"><a href="#七、git-commit-命令" class="headerlink" title="七、git commit 命令"></a>七、git commit 命令</h2><p>Git 提供了<code>git commit</code>命令，简化提交操作。保存进暂存区以后，只要<code>git commit</code>一个命令，就同时提交目录结构和说明，生成快照。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> commit -m <span class="token string">"first commit"</span></code></pre><p>此外，还有两个命令也很有用。</p><p><code>git checkout</code>命令用于切换到某个快照。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> checkout c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</code></pre><p><code>git show</code>命令用于展示某个快照的所有代码变动。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> show c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</code></pre><h2 id="八、branch-的概念"><a href="#八、branch-的概念" class="headerlink" title="八、branch 的概念"></a>八、branch 的概念</h2><p>到了这一步，还没完。如果这时用<code>git log</code>命令查看整个版本历史，你看不到新生成的快照。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> log</code></pre><p>上面命令没有任何输出，这是为什么呢？快照明明已经写入历史了。</p><p>原来<code>git log</code>命令只显示当前分支的变动，虽然我们前面已经提交了快照，但是还没有记录这个快照属于哪个分支。</p><p>所谓分支（branch）就是指向某个快照的指针，分支名就是指针名。哈希值是无法记忆的，分支使得用户可以为快照起别名。而且，分支会自动更新，如果当前分支有新的快照，指针就会自动指向它。比如，master 分支就是有一个叫做 master 指针，它指向的快照就是 master 分支的当前快照。</p><p>用户可以对任意快照新建指针。比如，新建一个 fix-typo 分支，就是创建一个叫做 fix-typo 的指针，指向某个快照。所以，Git 新建分支特别容易，成本极低。</p><p>Git 有一个特殊指针<code>HEAD</code>， 总是指向当前分支的最近一次快照。另外，Git 还提供简写方式，<code>HEAD^</code>指向 <code>HEAD</code>的前一个快照（父节点），<code>HEAD~6</code>则是<code>HEAD</code>之前的第6个快照。</p><p>每一个分支指针都是一个文本文件，保存在<code>.git/refs/heads/</code>目录，该文件的内容就是它所指向的快照的二进制对象名（哈希值）。</p><h2 id="九、更新分支"><a href="#九、更新分支" class="headerlink" title="九、更新分支"></a>九、更新分支</h2><p>下面演示更新分支是怎么回事。首先，修改一下<code>test.txt</code>。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"hello world again"</span> <span class="token operator">></span> test.txt</code></pre><p>然后，保存二进制对象。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> hash-object -w test.txtc90c5155ccd6661aed956510f5bd57828eec9ddb</code></pre><p>接着，将这个对象写入暂存区，并保存目录结构。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> update-index test.txt$ <span class="token function">git</span> write-tree1552fd52bc14497c11313aa91547255c95728f37</code></pre><p>最后，提交目录结构，生成一个快照。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> <span class="token string">"second commit"</span> <span class="token operator">|</span> <span class="token function">git</span> commit-tree \ 1552fd52bc14497c11313aa91547255c95728f37 -p \ c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa785f188674ef3c6ddc5b516307884e1d551f53ca</code></pre><p>上面代码中，<code>git commit-tree</code>的<code>-p</code>参数用来指定父节点，也就是本次快照所基于的快照。</p><p>现在，我们把本次快照的哈希值，写入<code>.git/refs/heads/master</code>文件，这样就使得<code>master</code>指针指向这个快照。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token keyword">echo</span> 785f188674ef3c6ddc5b516307884e1d551f53ca <span class="token operator">></span> .git/refs/heads/master</code></pre><p>现在，<code>git log</code>就可以看到两个快照了。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">git</span> logcommit 785f188674ef3c6ddc5b516307884e1d551f53ca <span class="token punctuation">(</span>HEAD -<span class="token operator">></span> master<span class="token punctuation">)</span>Author: ruanyf <span class="token operator">&lt;</span>yifeng.ruan@gmail.com<span class="token operator">></span>Date:   Sun Oct 7 13:38:00 2018 +0800    second commitcommit c9053865e9dff393fd2f7a92a18f9bd7f2caa7faAuthor: ruanyf <span class="token operator">&lt;</span>yifeng.ruan@gmail.com<span class="token operator">></span>Date:   Sun Oct 7 13:12:14 2018 +0800    first commit</code></pre><p><code>git log</code>的运行过程是这样的：</p><blockquote><ol><li>查找<code>HEAD</code>指针对应的分支，本例是<code>master</code></li><li>找到<code>master</code>指针指向的快照，本例是<code>785f188674ef3c6ddc5b516307884e1d551f53ca</code></li><li>找到父节点（前一个快照）<code>c9053865e9dff393fd2f7a92a18f9bd7f2caa7fa</code></li><li>以此类推，显示当前分支的所有快照</li></ol></blockquote><p>最后，补充一点。前面说过，分支指针是动态的。原因在于，下面三个命令会自动改写分支指针。</p><blockquote><ul><li><code>git commit</code>：当前分支指针移向新创建的快照。</li><li><code>git pull</code>：当前分支与远程分支合并后，指针指向新创建的快照。</li><li><code>git reset [commit_sha]</code>：当前分支指针重置为指定快照。</li></ul></blockquote><h2 id="十、参考链接"><a href="#十、参考链接" class="headerlink" title="十、参考链接"></a>十、参考链接</h2><ul><li><a href="https://medium.com/@shalithasuranga/how-does-git-work-internally-7c36dcb1f2cf" target="_blank" rel="noopener">How does git work internally</a>, Shalitha Suranga</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim优化-语法学习</title>
      <link href="/2018/10/22/vim%E4%BC%98%E5%8C%96-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/"/>
      <url>/2018/10/22/vim%E4%BC%98%E5%8C%96-%E8%AF%AD%E6%B3%95%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<p>vimrc 是控制 vim 行为的配置文件，位于 ~/.vimrc，不论 vim 窗口外观、显示字体，还是操作方式、快捷键、插件属性均可通过编辑该配置文件将 vim 调教成最适合你的编辑器。</p><h2 id="快捷键修改"><a href="#快捷键修改" class="headerlink" title="快捷键修改"></a>快捷键修改</h2><blockquote><p> 想要修改快捷键，必须了解vim的键映射map，它有五种前缀，对应着vim中的五种模式：</p></blockquote><pre><code>nore前缀： 非递归n前缀：    在普通模式下生效v前缀：    在可视模式下生效i前缀：     在插入模式下生效c前缀：    在EX命令模式下生效</code></pre><p>通过不同的前缀，就能明确告诉vim，我们自定义的快捷键在哪种模式下生效。</p><p>除此之外，还要配合键表：</p><p><k0>-<k9>       小键盘数字0到9</k9></k0></p><p><s-x>                大写S配合x，意味着shift+x组合键</s-x></p><p><c-x>               大写C配合x，意味着ctrl+x组合键</c-x></p><p><a-x>               大写A配合x，意味着alt+x组合键</a-x></p><p><esc>               ESC键</esc></p><p><bs>                backspace退格键</bs></p><p><cr>                ENTER回车键</cr></p><p><space>           空格键</space></p><p><shift>             shift键</shift></p><p><ctrl>               ctrl键</ctrl></p><p><alt>                alt键</alt></p><p><f1>-<f12>    F1到F12功能键</f12></f1></p><p>尽管能映射的键表非常丰富，但因为某些历史原因，ALT几乎无法映射。</p><p>同时CTRL键被系统频繁使用，F1到F12功能键某些也被vim占用。</p><p>比如F1是帮助，这些都不适合用来映射，以免造成快捷键冲突。</p><p>更改键盘默认按键时要特别注意, 不用递归</p><pre class=" language-vim"><code class="language-vim"><span class="token operator">/</span><span class="token operator">/</span> 例子nnoremap  i   <span class="token keyword">k</span>nnoremap  <span class="token keyword">k</span>  <span class="token keyword">j</span>nnoremap  <span class="token keyword">j</span>   <span class="token keyword">h</span></code></pre><p>此时使用的是前缀n ,表示在normal模式下生效,</p><p>使用前缀nore,表示不递归,否则按下i等于按下k,就等于按下j, 等等就乱套了.</p><h2 id="功能映射"><a href="#功能映射" class="headerlink" title="功能映射"></a>功能映射</h2><blockquote><p>vim自带的行光标移动也不方便，移动到行首^，需要按shift+6，移动到行尾$，需要按shift+4。</p></blockquote><p>个人也把它们进行映射：</p><pre class=" language-undefined"><code class="language-undefined">"行光标移动nmap lh   ^nmap le   $</code></pre><p>连续按下lh就表明移动到行首，lh可以理解成line_head，le理解成line_end.</p><p>具体用什么样的快捷键映射不重要，重要的是能不能方便自己使用与记忆。</p><p>我们可能需要频繁变更 .vimrc，要让变更内容生效，一般的做法是先保存 .vimrc 再重启 vim，太繁琐了。</p><p>增加如下设置，可以实现在保存 .vimrc 时自动重启加载它。</p><pre><code>&quot; 让配置变更立即生效autocmd BufWritePost $MYVIMRC source $MYVIMRC</code></pre><h2 id="前缀键"><a href="#前缀键" class="headerlink" title="前缀键"></a><leader>前缀键</leader></h2><blockquote><p>vim自带的快捷键很多，再加上各类插件提供的快捷键，我们自己定义的快捷键，这些混合在一起，非常容易引起按键的冲突，为了环境该问题，vim引入了<leader>前缀键。</leader></p></blockquote><p>前缀键的意思就是，在各种快捷键的最前面加上<leader>，避免了二义性。</leader></p><p>比如我们定义<leader>是<code>,</code>号:</leader></p><pre><code>let mapleader=&#39;,&#39;&quot;配合键盘映射nmap &lt;leader&gt;w   :w&lt;CR&gt;</code></pre><p>在普通模式按下#w时，就完成了文件的保存工作。</p><p>当然，最好还是把所有映射都设定为普通模式下有效，尽管在完成结果上没有什么区别，但违背了vim设定几种模式的本意，插入模式仅用来输入字符，功能都放进普通模式或者EX命令模式。</p><p>作者：dark_tone<br>原文：<a href="https://blog.csdn.net/dark_tone/article/details/52856032" target="_blank" rel="noopener">https://blog.csdn.net/dark_tone/article/details/52856032</a> </p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scss快速入门</title>
      <link href="/2018/10/22/scss%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"/>
      <url>/2018/10/22/scss%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="1-引入变量"><a href="#1-引入变量" class="headerlink" title="1.引入变量"></a>1.引入变量</h2><h3 id="变量声名"><a href="#变量声名" class="headerlink" title="变量声名"></a>变量声名</h3><p><code>$hightlight-color: #F90;</code></p><p>代码块中的变量可以和外部的重名, 互不影响.</p><h3 id="变量引用"><a href="#变量引用" class="headerlink" title="变量引用"></a>变量引用</h3><p>凡是<code>css</code>属性的标准值（比如说1px或者bold）可存在的地方，变量就可以使用。</p><h3 id="中划线还是下划线"><a href="#中划线还是下划线" class="headerlink" title="中划线还是下划线"></a>中划线还是下划线</h3><p>可以互相使用, 就是 声名用<code>-</code>时,引用可以<code>_</code>,不过还是推荐一致更好.</p><p>#2.父选择器标识符<code>&amp;</code></p><pre class=" language-css"><code class="language-css"><span class="token selector">article a </span><span class="token punctuation">{</span>  <span class="token selector">color: blue;  &amp;<span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>编译后</p><pre class=" language-css"><code class="language-css"><span class="token selector">article a </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> blue <span class="token punctuation">}</span><span class="token selector">article a<span class="token pseudo-class">:hover</span> </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red <span class="token punctuation">}</span></code></pre><blockquote><p> <code>&amp;</code>符号前边可以再加选择器</p></blockquote><h3 id="属性也可以嵌套"><a href="#属性也可以嵌套" class="headerlink" title="属性也可以嵌套"></a>属性也可以嵌套</h3><pre class=" language-scss"><code class="language-scss"><span class="token selector">nav </span><span class="token punctuation">{</span>  <span class="token selector">border: </span><span class="token punctuation">{</span>    <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span>    <span class="token property">style</span><span class="token punctuation">:</span> solid<span class="token punctuation">;</span>    <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="3-导入css-sass文件"><a href="#3-导入css-sass文件" class="headerlink" title="3.导入css/sass文件"></a>3.导入css/sass文件</h2><h3 id="默认变量值用-default"><a href="#默认变量值用-default" class="headerlink" title="默认变量值用 !default"></a>默认变量值用 <code>!default</code></h3><h2 id="4-静默注释"><a href="#4-静默注释" class="headerlink" title="4.  静默注释"></a>4.  静默注释</h2><pre class=" language-scss"><code class="language-scss"><span class="token selector">body </span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#333</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 这种注释内容不会出现在生成的css文件中</span>  <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* 这种注释内容会出现在生成的css文件中 */</span><span class="token punctuation">}</span></code></pre><h2 id="5-混合器-mixin"><a href="#5-混合器-mixin" class="headerlink" title="5.混合器 @mixin"></a>5.混合器 <code>@mixin</code></h2><p><code>sass</code>的混合器<code>@mixin</code>实现大段样式的重用.</p><p>用 @mixin 声名. 用 @include 使用.</p><pre class=" language-scss"><code class="language-scss"><span class="token keyword">@mixin</span> <span class="token selector">rounded-corners </span><span class="token punctuation">{</span>  <span class="token property">-moz-border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>  <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">notice </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px solid <span class="token hexcode">#00aa00</span><span class="token punctuation">;</span>  <span class="token keyword">@include</span> rounded-corners<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// sacc 最终生成</span><span class="token selector">.notice </span><span class="token punctuation">{</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">2</span>px solid <span class="token hexcode">#00aa00</span><span class="token punctuation">;</span>  <span class="token property">-moz-border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>  <span class="token property">-webkit-border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">5</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="何时使用混合器"><a href="#何时使用混合器" class="headerlink" title="何时使用混合器"></a>何时使用混合器</h3><p>利用混合器，可以很容易地在样式表的不同地方共享样式。如果你发现自己在不停地重复一段样式，那就应该把这段样式构造成优良的混合器，尤其是这段样式本身就是一个逻辑单元，比如说是一组放在一起有意义的属性。</p><p>判断一组属性是否应该组合成一个混合器，一条经验法则就是你能否为这个混合器想出一个好的名字。如果你能找到一个很好的短名字来描述这些属性修饰的样式，比如<code>rounded-corners``fancy-font</code>或者<code>no-bullets</code>，那么往往能够构造一个合适的混合器。如果你找不到，这时候构造一个混合器可能并不合适。</p><h3 id="混合器中的CSS规则"><a href="#混合器中的CSS规则" class="headerlink" title="混合器中的CSS规则"></a>混合器中的CSS规则</h3><p>混合器中不仅可以包含属性，也可以包含<code>css</code>规则，包含选择器和选择器中的属性，如下代码:</p><pre class=" language-scss"><code class="language-scss"><span class="token keyword">@mixin</span> <span class="token selector">no-bullets </span><span class="token punctuation">{</span>  <span class="token property">list-style</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>  <span class="token selector">li </span><span class="token punctuation">{</span>    <span class="token property">list-style-image</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token property">list-style-type</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span>    <span class="token property">margin-left</span><span class="token punctuation">:</span> <span class="token number">0</span>px<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="给混合器传参"><a href="#给混合器传参" class="headerlink" title="给混合器传参"></a>给混合器传参</h3><p> 例子</p><pre class=" language-scss"><code class="language-scss"><span class="token comment" spellcheck="true">// 定义</span><span class="token keyword">@mixin</span> <span class="token function">link-colors</span><span class="token punctuation">(</span><span class="token variable">$normal</span>, <span class="token variable">$hover</span>, <span class="token variable">$visited</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$normal</span><span class="token punctuation">;</span>  <span class="token selector"><span class="token parent important">&amp;</span>:hover </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$hover</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token selector"><span class="token parent important">&amp;</span>:visited </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$visited</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 使用</span><span class="token selector">a </span><span class="token punctuation">{</span>  <span class="token keyword">@include</span> <span class="token function">link-colors</span><span class="token punctuation">(</span>blue, red, green<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//Sass最终生成的是：</span><span class="token selector">a </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> blue<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector">a:hover </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> red<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector">a:visited </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>当你@include混合器时，有时候可能会很难区分每个参数是什么意思，参数之间是一个什么样的顺序。为了解决这个问题，<code>sass</code>允许通过语法<code>$name: value</code>的形式指定每个参数的值。这种形式的传参，参数顺序就不必再在乎了，只需要保证没有漏掉参数即可：</p><pre class=" language-scss"><code class="language-scss"><span class="token selector">a </span><span class="token punctuation">{</span>    <span class="token keyword">@include</span> <span class="token function">link-colors</span><span class="token punctuation">(</span>      <span class="token property"><span class="token variable">$normal</span></span><span class="token punctuation">:</span> blue,      <span class="token property"><span class="token variable">$visited</span></span><span class="token punctuation">:</span> green,      <span class="token property"><span class="token variable">$hover</span></span><span class="token punctuation">:</span> red  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><p>为了在<code>@include</code>混合器时不必传入所有的参数，我们可以给参数指定一个默认值。参数默认值使用<code>$name: default-value</code>的声明形式，默认值可以是任何有效的<code>css</code>属性值，甚至是其他参数的引用，如下代码：</p><pre class=" language-scss"><code class="language-scss"><span class="token keyword">@mixin</span> <span class="token function">link-colors</span><span class="token punctuation">(</span>    <span class="token variable">$normal</span>,    <span class="token property"><span class="token variable">$hover</span></span><span class="token punctuation">:</span> <span class="token variable">$normal</span>,    <span class="token property"><span class="token variable">$visited</span></span><span class="token punctuation">:</span> <span class="token variable">$normal</span>  <span class="token punctuation">)</span><span class="token punctuation">{</span>  <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$normal</span><span class="token punctuation">;</span>  <span class="token selector"><span class="token parent important">&amp;</span>:hover </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$hover</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>  <span class="token selector"><span class="token parent important">&amp;</span>:visited </span><span class="token punctuation">{</span> <span class="token property">color</span><span class="token punctuation">:</span> <span class="token variable">$visited</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>如果像下边这样调用：<code>@include link-colors(red)</code> <code>$hover</code>和<code>$visited</code>也会被自动赋值为<code>red</code>。</p><h2 id="6-使用选择器继承来精简CSS"><a href="#6-使用选择器继承来精简CSS" class="headerlink" title="6.使用选择器继承来精简CSS"></a>6.使用选择器继承来精简CSS</h2><p>继承一个类的所有样式到被继承的地方:</p><pre class=" language-scss"><code class="language-scss"><span class="token comment" spellcheck="true">//通过选择器继承继承样式</span><span class="token selector">.error </span><span class="token punctuation">{</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#fdd</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.seriousError </span><span class="token punctuation">{</span>  <span class="token keyword">@extend</span> <span class="token number">.</span>error<span class="token punctuation">;</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">3</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 渲染后</span><span class="token selector">.error, .seriousError </span><span class="token punctuation">{</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid red<span class="token punctuation">;</span>  <span class="token property">background-color</span><span class="token punctuation">:</span> <span class="token hexcode">#fdd</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">.seriousError </span><span class="token punctuation">{</span>  <span class="token property">border-width</span><span class="token punctuation">:</span> <span class="token number">3</span>px<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通常使用继承会让你的<code>css</code>美观、整洁。因为继承只会在生成<code>css</code>时复制选择器，而不会复制大段的<code>css</code>属性。但是如果你不小心，可能会让生成的<code>css</code>中包含大量的选择器复制,解决办法是:</p><p>不要在<code>css</code>规则中使用后代选择器去继承<code>css</code>规则.如:</p><pre class=" language-scss"><code class="language-scss"><span class="token selector">.foo .bar </span><span class="token punctuation">{</span> <span class="token keyword">@extend</span> <span class="token number">.</span>baz<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token selector">.bip .baz </span><span class="token punctuation">{</span> <span class="token property">a</span><span class="token punctuation">:</span> b<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>在上边的例子中，<code>sass</code>必须保证应用到.baz的样式同时也要应用到<code>.foo .bar</code>（位于class=”foo”的元素内的class=”bar”的元素）。例子中有一条应用到<code>.bip .baz</code>（位于class=”bip”的元素内的class=”baz”的元素）的<code>css</code>规则。当这条规则应用到<code>.foo .bar</code>时，可能存在三种情况，如下代码:</p><pre class=" language-scss"><code class="language-scss">&lt;!-- 继承可能迅速变复杂 -->&lt;!-- Case <span class="token number">1</span> -->&lt;div class=<span class="token string">"foo"</span>>  &lt;div class=<span class="token string">"bip"</span>>    &lt;div class=<span class="token string">"bar"</span>><span class="token number">...</span>&lt;/div>  &lt;/div>&lt;/div>&lt;!-- Case <span class="token number">2</span> -->&lt;div class=<span class="token string">"bip"</span>>  &lt;div class=<span class="token string">"foo"</span>>    &lt;div class=<span class="token string">"bar"</span>><span class="token number">...</span>&lt;/div>  &lt;/div>&lt;/div>&lt;!-- Case <span class="token number">3</span> -->&lt;div class=<span class="token string">"foo bip"</span>>  &lt;div class=<span class="token string">"bar"</span>><span class="token number">...</span>&lt;/div>&lt;/div></code></pre><blockquote><p>不要用后代选择器去继承。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>变量是<code>sass</code>提供的最基本的工具. 通过变量可以让独立的<code>css</code>值变得可重用, 无论是在一条单独的样式还是一段样式. 变量和混合器的命名可以通用<code>-</code>和<code>_</code>. 还提供的<code>&amp;</code>父选择标识符, 可以在嵌套中直接给父级添加伪类处理.</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> scss </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js深入浅出笔记-jrg</title>
      <link href="/2018/10/19/js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B0-jrg/"/>
      <url>/2018/10/19/js%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%AC%94%E8%AE%B0-jrg/</url>
      
        <content type="html"><![CDATA[<h1 id="js深入浅出"><a href="#js深入浅出" class="headerlink" title="js深入浅出"></a>js深入浅出</h1><h2 id="你真的懂函数吗"><a href="#你真的懂函数吗" class="headerlink" title="你真的懂函数吗"></a>你真的懂函数吗</h2><ul><li><p>匿名函数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//fn 是匿名函数的引用.</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'fn'</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">var</span> fn2 <span class="token operator">=</span> fn<span class="token punctuation">;</span>fn<span class="token punctuation">.</span>name<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// fn</span>fn2<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// fn</span><span class="token comment" spellcheck="true">// 此时匿名函数是有name的</span></code></pre></li><li><p>具名函数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">fn3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// 这是一个具名函数,如果这个具名函数的声名在 window</span>    <span class="token keyword">return</span> <span class="token number">3</span>    <span class="token comment" spellcheck="true">//则 全局都可以访问</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 但是 如果像下面 把具名函数赋给一个变量 则它在window 访问是undefined</span><span class="token keyword">var</span> fn5 <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token function">fn4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 只是此时fn4 的 访问只能在 = 后 到 ; 前,</span></code></pre></li><li><p>箭头函数</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 如果只有 一个 参数 且只有 return 语句</span><span class="token keyword">var</span> fn6 <span class="token operator">=</span> i <span class="token operator">=</span><span class="token operator">></span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 如果有多个 参数 则必须 括起来, 如果 不只有 return ,则必须用大括号括起来</span><span class="token keyword">var</span> fn6 <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p><strong>js语义分析</strong></p><p>  抽象词法树</p><h2 id="stack-栈-先进先出"><a href="#stack-栈-先进先出" class="headerlink" title="stack 栈  先进先出"></a>stack 栈  先进先出</h2><p>js是单线程的遇到函数就要进去执行,此时需要记住是在哪里进去的,这时候就像stack中添加一个记号,然后 函数执行完后,退出的时候,就从stack中取出这个记号,再往下执行.</p><h3 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h3><p>函数调用的最正确的方法</p><pre class=" language-js"><code class="language-js">fn<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 其中call有两个参数,  第一个是 this.(必须是个对象,不传在浏览器中默认是window) 第二个是 arguments</span></code></pre><ul><li>chrome的console.log 打印 fn.call() 的第一个参数this的时候 打印出来的是Window .其实是window</li><li>this 就是call 的第一个参数 <strong>记住</strong></li><li>fn() 是阉割版的 fn.call();</li><li>this必须是一个对象  它是函数和对象之间的羁绊</li><li>对象中的函数是独立的, 和对象没有一点关系, 只是js 在你用 对象.函数的时候自动把. 前面的对象 传给 call的第一个参数</li></ul><h3 id="call-apply"><a href="#call-apply" class="headerlink" title="call / apply"></a>call / apply</h3><ul><li>如果你知道你的参数个数 则可以用call, 如果不知道有多少项 , 就使用 apply</li></ul><h3 id="bind"><a href="#bind" class="headerlink" title="bind"></a>bind</h3><blockquote><p>fn.bind.call(fn,{},1,2,3)</p></blockquote><ul><li>call和apply 都是直接调用函数, 而 bind 则是返回一个函数 (return function)</li><li>bind的作用实在你调用函数的后边加一个call , 不是现在加,而实在 调用这个新返回函数的时候加</li></ul><h3 id="柯里化-高阶函数"><a href="#柯里化-高阶函数" class="headerlink" title="柯里化 / 高阶函数"></a>柯里化 / 高阶函数</h3><blockquote><p>返回的函数的函数</p></blockquote><ul><li>柯里化：将 f(x,y) 变成 f(x=1)(y) 或 f(y=1)x</li></ul><pre><code>  //柯里化之前  function sum(x,y){      return x+y  }  //柯里化之后  function addOne(y){      return sum(1, y)  }  //柯里化之前  function Handlebar(template, data){      return template.replace(&#39;{{name}}&#39;, data.name)  }  //柯里化之后  function Handlebar(template){      return function(data){          return template.replace(&#39;{{name}}&#39;, data.name)      }  }</code></pre><ul><li><p>柯里化可以将真实计算拖延到最后再做</p><p>关于柯里化的高级文章：</p><ol><li><a href="http://www.yinwang.org/blog-cn/2013/04/02/currying" target="_blank" rel="noopener">http://www.yinwang.org/blog-cn/2013/04/02/currying</a></li><li><a href="https://zhuanlan.zhihu.com/p/31271179" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/31271179</a></li></ol></li><li><p>高阶函数：</p><p>在数学和计算机科学中，高阶函数是至少满足下列一个条件的函数：</p><ol><li><p>接受一个或多个函数作为输入：forEach sort map filter reduce</p></li><li><p>输出一个函数：lodash.curry</p></li><li><p>不过它也可以同时满足两个条件：Function.prototype.bind</p></li></ol></li></ul><h3 id="数组的方法-是-高阶函数"><a href="#数组的方法-是-高阶函数" class="headerlink" title="数组的方法  是 高阶函数"></a>数组的方法  是 高阶函数</h3><ul><li><p>map</p></li><li><p>filter</p></li><li><p>reduce</p></li><li><p>sort</p></li><li><p>forEach</p></li></ul><h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><blockquote><p>名词形式：被当做参数的函数就是回调<br>动词形式：调用这个回调</p></blockquote><blockquote><p>回调和异步不是一回事</p></blockquote><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><blockquote><p>返回对象的函数就是构造函数<br>一般首字母大写</p></blockquote><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><blockquote><p>不接受指定this(call)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo美化</title>
      <link href="/2018/10/17/hexo%E7%BE%8E%E5%8C%96/"/>
      <url>/2018/10/17/hexo%E7%BE%8E%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h3 id="为Hexo博客的代码片段添加-选择全部-按钮"><a href="#为Hexo博客的代码片段添加-选择全部-按钮" class="headerlink" title="为Hexo博客的代码片段添加 选择全部 按钮"></a>为Hexo博客的代码片段添加 选择全部 按钮</h3><p>Hexo生成的博客中，代码片段是不支持选择全部功能的，若代码片段较长，手动选择非常的不方便。<br>添加的方法如下。<br>在页面模板文件（对于Next主题，模板文件为themes/next/layout/_layout.swig）的<head><meta name="generator" content="Hexo 3.9.0">节点中添加如下代码。<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head></p><pre class=" language-js"><code class="language-js"><span class="token function">$</span><span class="token punctuation">(</span>document<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">ready</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> SelectText <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> doc <span class="token operator">=</span> document            <span class="token punctuation">,</span> text <span class="token operator">=</span> element            <span class="token punctuation">,</span> range<span class="token punctuation">,</span> selection        <span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>doc<span class="token punctuation">.</span>body<span class="token punctuation">.</span>createTextRange<span class="token punctuation">)</span> <span class="token punctuation">{</span>            range <span class="token operator">=</span> document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">createTextRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            range<span class="token punctuation">.</span><span class="token function">moveToElementText</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>            range<span class="token punctuation">.</span><span class="token function">select</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>window<span class="token punctuation">.</span>getSelection<span class="token punctuation">)</span> <span class="token punctuation">{</span>            selection <span class="token operator">=</span> window<span class="token punctuation">.</span><span class="token function">getSelection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            range <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createRange</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            range<span class="token punctuation">.</span><span class="token function">selectNodeContents</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span>            selection<span class="token punctuation">.</span><span class="token function">removeAllRanges</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            selection<span class="token punctuation">.</span><span class="token function">addRange</span><span class="token punctuation">(</span>range<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">".code"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">each</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> code <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">var</span> button_html <span class="token operator">=</span><span class="token template-string"><span class="token string">`            &lt;div style="position: fixed;                                                                                       right: 3%;                                                                                             margin-top: 5px;                                                                                      font-family: consolas, Menlo, \'PingFang SC\', \'Microsoft YaHei\', monospace;                        font-size: 10px;                                                                                      cursor: pointer;                                                                                      color: #e31436;                                                                                       ">                                                                                         &lt;span>全选&lt;/pan>                                                                                      &lt;/div>`</span></span><span class="token punctuation">;</span>        <span class="token keyword">var</span> button <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span>button_html<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">$</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">SelectText</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">$</span><span class="token punctuation">(</span>button<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">insertBefore</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>clip-path</title>
      <link href="/2018/10/16/clip-path/"/>
      <url>/2018/10/16/clip-path/</url>
      
        <content type="html"><![CDATA[<h1 id="clip-path"><a href="#clip-path" class="headerlink" title="clip-path"></a>clip-path</h1><p>clip-path属性可以创建一个只有元素的部分区域可以显示的剪切区域。区域内的部分显示，区域外的隐藏。剪切区域是被引用内嵌的URL定义的路径或者外部svg的路径，或者作为一个形状例如<a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/circle" target="_blank" rel="noopener">circle()</a>.。clip-path属性代替了现在已经弃用的剪切 <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/clip" target="_blank" rel="noopener">clip</a>属性。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><pre class=" language-css"><code class="language-css"><span class="token selector">img</span><span class="token punctuation">{</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">155</span>px<span class="token punctuation">;</span>  <span class="token property">height</span><span class="token punctuation">:</span> <span class="token number">160</span>px<span class="token punctuation">;</span>  <span class="token property">border</span><span class="token punctuation">:</span> <span class="token number">1</span>px solid <span class="token hexcode">#f7f7f9</span><span class="token punctuation">;</span>  <span class="token property">border-radius</span><span class="token punctuation">:</span> <span class="token number">6</span>px<span class="token punctuation">;</span>  <span class="token property">clip-path</span><span class="token punctuation">:</span><span class="token function">polygon</span><span class="token punctuation">(</span><span class="token number">50%</span> <span class="token number">0</span>,<span class="token number">100%</span> <span class="token number">50%</span>,<span class="token number">50%</span> <span class="token number">100%</span>,<span class="token number">0</span> <span class="token number">50%</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token property">transition</span><span class="token punctuation">:</span> clip-path <span class="token number">1</span>s <span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">img<span class="token pseudo-class">:hover</span></span><span class="token punctuation">{</span>  <span class="token property">clip-path</span><span class="token punctuation">:</span><span class="token function">polygon</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token number">0</span>,<span class="token number">100%</span> <span class="token number">0</span>,<span class="token number">100%</span> <span class="token number">100%</span>,<span class="token number">0</span> <span class="token number">100%</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><img src="/images/clip-pathDemo.GIF" alt="hoverDemo"></p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>classList-原生代替jquery的类名切换属性</title>
      <link href="/2018/10/15/classList-%E5%8E%9F%E7%94%9F%E4%BB%A3%E6%9B%BFjquery%E7%9A%84%E7%B1%BB%E5%90%8D%E5%88%87%E6%8D%A2%E5%B1%9E%E6%80%A7/"/>
      <url>/2018/10/15/classList-%E5%8E%9F%E7%94%9F%E4%BB%A3%E6%9B%BFjquery%E7%9A%84%E7%B1%BB%E5%90%8D%E5%88%87%E6%8D%A2%E5%B1%9E%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="MDN描述"><a href="#MDN描述" class="headerlink" title="MDN描述"></a>MDN描述</h2><p><code>Element.classList</code> 是一个只读属性,返回元素的类属性的实时<code>DOMTokenList</code>集合.</p><p>使用<code>classList</code>是代替<code>element.className</code>作为空格分隔的字符串访问元素的类列表的一种简便方法.</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><blockquote><p>let elementClasses = elementNodeReference.classList;</p></blockquote><p><strong>elementClasses</strong>是一个<code>DOMTokenList</code>表示<code>elementNodeReference</code>的类属性.如果元素为设置类名则属性为空. 则 <strong>elementClasses.length</strong>返回0. 虽然 <strong>element.classList</strong>本身是只读的,但是可以使用 <strong>add()</strong>和 <strong>remove()</strong>方法修改它.</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p><strong>add( String [, String] )</strong></p><p>​    添加指定的类值. 如果类存在 则忽略.可以是多个</p><p><strong>remove( String [,String] )</strong></p><p>​    删除指定的类值. 可以是多个.</p><p><strong>item ( Number )</strong></p><p>​    按集合中的索引返回类值.</p><p><strong>toggle( String [, force] )</strong> </p><p>​    当只有一个参数时, 切换类值.</p><p>​    当有第二个参数时, 如果第二个参数计算结果为ture,则添加指定类值.如果为false.则删除它.</p><p><strong>contains( String )</strong></p><p>​    检查元素的了类属性中是否存在指定的类值</p><p><strong>replace( oldClass, newClass )</strong><br>​    用一个新类替换已有的类.</p><h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>chrome和firefox支持所有属性.</p><p>ie10 只实现处理一个参数,<strong>add/remove方法不支持多参数处理</strong>。默认只会处理第一个参数</p><p>opera和safari除了<code>replace</code>未实现,其他都已实现.</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>grep命令-每天一个linux命令</title>
      <link href="/2018/10/12/grep%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/12/grep%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>grep（global search regular expression(RE) and print out the line，全面搜索正则表达式并把行打印出来）是一种强大的文本搜索工具，它能使用正则表达式搜索文本，并把匹配的行打印出来。</p>]]></content>
      
      
      <categories>
          
          <category> Back-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>cp命令-每天一个linux命令</title>
      <link href="/2018/10/11/cp%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/"/>
      <url>/2018/10/11/cp%E5%91%BD%E4%BB%A4-%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AAlinux%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="cp-命令-–每天一个linux命令"><a href="#cp-命令-–每天一个linux命令" class="headerlink" title="cp 命令 –每天一个linux命令"></a>cp 命令 –每天一个linux命令</h1><p><strong>cp命令</strong>用来将一个或多个源文件或者目录复制到指定的文件或目录。他可以将单个源文件复制成一个指定文件名的具体文件或者一个已经存在的目录下.cp命令还支持同时复制多个文件,当一次复制多个文件时,目的文件参数必须是一个已经存在的目录,否则会报错.</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><blockquote><p>cp (选项)（参数）</p></blockquote><h2 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h2><blockquote><p>-r 复制文件夹</p><p>-v 显示操作详细信息</p><p>-i 以交互模式进行(覆盖之前询问)</p><p>-u 如果文件存在则更新,不存在则复制;</p></blockquote><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><blockquote><p>源文件:  可以是多个 用 <code>空格</code>隔开, 默认不能复制目录, 想用必须用<code>-r</code>;</p><p>目标文件:  当源文件有多个时, 要求目标文件为指定目录(必须存在).</p></blockquote><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>将文件file复制到目录<code>/usr/men/tmp</code>下，并改名为file1</p><pre><code>cp file /usr/men/tmp/file1</code></pre><p>将目录<code>/usr/men</code>下的所有文件及其子目录复制到目录<code>/usr/zh</code>中</p><pre><code>cp -r /usr/men /usr/zh</code></pre><p>交互式地将目录<code>/usr/men</code>中的以m打头的所有.c文件复制到目录<code>/usr/zh</code>中</p><pre><code>cp -i /usr/men m*.c /usr/zh</code></pre><p>下面的第一行中是 cp 命令和具体的参数（-r 是“递归”， -u 是“更新”，-v 是“详细”）。接下来的三行显示被复制文件的信息，最后一行显示命令行提示符。这样，只拷贝新的文件到我的存储设备上，我就使用 cp 的“更新”和“详细”选项。</p><p>通常来说，参数 <code>-r</code> 也可用更详细的风格 <code>--recursive</code>。但是以简短的方式，也可以这么连用 <code>-ruv</code>。</p><pre><code>cp -r -u -v /usr/men/tmp ~/men/tmp</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue中使用Font Awesome</title>
      <link href="/2018/10/08/vue%E4%B8%AD%E4%BD%BF%E7%94%A8Font-Awesome/"/>
      <url>/2018/10/08/vue%E4%B8%AD%E4%BD%BF%E7%94%A8Font-Awesome/</url>
      
        <content type="html"><![CDATA[<h1 id="在vue项目中使用Font-Awesome"><a href="#在vue项目中使用Font-Awesome" class="headerlink" title="在vue项目中使用Font Awesome"></a>在vue项目中使用Font Awesome</h1><p><strong>Font Awesome</strong>是一个十分优秀的第三方图标库，<strong>Vue</strong>是一个目前最火的前端框架，那么如何把二者结合起来，就是本文的目的。</p><h2 id="（一）官方"><a href="#（一）官方" class="headerlink" title="（一）官方"></a>（一）官方</h2><h3 id="一、准备工作"><a href="#一、准备工作" class="headerlink" title="一、准备工作"></a>一、准备工作</h3><p><strong>1. 安装基础依赖</strong></p><p>进入Vue项目文件夹，执行如下命令安装基础依赖库：</p><pre class=" language-sh"><code class="language-sh">npm i --save @fortawesome/fontawesome-svg-corenpm i --save @fortawesome/vue-fontawesome            </code></pre><p><strong>2. 安装样式依赖</strong></p><p>Font Awesome 为我们提供了<code>Solid</code>,<code>Regular</code>, <code>Brands</code>这三种免费样式，执行如下命令安装：</p><pre class=" language-sh"><code class="language-sh">npm i --save @fortawesome/free-solid-svg-iconsnpm i --save @fortawesome/free-regular-svg-iconsnpm i --save @fortawesome/free-brands-svg-icons</code></pre><p><strong>3. 配置vue项目下的<code>src/main.js</code></strong></p><p>配置如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">import</span> <span class="token punctuation">{</span> library <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@fortawesome/fontawesome-svg-core'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> fas <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@fortawesome/free-solid-svg-icons'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> far <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@fortawesome/free-regular-svg-icons'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> fab <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@fortawesome/free-brands-svg-icons'</span><span class="token keyword">import</span> <span class="token punctuation">{</span> FontAwesomeIcon<span class="token punctuation">,</span> FontAwesomeLayers<span class="token punctuation">,</span> FontAwesomeLayersText <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'@fortawesome/vue-fontawesome'</span>library<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fas<span class="token punctuation">,</span> far<span class="token punctuation">,</span> fab<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//添加3中样式</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'font-awesome-icon'</span><span class="token punctuation">,</span> FontAwesomeIcon<span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 我只用这个</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'font-awesome-layers'</span><span class="token punctuation">,</span> FontAwesomeLayers<span class="token punctuation">)</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'font-awesome-layers-text'</span><span class="token punctuation">,</span> FontAwesomeLayersText<span class="token punctuation">)</span></code></pre><h3 id="二、样式介绍"><a href="#二、样式介绍" class="headerlink" title="二、样式介绍"></a>二、样式介绍</h3><p>三种免费样式，使用的时候分别对应不同的前缀</p><ul><li><code>solid</code>样式，前缀为<code>fas</code> </li><li><code>regular</code>样式，前缀为<code>far</code></li><li><code>brands</code>样式，前缀为<code>fab</code>  </li></ul><h3 id="三、基本用法-显示图标"><a href="#三、基本用法-显示图标" class="headerlink" title="三、基本用法 显示图标"></a>三、基本用法 显示图标</h3><ol><li><p>显示</p><p>a. 我们使用 font-awesome-icon 标签来显示图标，icon 属性中可以设置样式前缀、以及图标名字。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">:icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[<span class="token punctuation">'</span>fas<span class="token punctuation">'</span>, <span class="token punctuation">'</span>square<span class="token punctuation">'</span>]<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">:icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[<span class="token punctuation">'</span>far<span class="token punctuation">'</span>, <span class="token punctuation">'</span>square<span class="token punctuation">'</span>]<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">:icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>[<span class="token punctuation">'</span>fab<span class="token punctuation">'</span>, <span class="token punctuation">'</span>accessible-icon<span class="token punctuation">'</span>]<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li></ol><p>   b. 如果是 solid 样式（前缀为：fas），则前缀可以省略。比如上面第一个图标等效下面写法：</p><pre class=" language-html"><code class="language-html">   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>square<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><ol start="2"><li><p>设置图标大小</p><p>默认情况下图标和当前文字的大小是一样的。我们可以通过 size 属性在此基础上作调整，该属性支持多种类型的设置方式</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>xs<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lg<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2x<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li><li><p>固定图标宽度<br>使用 fixed-width 可以固定图标宽度。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>home<span class="token punctuation">"</span></span> <span class="token attr-name">fixed-width</span> <span class="token punctuation">/></span></span> home <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>child<span class="token punctuation">"</span></span> <span class="token attr-name">fixed-width</span> <span class="token punctuation">/></span></span> help <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cog<span class="token punctuation">"</span></span> <span class="token attr-name">fixed-width</span> <span class="token punctuation">/></span></span> settings <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span></code></pre></li><li><p>旋转图标</p><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">rotation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">rotation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>90<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">rotation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>180<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">rotation</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>270<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li><li><p>翻转图标</p><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">flip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>horizontal<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">flip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>vertical<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chess-knight<span class="token punctuation">"</span></span> <span class="token attr-name">flip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>both<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li><li><p>旋转动画效果<br> a. 添加 spin 属性可以让图标不停地顺时针旋转。</p><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>arrow-circle-down<span class="token punctuation">"</span></span> <span class="token attr-name">spin</span> <span class="token punctuation">/></span></span></code></pre><p> b.添加 pulse 属性同样可以让图标旋转，但它不像 spin 那样是均匀地变化角度，而是 0 度、45 度、90 度…这样跳跃地变化。</p><pre class=" language-html"><code class="language-html"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>arrow-circle-down<span class="token punctuation">"</span></span> <span class="token attr-name">pulse</span> <span class="token punctuation">/></span></span></code></pre></li><li><p>图片居左、居右显示<br>有时我们需要让图标一直在最左侧或最右侧（在做文字围绕图标效果时会用到）。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2x<span class="token punctuation">"</span></span> <span class="token attr-name">pull</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>left<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>Font Awsome is awsome. Font Awsome is awsome. Font Awsome is awsome.</code></pre></li><li><p>给图标加上边框(border)</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token attr-name">size</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2x<span class="token punctuation">"</span></span> <span class="token attr-name">pull</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>right<span class="token punctuation">"</span></span> <span class="token attr-name">border</span> <span class="token punctuation">/></span></span></code></pre></li></ol><h3 id="四、进阶用法"><a href="#四、进阶用法" class="headerlink" title="四、进阶用法"></a>四、进阶用法</h3><p><strong>a. 变形、自由变换（Transforms）</strong><br>​    1. 变形、自由变换（Transforms）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token attr-name">transform</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shrink-6 left-4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><pre><code>2. 下面样例将第二个图标顺时针旋转 42 度：</code></pre><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>br</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>clipboard-list<span class="token punctuation">"</span></span> <span class="token attr-name">:transform</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>{ rotate: 42 }<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p><strong>b. 遮罩</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span>  <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span> <span class="token attr-name">mask</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span>  <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span> <span class="token attr-name">mask</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>square<span class="token punctuation">"</span></span>  <span class="token punctuation">/></span></span></code></pre><p><strong>c. 多个图标的组合使用</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-layers</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa-lg<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>circle<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> green<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>check<span class="token punctuation">"</span></span> <span class="token attr-name">transform</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>shrink-6<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span> white<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font-awesome-layers</span><span class="token punctuation">></span></span></code></pre><p><strong>d. 图标与文字的组合使用</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-layers</span> <span class="token attr-name">full-width</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa-4x<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>star<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-layers-text</span> <span class="token attr-name">transform</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>down-1 right-1 shrink-14<span class="token punctuation">"</span></span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hello<span class="token punctuation">"</span></span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">color</span><span class="token punctuation">:</span>white</span><span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>font-awesome-layers</span><span class="token punctuation">></span></span></code></pre><p><strong>e.动态改变图标（图标的绑定）</strong></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>template</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>font-awesome-icon</span> <span class="token attr-name">:icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>icon<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>template</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">icon</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token string">'fas'</span><span class="token punctuation">,</span> <span class="token string">'coffee'</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h2 id="（二）Vue-Awesome-内置Font-Awesome图标"><a href="#（二）Vue-Awesome-内置Font-Awesome图标" class="headerlink" title="（二）Vue-Awesome 内置Font Awesome图标"></a>（二）Vue-Awesome 内置Font Awesome图标</h2><blockquote><p>基于 Vue.js 的强大 SVG 图标组件。已内置 Font Awesome 图标。<br>Vue-Awesome 是基于 <a href="https://vuejs.org/" target="_blank" rel="noopener">Vue.js</a> 的 SVG 图标组件，内置图标来自 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome</a>。</p></blockquote><p>查看<a href="https://justineo.github.io/vue-awesome/demo/" target="_blank" rel="noopener">此处</a>的 demo 一睹为快。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><pre class=" language-sh"><code class="language-sh">npm install vue-awesome</code></pre><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 基础用法 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beer<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 添加选项 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sync<span class="token punctuation">"</span></span> <span class="token attr-name">scale</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">spin</span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>comment<span class="token punctuation">"</span></span> <span class="token attr-name">flip</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>horizontal<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>code-branch<span class="token punctuation">"</span></span> <span class="token attr-name">label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Forked Repository<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token comment" spellcheck="true">&lt;!-- 堆叠图标 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>No Photos<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>camera<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>v-icon</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ban<span class="token punctuation">"</span></span> <span class="token attr-name">scale</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>alert<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>v-icon</span><span class="token punctuation">></span></span></code></pre><p>Font Awesome 5 开始把所有图标分成了多个包。Vue-Awesome 的图标都来自其中的免费图标，而免费图标分别来自 3 个不同的图标包：<code>regular</code>、<code>solid</code> 和 <code>brands</code>。因为 <code>solid</code> 下的免费图标数量最多，所以我们选择按如下方式来组织图标：</p><ul><li>所有来自 <code>solid</code> 包的图标位于 <code>vue-awesome/icons</code> 目录下，且 <code>name</code> prop 的值不带前缀。</li><li>来自 <code>regular</code> 和 <code>brands</code> 的图标位于 <code>vue-awesome/icons/regular</code> 和 <code>vue-awesome/icons/brands</code> 目录下，且 <code>name</code> prop 的值需要添加前缀，例如 <code>regular/flag</code> 或者 <code>brands/reddit</code>。</li></ul><p>请访问 <a href="https://fontawesome.com/" target="_blank" rel="noopener">Font Awesome 官网</a>以查询可以使用的 <code>name</code> 值，如 <code>beer</code>、<code>file</code>、<code>camera</code> 等。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><p><strong>用 npm 与 vue-loader 基于 ES Module 引入（推荐用法）</strong></p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">'vue'</span>  <span class="token comment" spellcheck="true">// 必须</span><span class="token comment" spellcheck="true">/* 在下面两种方式中任选一种 */</span><span class="token comment" spellcheck="true">// 仅引入用到的图标以减小打包体积</span><span class="token keyword">import</span> <span class="token string">'vue-awesome/icons/flag'</span><span class="token comment" spellcheck="true">// 或者在不关心打包体积时一次引入全部图标</span><span class="token keyword">import</span> <span class="token string">'vue-awesome/icons'</span><span class="token comment" spellcheck="true">/* 任选一种注册组件的方式 */</span><span class="token keyword">import</span> Icon <span class="token keyword">from</span> <span class="token string">'vue-awesome/components/Icon'</span> <span class="token comment" spellcheck="true">// 必须</span><span class="token comment" spellcheck="true">// 全局注册（在 `main .js` 文件中）</span>Vue<span class="token punctuation">.</span><span class="token function">component</span><span class="token punctuation">(</span><span class="token string">'v-icon'</span><span class="token punctuation">,</span> Icon<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 或局部注册（在组件文件中）</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token punctuation">{</span>  components<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token string">'v-icon'</span><span class="token punctuation">:</span> Icon  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.hangge.com/blog/cache/detail_2104.html" target="_blank" rel="noopener">http://www.hangge.com/blog/cache/detail_2104.html</a></p><p><a href="https://fontawesome.com/" target="_blank" rel="noopener">https://fontawesome.com/</a></p><p><a href="https://www.npmjs.com/package/@fortawesome/vue-fontawesome" target="_blank" rel="noopener">https://www.npmjs.com/package/@fortawesome/vue-fontawesome</a></p><p><a href="https://github.com/Justineo/vue-awesome/blob/master/README.zh_CN.md" target="_blank" rel="noopener">https://github.com/Justineo/vue-awesome/blob/master/README.zh_CN.md</a></p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FontAwesome </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Font Awesome使用</title>
      <link href="/2018/10/08/Font-Awesome%E4%BD%BF%E7%94%A8/"/>
      <url>/2018/10/08/Font-Awesome%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="Font-Awesome字体图标"><a href="#Font-Awesome字体图标" class="headerlink" title="Font Awesome字体图标"></a>Font Awesome字体图标</h1><h2 id="一，什么是字体图标"><a href="#一，什么是字体图标" class="headerlink" title="一，什么是字体图标"></a>一，什么是字体图标</h2><p>（1）现在比较流行使用字体图标，所谓字体图标其实就是一个包含许多图标的字体库。同我们常用的字体一样，这个也可以理解为一种特殊字体，只不过里面包含的都是图标。</p><p>（2）既然是字体，那么最方便的就是可以随意在代码中更改颜色和大小而不会失真。这样不需要因为要适配各种尺寸而制作多个图片，或者做多套颜色的图标用来标识不同状态。</p><p>（3）无论是按钮图标还是导航栏图标，也不管是网站开发还是移动应用开发，字体图标都能适用。</p><h2 id="二，Font-Awesome-图标字体库"><a href="#二，Font-Awesome-图标字体库" class="headerlink" title="二，Font Awesome 图标字体库"></a>二，Font Awesome 图标字体库</h2><p>Font Awesome</p><p> 是一套目前最受欢迎最全面的图标字体库。这套图标字体集几乎囊括了网页中可能用到的所有图标和社交网络图标、Web 应用程序图标和编辑器图标等等。</p><p>网站地址：<a href="http://fontawesome.io/" target="_blank" rel="noopener">官网地址</a>  <a href="https://github.com/FortAwesome/Font-Awesome" target="_blank" rel="noopener">GitHub地址</a></p><p>主要特色如下：</p><p>✓ 一种字体，包含1341个免费图标（截至5.3.1版本）；</p><p>✓ 纯 CSS 控制，能够轻松定义图标的颜色、大小、阴影以及任何 CSS 能够实现的效果；</p><p>✓ 无限缩放，svg矢量图标在任何尺寸下都一模一样；</p><p>✓ 免费使用，包括商业和非商业项目；</p><p>✓ 支持 Internet Explorer 7 浏览器；</p><p>✓ 简单，易用；</p><p><a href="http://fontawesome.io/icons/" target="_blank" rel="noopener">点击此处查看全部</a></p><h2 id="三，Font-Awesome的配置"><a href="#三，Font-Awesome的配置" class="headerlink" title="三，Font Awesome的配置"></a>三，Font Awesome的配置</h2><p>（1）首先将整个字体库文件夹<code>font-awesome</code>放到工程项目中。 </p><p>（2）在html页面的头部把 <code>font-awesome.min.css</code>引进来。</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>font-awesome/css/font-awesome.min.css<span class="token punctuation">"</span></span><span class="token punctuation">></span></span></code></pre><h2 id="四，Font-Awesome的使用样例"><a href="#四，Font-Awesome的使用样例" class="headerlink" title="四，Font Awesome的使用样例"></a>四，Font Awesome的使用样例</h2><p>在页面中的任何地方都可以使用 </p><i><p> 标签来使用Font Awesome字体图标。</p><p><strong>1，最简单的样例</strong></p><p>通过在class中使用</p><p>fa </p><p>前缀以及图标名字，可以显示出相应的图标（内联样式）</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-camera-retro<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span> fa-camera-retro</code></pre><p><strong>2，相对于内容大小，放大图标尺寸</strong></p><p>使用</p><p>fa-lg, fa-2x, fa-3x, fa-4x, fa-5x</p><p>样式可以让图标相对于内容，尺寸增大33%，变成2倍，3倍，4倍，5倍。</p><p>（注意：如果发现图标上下有被隐藏的情况，你可以通过适当增加line-height 来解决）</p><p><strong>3，固定宽度图标</strong><br>使用 fa-fw 可以固定图标宽度</p><p><strong>4，列表图标</strong><br>使用 fa-ul 和 fa-li 可以很方便地替换list列表默认图标</p><p><strong>5，有边框且漂浮的图标</strong><br>使用 fa-border 与 fa-pull-right 或者 fa-pull-left 组合使用，可以很方便地实现引用或文章图标。</p><p><strong>6，图标旋转动画</strong> </p><p>使用 fa-spin 可以让图标匀速旋转，使用 fa-pulse 可以让图标只按8个角度旋转。</p><p><strong>7，旋转、翻转图标</strong><br>使用 fa-rotate-* 和 fa-flip-* 可以分别实现图标的旋转和翻转。</p><p><strong>8，叠加图标</strong><br>要叠加多个图标，使用 fa-stack 设置容器。fa-stack-1x 表示正常大小的图标，fa-stack-2x 表示更大的图标。 fa-inverse 可以让图标反色。</p></i>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> icon </tag>
            
            <tag> FontAwesome </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js-object-basic-usage</title>
      <link href="/2018/10/06/js-object-basic-usage/"/>
      <url>/2018/10/06/js-object-basic-usage/</url>
      
        <content type="html"><![CDATA[<h2 id="6种基本数据类型"><a href="#6种基本数据类型" class="headerlink" title="6种基本数据类型"></a>6种基本数据类型</h2><p>null undefined string number boolean symobl</p><h2 id="5种falsy值"><a href="#5种falsy值" class="headerlink" title="5种falsy值"></a>5种falsy值</h2><p>null undefined 0 NaN ‘’(空字符串不能有空格)</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>是js的第七种数据类型，也是唯一的一种复杂类型。</p><p><strong>注意</strong></p><ul><li>js对象的键名都是字符串（es6之后还可以是symbol）</li><li>引号可以省略，省略后只能写标识符（是指只能包括字母、数字、下划线、美元符号，且不能是数字开头）</li><li>引号就算省略了，也还是字符串</li><li><code>Object.keys(obj)}</code>这个API可以正确查看对象的key</li></ul><h3 id="变量作为属性名–用"><a href="#变量作为属性名–用" class="headerlink" title="变量作为属性名–用[]"></a>变量作为属性名–用<code>[]</code></h3><ul><li>用 <code>xxx in object</code> 返回布尔值查看是否含有xxx属性</li><li><code>obj.xxx === undefined</code> 不是确定xxx是否是obj的属性</li></ul><h3 id="chrome中调试对象"><a href="#chrome中调试对象" class="headerlink" title="chrome中调试对象"></a>chrome中调试对象</h3><ul><li>查看自身属性+共有属性（原型）<code>console.dir(obj)</code></li></ul><h2 id="对象写属性"><a href="#对象写属性" class="headerlink" title="对象写属性"></a>对象写属性</h2><ul><li>直接赋值 <code>obj.name = &#39;xx&#39;</code> 这里name是字符串，可以改为 <code>obj[&#39;name&#39;] = &#39;xx&#39;</code></li><li>批量赋值 <code>Object.assign(obj,{age: 18,gender: &#39;man&#39;})</code></li></ul><h3 id="修改共有属性"><a href="#修改共有属性" class="headerlink" title="修改共有属性"></a>修改共有属性</h3><ul><li><p>生产环境中不能使用 <code>obj.__proto__.toString=&#39;xxx&#39;</code></p></li><li><p>准确的使用是在构造函数上修改 <code>Object.prototype.toString = &#39;xxx&#39;</code></p></li><li><p>修改隐藏属性（原型，这个在创建时修改）用 <code>Object.create()</code> </p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> common <span class="token operator">=</span> <span class="token punctuation">{</span>kind<span class="token punctuation">:</span> <span class="token string">'human'</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>common<span class="token punctuation">)</span>obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lei'</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>common<span class="token punctuation">)</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wang'</span></code></pre><p>总结： 要改就一开始改，别后来再改</p></li></ul><h2 id="内容总结"><a href="#内容总结" class="headerlink" title="内容总结"></a>内容总结</h2><ul><li>原型里包含共有属性</li></ul><h3 id="声明对象的两种写法"><a href="#声明对象的两种写法" class="headerlink" title="声明对象的两种写法"></a>声明对象的两种写法</h3><ol><li><p>字面量 </p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'liu'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span></code></pre></li><li><p>new 构造函数</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'liu'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li></ol><h3 id="删除对象的属性"><a href="#删除对象的属性" class="headerlink" title="删除对象的属性"></a>删除对象的属性</h3><p>使用 <code>delete</code>操作符 <code>delete obj.name</code>或<code>delete obj[&#39;name&#39;]</code></p><h3 id="查看对象的属性"><a href="#查看对象的属性" class="headerlink" title="查看对象的属性"></a>查看对象的属性</h3><ol><li><p>查看自身所有属性</p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre></li><li><p>查看自身 + 共有属性</p><pre class=" language-js"><code class="language-js">console<span class="token punctuation">.</span><span class="token function">dir</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span></code></pre></li><li><p>查看属性是自身的还是共有的</p><pre class=" language-js"><code class="language-js">obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span></code></pre></li></ol><h3 id="修改或增加对象的属性"><a href="#修改或增加对象的属性" class="headerlink" title="修改或增加对象的属性"></a>修改或增加对象的属性</h3><ul><li><p>直接赋值</p><pre class=" language-js"><code class="language-js">obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'xx'</span></code></pre><p>这里name是字符串，可以改为 <code>obj[&#39;name&#39;] = &#39;xx&#39;</code></p></li><li><p>批量赋值 </p><pre class=" language-js"><code class="language-js">Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>name<span class="token punctuation">:</span> <span class="token string">'z'</span><span class="token punctuation">,</span> age<span class="token punctuation">:</span> <span class="token number">18</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>修改共有属性</p><ul><li>生产环境中不能使用 <code>obj.__proto__.toString=&#39;xxx&#39;</code></li><li>准确的使用是在构造函数上修改 <code>Object.prototype.toString = &#39;xxx&#39;</code></li></ul></li><li><p>修改隐藏属性用 <code>Object.create()</code> </p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> common <span class="token operator">=</span> <span class="token punctuation">{</span>kind<span class="token punctuation">:</span> <span class="token string">'human'</span><span class="token punctuation">}</span><span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>common<span class="token punctuation">)</span>obj<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'lei'</span><span class="token keyword">let</span> obj2 <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>common<span class="token punctuation">)</span>obj2<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">'wang'</span></code></pre><p>  总结： 要改就一开始改，别后来再改</p></li></ul><h3 id="‘name’-in-obj-和-obj-hasOwnProperty-‘name’-区别"><a href="#‘name’-in-obj-和-obj-hasOwnProperty-‘name’-区别" class="headerlink" title="‘name’ in obj 和 obj.hasOwnProperty(‘name’)区别"></a>‘name’ in obj 和 obj.hasOwnProperty(‘name’)区别</h3><p>都是用来判断属性是否属于对象。</p><p>第一个有点问题是它判断的属性如果是对象继承的可枚举属性则也会返回<code>true</code>, 而 <code>hasOwnProperty</code>则只会返回自身的，不包含属于原型的属性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mac上github的clone项目提速</title>
      <link href="/2018/10/04/mac%E4%B8%8Agithub%E7%9A%84clone%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%80%9F/"/>
      <url>/2018/10/04/mac%E4%B8%8Agithub%E7%9A%84clone%E9%A1%B9%E7%9B%AE%E6%8F%90%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>平时自己上github，clone小点的项目速度的快慢对我来说影响不大（其实是之前没有国外的服务器，没试过命令行FQ），但是遇到大的项目需要等待很久，前些时买了服务器，也闲来无事折腾试试。 进入正题：</p><h2 id="方案一"><a href="#方案一" class="headerlink" title="方案一"></a>方案一</h2><p>通过修改hosts文件（亲测有效）</p><p>在<a href="https://www.ipaddress.com" target="_blank" rel="noopener">IP Lookup</a>工具中分别查询github的<code>github.com</code>和<code>github.global.ssl.fastly.net</code>域名的IP地址，</p><p> 打开的hosts（hosts文件位置：【Windows】<code>C:\Windows\System32\drivers\etc\host【</code>Mac】执行 <code>sudo vi /etc/hosts</code> ）文件中添加如下格式：</p><pre><code>192.30.253.112 github.com151.101.13.194 github.global.ssl.fastly.net</code></pre><p>最后执行<code>ipconfig /flushdns</code>命令，刷新 DNS 缓存。</p><p><strong>对比图</strong></p><p>修改前：</p><p><img src="/images/github%E6%8F%90%E9%80%9F-%E9%85%8D%E7%BD%AE%E5%89%8D.jpg" alt></p><p>修改后：</p><p><img src="/images/github%E6%8F%90%E9%80%9F-%E9%85%8D%E7%BD%AE%E5%90%8E.jpg" alt></p><h2 id="方案二"><a href="#方案二" class="headerlink" title="方案二"></a>方案二</h2><p>用<code>proxychains-ng</code>这个命令行FQ软件。(方法来自方应杭)</p><p><strong>安装</strong></p><pre><code> # 自己从github下载并编译 git clone https://github.com/rofl0r/proxychains-ng.git   cd proxychains-ng   //进入proxychains-ng目录 sudo ./configure               //使用root身份运行  sudo make  sudo make install sudo cp ./src/proxychains.conf /etc/proxychians.conf //配置文件复制到/etc目录下 # brew安装 brew install proxychains-ng</code></pre><p>安装完后有一个<code>proxychains4</code>的命令，配置<code>/etc/proxychians.conf</code>文件，找到<code>[ProxyList]</code>，然后加上<code>socks5     127.0.0.1 1080</code> 其中1080端口对应本地的端口号。</p><p><strong>使用</strong></p><p>默认方法： <code>proxychain4 curl -L google.com</code> ,即在命令前加上proxychains4</p><p>我的方法： </p><p>新建一个配置文件 </p><pre class=" language-bash"><code class="language-bash"> <span class="token comment" spellcheck="true"># 文件~/proxychains.conf</span> strict_chain quiet_mode proxy_dns  remote_dns_subnet 224 tcp_read_time_out 15000 tcp_connect_time_out 8000 <span class="token punctuation">[</span>ProxyList<span class="token punctuation">]</span> socks5     127.0.0.1 1080</code></pre><p>配置<del>/.zshrc（或</del>/.bashrc）用<code>alias</code></p><pre><code>alias pc=&#39;proxychains4 -f ~/proxychains.conf&#39;</code></pre><p>之后在使用就可以只用<code>pc</code>命令后面跟上你要FQ的命令即可。</p><p><strong>如果你是mac系统 那么需要关闭SIP（System Integrity Protection）</strong></p><p>macOS 10.11后，苹果加入SIP设置就会导致部分命令是执行不成功的，就包括使用socks的proxychains4。如果我们要解决这个问题，我们就要关掉SIP。</p><ul><li>重启Mac，按下Command+R直到出现Apple Logo。</li><li>选择实用工具-&gt;终端。</li><li>输入命令csrutil disable。出现类似于“成功禁用SIP”的意思就表示成功了。</li></ul><p>如果还要打开SIP，最后的步骤csrutil enable即可</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mac下如何安装Exuberant Ctags</title>
      <link href="/2018/09/28/Mac%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Exuberant-Ctags/"/>
      <url>/2018/09/28/Mac%E4%B8%8B%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85Exuberant-Ctags/</url>
      
        <content type="html"><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><pre class=" language-shell"><code class="language-shell">brew install ctags-exuberant</code></pre><p>安装完后，使用 which -a ctags，如果出现</p><pre class=" language-shell"><code class="language-shell">/usr/bin/ctags ==> original ctags/usr/local/bin/ctags ==> exuberant ctags</code></pre><p>则安装没出啥问题,但是此时系统用的是默认xcode里的<code>ctags</code>，而不是我们要使用的<br><code>exuberant ctags</code></p><p>打开~/根目录下的.profile，如果你也没发现有这个文件，没关系，创建一个！<br>然后在里面添加：export PATH=”/usr/local/bin:/usr/local/sbin:$PATH”<br>再到终端执行：source ~/.profile<br>然后再看看which ctags，如无意外，应该是/usr/local/bin/ctags</p><p>最后在.vimrc配置文件添加： let Tlist_Ctags_Cmd=”/usr/local/bin/ctags”</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim折腾记-2</title>
      <link href="/2018/09/28/vim%E6%8A%98%E8%85%BE%E8%AE%B0-2/"/>
      <url>/2018/09/28/vim%E6%8A%98%E8%85%BE%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h5 id="2-1快捷移动"><a href="#2-1快捷移动" class="headerlink" title="2.1快捷移动"></a>2.1快捷移动</h5><p>文件头：<code>gg</code><br>文件尾： <code>G</code></p><p>段移动：<code>^f</code>, <code>^b</code></p><p>行头：<code>0</code>, <code>g0</code><br>行尾： <code>$</code>, <code>g_</code></p><pre class=" language-vim"><code class="language-vim"><span class="token operator">&lt;</span><span class="token keyword">c</span><span class="token operator">-</span><span class="token keyword">f</span><span class="token operator">></span>   <span class="token comment" spellcheck="true">" 向下移动一页</span><span class="token operator">&lt;</span><span class="token keyword">c</span><span class="token operator">-</span><span class="token keyword">d</span><span class="token operator">></span>   <span class="token comment" spellcheck="true">" 向下移动半页</span><span class="token operator">&lt;</span><span class="token keyword">c</span><span class="token operator">-</span><span class="token keyword">b</span><span class="token operator">></span>   <span class="token comment" spellcheck="true">" 向上移动一页</span><span class="token operator">&lt;</span><span class="token keyword">c</span><span class="token operator">-</span><span class="token keyword">u</span><span class="token operator">></span>   <span class="token comment" spellcheck="true">" 向上移动半页</span></code></pre><h2 id="放置行"><a href="#放置行" class="headerlink" title="放置行"></a><strong>放置行</strong></h2><p>有时我们希望将指定的行放在屏幕顶端。先将光标放在指定的行上，然后输入z<enter>，这一行就会出现在屏幕的顶端了。我们还可以利用参数将指定的行置于屏幕顶端。例如命令8z<enter>就是将第八行置于屏幕顶端。这个命令将指定的行置于顶端，并将光标移动到本行第一个非空白字符处。如果要将指定行置于顶端，并将光标保持在一行的当前位置不变，可以使用zt命令。</enter></enter></p><p>如果要将指定的行放在屏幕底部，可以使用命令z-或是zb。所不同的是，前者将光标放在这一行中第一个没有空白符的字符处，而后者是保持光标的位置不变。</p><p>命令zz或是z.可以将指定的行放在屏幕的中部。这两个命令的不同就是，前者保持光标的位置不变，而后者是将光标置于第一个非空白的字符处。</p><p>在normal模式下 直接输入H M L 代表 把光标放在 屏顶部 屏中部 屏底部。</p><p>其中：<esc>代表Escape键；<cr>代表Enter键；而功能键则用<f10>表示。首先进入命令行模式，然后执行新建标签页的:tabnew命令，最后返回常规模式。</f10></cr></esc></p><p>同理：对于组合键，可以用<c-esc>代表Ctrl-Esc；使用<s-f1>表示Shift-F1。对于Mac用户，可以使用<d>代表Command键。</d></s-f1></c-esc></p><p>注意：Alt键可以使用<m-key>或<a-key>来表示。</a-key></m-key></p><p>关于键盘符号的详细说明，请使用:h key-notation命令查看帮助信息。</p><table><thead><tr><th>按键</th><th>描述</th><th>助记</th></tr></thead><tbody><tr><td><code>0</code></td><td>跳到行首，可以理解为无穷大的<code>h</code></td><td></td></tr><tr><td><code>^</code></td><td>跳到行首开始的第一个非空白字符</td><td></td></tr><tr><td><code>$</code></td><td>跳到行尾，可以理解为无穷大的<code>l</code></td><td></td></tr><tr><td><code>gg</code></td><td>跳到首行，可以理解为无穷大的<code>k</code></td><td></td></tr><tr><td><code>G</code></td><td>跳到末行，可以理解为无穷大的<code>j</code></td><td></td></tr><tr><td><code>w</code></td><td>跳到下一个词首</td><td>word</td></tr><tr><td><code>b</code></td><td>跳到上一个词首</td><td>back-word</td></tr><tr><td><code>e</code></td><td>跳到下一个词尾</td><td>end</td></tr><tr><td><code>ge</code></td><td>跳到上一个词尾</td><td></td></tr></tbody></table><h3 id="操作命令"><a href="#操作命令" class="headerlink" title="操作命令"></a>操作命令</h3><p>编辑文档的过程，实际上就是不断操作特定文本的过程：删除、修改、复制，等等。 Vim 下的操作命令（Operator Commands）即特指一系列针对特定文本的操作。 常用的操作命令包括：</p><table><thead><tr><th>按键</th><th>描述</th><th>助记</th></tr></thead><tbody><tr><td><code>c</code></td><td>删除，并进入插入模式</td><td>change</td></tr><tr><td><code>d</code></td><td>删除</td><td>delete</td></tr><tr><td><code>y</code></td><td>复制</td><td>yank</td></tr><tr><td><code>gu</code></td><td>变为小写字母</td><td></td></tr><tr><td><code>gU</code></td><td>变为大写字母</td><td></td></tr><tr><td><code>g~</code></td><td>颠倒字母的大小写</td><td></td></tr><tr><td><code>&gt;</code></td><td>右缩进</td><td></td></tr><tr><td><code>&lt;</code></td><td>左缩进</td><td></td></tr><tr><td><code>=</code></td><td>自动缩进</td><td></td></tr></tbody></table><p><strong>需要注意的是，一个操作命令只会对紧随其后的一个移动命令有效。</strong></p><p>Normal 模式下“一击即中”的常用命令则包括：</p><table><thead><tr><th>按键</th><th>描述</th><th>助记</th></tr></thead><tbody><tr><td><code>p</code></td><td>粘贴于当前光标之后</td><td>paste/put</td></tr><tr><td><code>P</code></td><td>粘贴于当前光标之前</td><td>Paste/Put</td></tr><tr><td><code>x</code></td><td>删除当前字符，相当于 <code>dl</code></td><td></td></tr><tr><td><code>s</code></td><td>删除当前字符并插入，相当于 <code>cl</code></td><td></td></tr><tr><td><code>C</code></td><td>删除至行尾并插入，相当于 <code>c$</code></td><td></td></tr><tr><td><code>D</code></td><td>删除至行尾</td><td></td></tr><tr><td><code>S</code></td><td>从当前行首个非空字符删除至行尾并插入，相当于 <code>^C</code></td><td></td></tr><tr><td><code>u</code></td><td>撤销上一次修改</td><td>undo</td></tr><tr><td><code>&lt;Ctrl-r&gt;</code></td><td>重做上一次修改，<code>u</code> 的逆过程</td><td>redo</td></tr><tr><td><code>.</code></td><td>在当前光标处重复上一次修改</td><td></td></tr></tbody></table><p><strong>取消查找的高亮</strong>: 输入 <code>:nohls</code> 即可</p><pre class=" language-vim"><code class="language-vim">全文替换，也可以写成 <span class="token punctuation">:</span><span class="token operator">%</span>s<span class="token operator">/</span>word1<span class="token operator">/</span>word2<span class="token operator">/</span>g<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">,</span>$s<span class="token operator">/</span>word1<span class="token operator">/</span>word2<span class="token operator">/</span>gc    <span class="token comment" spellcheck="true">" 全文替换，并出现确认提示</span></code></pre><pre class=" language-vim"><code class="language-vim">dd          <span class="token comment" spellcheck="true">" 删除当前行</span>ndd         <span class="token comment" spellcheck="true">" 向下删除 n 行</span>d1G <span class="token operator">/</span> dgg   <span class="token comment" spellcheck="true">" 删除第一行到当前行的数据</span>dG          <span class="token comment" spellcheck="true">" 删除当前行到最后一行的数据</span><span class="token keyword">d</span>$          <span class="token comment" spellcheck="true">" 删除当前字符到行尾</span>d0          <span class="token comment" spellcheck="true">" 从行首删除到当前字符</span>yy          <span class="token comment" spellcheck="true">" 复制当前行</span>nyy         <span class="token comment" spellcheck="true">" 从当前行开始复制 n 行</span>y1G <span class="token operator">/</span> ygg   <span class="token comment" spellcheck="true">" 从第一行复制到当前行</span>yG          <span class="token comment" spellcheck="true">" 从当前行复制到最后一行</span>y0          <span class="token comment" spellcheck="true">" 从行首复制到当前字符</span><span class="token keyword">y</span>$          <span class="token comment" spellcheck="true">" 从当前字符复制到行尾</span><span class="token keyword">p</span><span class="token punctuation">,</span> <span class="token keyword">P</span>        <span class="token comment" spellcheck="true">" 黏贴，p 黏贴到光标下一行，P 黏贴到光标上一行</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端如何优雅的使用字体(font-family)</title>
      <link href="/2018/09/27/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93-font-family/"/>
      <url>/2018/09/27/%E5%89%8D%E7%AB%AF%E5%A6%82%E4%BD%95%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8%E5%AD%97%E4%BD%93-font-family/</url>
      
        <content type="html"><![CDATA[<h2 id="先看看大厂是如何做的-（截至2016-07）"><a href="#先看看大厂是如何做的-（截至2016-07）" class="headerlink" title="先看看大厂是如何做的 （截至2016.07）"></a>先看看大厂是如何做的 （截至2016.07）</h2><ol><li>小米</li></ol><pre class=" language-css"><code class="language-css"><span class="token property">font</span><span class="token punctuation">:</span> <span class="token number">14</span>px/<span class="token number">1.5</span> <span class="token string">"Helvetica Neue"</span>,Helvetica,Arial,<span class="token string">"Microsoft Yahei"</span>,<span class="token string">"Hiragino Sans GB"</span>,<span class="token string">"Heiti SC"</span>,<span class="token string">"WenQuanYi Micro Hei"</span>,sans-serif<span class="token punctuation">;</span></code></pre><p>小米公司优先使用Helvetica Neue这款字体以保证最新版本Mac用户的最佳体验，选择了Arial作为Win下默认英文字体及Mac的替代英文字体；中文字体方面首选了微软雅黑，然后选择了冬青黑体及黑体-简作为Mac上的替代方案；最后使用文泉驿微米黑兼顾了Linux系统。</p><ol start="2"><li>淘宝</li></ol><pre class=" language-css"><code class="language-css"><span class="token property">font</span><span class="token punctuation">:</span> <span class="token number">12</span>px/<span class="token number">1.5</span> tahoma,arial,<span class="token string">'Hiragino Sans GB'</span>,<span class="token string">'\5b8b\4f53'</span>,sans-serif<span class="token punctuation">;</span></code></pre><p>代码中可以看出淘宝使用了Tahoma、Arial作为首选英文字体，中文字体首选了冬青黑体，由于Win下没有预装该款字体，所以显示出了后面的宋体（5b8b4f53为汉字宋体用 unicode 表示的写法，不用SimSun是因为 Firefox 的某些版本和 Opera 不支持 SimSun的写法）</p><ol start="3"><li>简书</li></ol><pre class=" language-css"><code class="language-css"><span class="token property">font-family</span><span class="token punctuation">:</span> <span class="token string">"lucida grande"</span>, <span class="token string">"lucida sans unicode"</span>, lucida, helvetica, <span class="token string">"Hiragino Sans GB"</span>, <span class="token string">"Microsoft YaHei"</span>, <span class="token string">"WenQuanYi Micro Hei"</span>, sans-serif<span class="token punctuation">;</span></code></pre><p>自认为简书的阅读体验很棒，我们看看简书所用的字体，简书优先选择了lucida家族的系列字体作为英文字体，该系列字体在Mac和Win上都是预装的，并且有着不俗的表现；中文字体方面将冬青黑体作为最优先使用的字体，同样考虑了Linux系统。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> Font-family </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webpack学习byjrg</title>
      <link href="/2018/09/26/webpack%E5%AD%A6%E4%B9%A0byjrg/"/>
      <url>/2018/09/26/webpack%E5%AD%A6%E4%B9%A0byjrg/</url>
      
        <content type="html"><![CDATA[<h1 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h1><p>我学新东西的套路就是：<br>「copy - run - modify」<br>「抄 - 运行 - 修改」</p><ol><li>抄文档给的例子</li><li>在自己这里运行成功</li><li>改一下，看还能不能运行成功</li></ol><p>我们学 Webpack 也遵循同样的套路。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>我们要使用 npm 来安装 webpack。</p><ol><li><p>为了让你更了解 npm，我们要做两件事（可不做）</p><ol><li>运行 <code>npm config set loglevel http</code>，让你知道 npm 发的每一个请求</li><li>运行 <code>npm config set progress false</code>，关闭那个进度条</li></ol></li><li><p>为了让你的安装速度变快，运行</p></li></ol><pre><code>   npm config set registry https://registry.npm.taobao.org/</code></pre><ol><li>这会让你在运行 npm adduser 的时候出问题，想要恢复成原样，只需要 <code>npm config delete registry</code> 即可</li></ol><ol start="3"><li>现在，使用</li></ol><pre><code>   npm i -g webpack</code></pre><p>   ，正式安装 webpack</p><ol><li>如果报错说有权限问题，就是用 <code>sudo npm i -g webpack</code></li><li>Windows 里没有 sudo，那么你只能「以管理员身份运行」Git Bash，然后再运行命令</li></ol><ol start="4"><li><p>验证安装成功</p><p>运行</p></li></ol><pre><code>   webpack --help</code></pre><p>   如果看到类似下面的信息，就说明安装成功</p><pre><code>   webpack 1.14.0   Usage: https://webpack.github.io/docs/cli.html   ...   ...   --display-cached-assets   --display-reasons, --verbose, -v</code></pre><h1 id="ES-Modules"><a href="#ES-Modules" class="headerlink" title="ES Modules"></a>ES Modules</h1><p>终于安装好了，可以开始使用 Webpack 了吗？</p><p>不行，我们有一个重要的知识需要学习一下，那就是 ES 模块，也就是 import 和 export 两个关键字。</p><p>请现到 MDN 上了解一下它们的用法：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="noopener">import 用法</a></p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="noopener">export 用法</a></p><p>如果你看晕了，没关系，你只要看两个页面的最前面一段就行了。后面我们会用 「copy - run - modify」 套路来学习它们。</p><h1 id="Webpack-1"><a href="#Webpack-1" class="headerlink" title="Webpack"></a>Webpack</h1><h2 id="copy：去-Webpack-的官网上找个例子来玩玩"><a href="#copy：去-Webpack-的官网上找个例子来玩玩" class="headerlink" title="copy：去 Webpack 的官网上找个例子来玩玩"></a>copy：去 Webpack 的官网上找个例子来玩玩</h2><p><a href="https://webpack.js.org/" target="_blank" rel="noopener">https://webpack.js.org/</a></p><p>往下滚，看到例子</p><h2 id="run：把例子弄到本地"><a href="#run：把例子弄到本地" class="headerlink" title="run：把例子弄到本地"></a>run：把例子弄到本地</h2><ol><li><p>随意建个目录，比如 webpack-demo</p></li><li><p>进入目录后，将官网的例子弄到本地，结果如下：</p><pre><code>.├── app.js├── bar.js├── page.html└── webpack.config.js</code></pre></li><li><p>按照官网说的，运行</p></li></ol><pre><code>   webpack</code></pre><p>   ，看到如下结果：</p><pre><code>   Hash: a5d289a022d184d8fbff   Version: webpack 1.14.0   Time: 36ms       Asset     Size  Chunks             Chunk Names   bundle.js  1.42 kB       0  [emitted]  main      [0] ./app.js 33 bytes {0} [built]</code></pre><ol start="4"><li><p>打开 page.html，F12 打开控制台，居然报错了！！！</p><pre><code>Uncaught SyntaxError: Unexpected token import</code></pre><p>不靠谱的官网</p></li><li><p>然后只能 copy</p></li></ol><p>   阮一峰的教程</p><p>   咯，把 webpack.config.js 改成这样</p><pre><code>   module.exports = {     entry: &#39;./app.js&#39;,     output: {       filename: &#39;bundle.js&#39;     },     module: {       loaders:[         {           test: /\.js[x]?$/,           exclude: /node_modules/,           loader: &#39;babel-loader?presets[]=es2015&amp;presets[]=react&#39;         },       ]     }   }</code></pre><ol start="6"><li>再次运行</li></ol><pre><code>   webpack</code></pre><p>   ，又出错：</p><pre><code>   ERROR in Entry module not found: Error: Cannot resolve module &#39;babel-loader&#39; in /tmp/webpack-demo</code></pre><p>   是阮的问题吗？不是，他的教程里说了要安装一些 npm 包才能成功。</p><p>   上面的提示说没有 ‘babel-loader’ ，我们试着安装一下：</p><pre><code>   npm i babel-loader</code></pre><p>   再次运行</p><pre><code>   webpack</code></pre><p>   ，它说需要安装 ‘babel-core’，跟上次的提示不一样了，看来只要我们一直安装下去就行了</p><pre><code>   npm i babel-core</code></pre><p>   再运行</p><pre><code>   webpack</code></pre><p>   ，提示变了：</p><pre><code>   Module build failed: Error: Couldn&#39;t find preset &quot;es2015&quot; relative to directory &quot;/tmp/webpack-demo&quot;</code></pre><p>   这次需要安装的是</p><pre><code>   babel-preset-es2015</code></pre><p>   （不要问我为什么它不提示完整的名字）</p><pre><code>   npm i babel-preset-es2015   然后运行 webpack，看报错，知道需要安装 babel-preset-react   npm i babel-preset-react   然后运行 webpack，终于成功了……   Hash: 4950c10e0d1d81a2a8f1   Version: webpack 1.14.0   Time: 475ms       Asset     Size  Chunks             Chunk Names   bundle.js  1.83 kB       0  [emitted]  main       + 2 hidden modules</code></pre><ol start="7"><li>用浏览器打开 page.html，F12 打开控制台，终于没有报错了！</li></ol><h2 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h2><p>虽然没有报错，但是什么功能也没有啊！摔！再次吐槽 Webpack 官网。</p><p>我们来改一下 bar.js 吧：</p><pre><code>export default function bar() {  alert(&#39;Hello Webpack!&#39;)}</code></pre><p>重新运行 webpack，然后刷新 page.html。</p><p>如果你看到浏览器弹框说「Hello Webpack」，那么你就学会使用 Webpack 了。</p><h1 id="致饥人谷学员"><a href="#致饥人谷学员" class="headerlink" title="致饥人谷学员"></a>致饥人谷学员</h1><p>你需要看懂这篇教程，并且运行成功。</p><p>然后新建一个 GitHub 项目，将代码上传到里面。上传成功后，将项目主页的链接放在本帖的评论区中，谢谢！</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><p>你需要在项目的根目录添加 .gitignore 文件，并且在里面加上一行 <code>node_modules</code>，以防止你把这个目录上传到 GitHub 上。你在新建项目的时候选择 Node，也可以达到同样目的。</p><p>但是缺点就是我无法使用你安装的 npm 包，所以你需要把你安装的包写在一个地方，比如 README 里：</p><pre><code>npm i babel-loader babel-core babel-preset-es2015 babel-preset-react</code></pre><p>当然你用 package.json 来记录就更好了</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> webpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sublimeText设置详解</title>
      <link href="/2018/09/26/sublimeText%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2018/09/26/sublimeText%E8%AE%BE%E7%BD%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<pre><code>{    // 设置主题文件    “color_scheme”: “Packages/User/SublimeLinter/Flatland Monokai (SL).tmTheme”,    “theme”: “Flatland Dark.sublime-theme”,    // 设置字体和大小    &quot;font_face&quot;: &quot;courier new&quot;,    &quot;font_size&quot;: 13,    // 字体选项：no_bold不显示粗体字，no_italic不显示斜体字，no_antialias和no_antialias关闭反锯齿    // subpixel_antialias和no_round是OS X系统独有的    “font_options”: [],    // 在文字上双击会全选当前的内容，如果里面出现以下字符，就会被截断    “word_separators”: “./\\()\”‘-:,.;&lt;&gt;~!@#$%^&amp;*|+=[]{}`~?”,    // 是否显示行号    “line_numbers”: true,    // 是否显示行号边栏    “gutter”: true,    // 行号边栏和文字的间距    “margin”: 4,    // 是否显示代码折叠按钮    “fold_buttons”: true,    // 不管鼠标在不在行号边栏，代码折叠按钮一直显示    “fade_fold_buttons”: true,    //列显示垂直标尺，在中括号里填入数字，宽度按字符计算    “rulers”: [],    // 是否打开拼写检查    “spell_check”: false,    // Tab键制表符宽度    “tab_size”: 4,    // 设为true时，缩进和遇到Tab键时使用空格替代    “translate_tabs_to_spaces”: false,    // 设置行间距，看起来不那么”挤“    &quot;line_padding_bottom&quot;: 1,     &quot;line_padding_top&quot;: 1,    // 否则作用于单个空格    “use_tab_stops”: true,    “detect_indentation”: true,    // 按回车时，自动与制表位对齐    “auto_indent”: true,    //针对C语言的    “smart_indent”: false,    // 需要启用auto_indent，第一次打开括号缩进时插入空格？（没测试出来效果…）    “indent_to_bracket”: true,    // 显示对齐的白线是否根据回车、tab等操作自动填补    “trim_automatic_white_space”: true,    // 是否自动换行，如果选auto，需要加双引号    “word_wrap”: false,    // 设置窗口内文字区域的宽度    “wrap_width”: 0,    // 防止被缩进到同一级的字换行    “indent_subsequent_lines”: true,    // 如果没有定义过，则文件居中显示（比如新建的文件）    “draw_centered”: false,    // 自动匹配引号，括号等    “auto_match_enabled”: true,    // 拼写检查的单词列表路径    “dictionary”: “Packages/Language – English/en_US.dic”,    // 代码地图的可视区域部分是否加上边框，边框的颜色可在配色方案上加入minimapBorder键    “draw_minimap_border”: false,    // 突出显示当前光标所在的行    “highlight_line”: false,    // 设置光标闪动方式    “caret_style”: “smooth”,    // 是否特殊显示当前光标所在的括号、代码头尾闭合标记    “match_brackets”: true,    // 设为false时，只有光标在括号或头尾闭合标记的两端时，match_brackets才生效    “match_brackets_content”: true,    // 是否突出显示圆括号，match_brackets为true生效    “match_brackets_square”: false,    // 是否突出显示大括号，match_brackets为true生效    “match_brackets_braces”: false,    // 是否突出显示尖括号，match_brackets为true生效    “match_brackets_angle”: false,    // html和xml下突出显示光标所在标签的两端，影响HTML、XML、CSS等    “match_tags”: true,    // 全文突出显示和当前选中字符相同的字符    “match_selection”: true,    // 设置为false时，滚动到文本的最下方时，没有缓冲区    “scroll_past_end”: true,    // 控制向上或向下到第一行或最后一行时发生什么    “move_to_limit_on_up_down”: false,    // 按space或tab时，实际会产生白色的点（一个空格一个点）或白色的横线（tab_size设置的制表符的宽度），选中状态下才能看到    // 设置为none时，什么情况下都不显示这些点和线    // 设置为selection时，只显示选中状态下的点和线    // 设置为all时，则一直显示    “draw_white_space”: “selection”,    // 制表位的对齐白线是否显示，颜色可在主题文件里设置（guide，activeGuide，stackGuide）    “draw_indent_guides”: true,    // 制表位的对齐白线，draw_normal为一直显示，draw_active为只显示当前光标所在的代码控制域    “indent_guide_options”: [&quot;draw_normal&quot;],    // 为true时，保存文件时会删除每行结束后多余的空格    “trim_trailing_white_space_on_save”: false,    // 为true时，保存文件时光标会在文件的最后向下换一行    “ensure_newline_at_eof_on_save”: false,    // 切换到其它文件标签或点击其它非本软件区域，文件自动保存    “save_on_focus_lost”: false,    // 编码时不能自动检测编码时，将自动检测ASCII, UTF-8 和 UTF-16    “fallback_encoding”: “Western (Windows 1252)”,    // 默认编码格式    “default_encoding”: “UTF-8″,    // 包含空字节的文件被打开默认为十六进制    “enable_hexadecimal_encoding”: true,    // 每一行结束的时候用什么字符做终止符    “default_line_ending”: “system”,    // 设置为enabled时，在一个字符串间按Tab将插入一个制表符    // 设置为true时，按Tab会根据前后环境进行代码自动匹配填补    “tab_completion”: true,    // 代码提示    “auto_complete”: true,    // 代码提示的大小限制    “auto_complete_size_limit”: 4194304,    // 代码提示延迟显示    “auto_complete_delay”: 50,    // 代码提示的控制范围    “auto_complete_selector”: “source – comment”,    // 触发代码提示的其他情况    “auto_complete_triggers”: [ {&quot;selector&quot;: &quot;text.html&quot;, &quot;characters&quot;: &quot;&lt;&quot;} ],    // 设为false时，选择提示的代码按回车或点击可以输出出来，但选择true时不会输出而是直接换行    “auto_complete_commit_on_tab”: false,    // 设置为false，使用Shift + tab总是插入制表符    “shift_tab_unindent”: true,    // 选中的文本按Ctrl + f时，自动复制到查找面板的文本框里    “find_selected_text”: true,    // 滚动的速度    “scroll_speed”: 1.0,    // 左边边栏文件夹动画    “tree_animation_enabled”: true,    // 标签页的关闭按钮    “show_tab_close_buttons”: true,    // 针对OS X    “use_simple_full_screen”: false,    // 水平垂直滚动条：system和disabled为默认显示方式，enabled为自动隐藏显示    “overlay_scroll_bars”: “system”,    // 热推出功能！退出时不会提示是否保存文件，而是直接退出    // 下次打开软件时，文件保持退出前的状态，没来得及保存的内容都在，但并没有真实的写在原文件里    “hot_exit”: true,    // 软件使用最后的设定打开文件，hot_exit为true时没有效果    “remember_open_files”: true,    // 针对OS X    “open_files_in_new_window”: true,    // 针对OS X    “close_windows_when_empty”: true,    // 哪些文件会被显示到边栏上    “folder_exclude_patterns”: [&quot;.svn&quot;, &quot;.git&quot;, &quot;.hg&quot;, &quot;CVS&quot;],    “file_exclude_patterns”: [&quot;*.pyc&quot;, &quot;*.pyo&quot;, &quot;*.exe&quot;, &quot;*.dll&quot;, &quot;*.obj&quot;,&quot;*.o&quot;, &quot;*.a&quot;, &quot;*.lib&quot;, &quot;*.so&quot;, &quot;*.dylib&quot;, &quot;*.ncb&quot;, &quot;*.sdf&quot;, &quot;*.suo&quot;, &quot;*.pdb&quot;, &quot;*.idb&quot;, &quot;.DS_Store&quot;, &quot;*.class&quot;, &quot;*.psd&quot;, &quot;*.db&quot;],    // Goto Anything or Find in Files    “binary_file_patterns”: [&quot;*.jpg&quot;, &quot;*.jpeg&quot;, &quot;*.png&quot;, &quot;*.gif&quot;, &quot;*.ttf&quot;, &quot;*.tga&quot;, &quot;*.dds&quot;, &quot;*.ico&quot;, &quot;*.eot&quot;, &quot;*.pdf&quot;, &quot;*.swf&quot;, &quot;*.jar&quot;, &quot;*.zip&quot;],    // 删除你想要忽略的插件，需要重启, 去掉Vinage开启vim模式    “ignored_packages”: [&quot;Vintage&quot;]}</code></pre><pre><code>// Data\Packages\Theme – Default\Default.sublime-theme控制软件的主题 ``“theme”: “Default.sublime-theme”,</code></pre><pre><code> ``// 滚动的速度 ``“scroll_speed”: ``1.0``, ``// 左边边栏文件夹动画 ``“tree_animation_enabled”: true, ``// 标签页的关闭按钮 ``“show_tab_close_buttons”: true,// Valid values are “system”, “enabled” and “disabled” ``// 水平垂直滚动条：system和disabled为默认显示方式，enabled为自动隐藏显示 ``“overlay_scroll_bars”: “system”,</code></pre><pre><code> ``}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sublime </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>css深入浅出</title>
      <link href="/2018/09/26/css%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/"/>
      <url>/2018/09/26/css%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-深入浅出"><a href="#CSS-深入浅出" class="headerlink" title="CSS 深入浅出"></a>CSS 深入浅出</h2><ol><li>永远不要定父级的高度。用padding撑</li><li>outline 是不占位的。</li></ol><h3 id="CSS的宽度和高度"><a href="#CSS的宽度和高度" class="headerlink" title="CSS的宽度和高度"></a>CSS的宽度和高度</h3><p><strong>文档流（Normal Flow） 普通流 常规流</strong><br>    内联元素的宽高<br>    块级元素的宽高<br>    水平居中<br>    垂直居中<br>    文字溢出省略（多行）<br><strong>盒模型</strong><br>    一比一的 div<br>    outline<br>    border 调试大法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>如果div中只有内联元素。那么它的高度是内联元素的行高。（字体默认行高 是字体设计者确定的）</li><li>&amp;nbsp； –no break space; 不换行的空格</li><li>text-align: justify ? 在多行中 行首和行尾对齐</li><li>html解析代码时会把内联元素之内的显示 之外的不显示</li><li>inline元素之间用空格或回车 则他们之间会显示间隙</li><li>css的调试是加border</li><li>word-break: break-all; 只要到行尾就断开</li><li>div的宽度不是由文字决定的</li><li>margin能不能使父元素变高取决于margin有没有被东西包着(如： border、padding、overflow：hidden)</li><li>margin合并</li><li>overflow：hidden； 不到万不得已，不要用；</li></ol><p>div的高度是由它内部的文档流中元素的总和决定的。<br><strong>文档流</strong>：其实是叫普通流（normal-flow）元素按照其在HTML中的位置顺序决定排布过程。<br>内联元素从左到右 ，块级元素从上到下,只要不是float和绝对定位的，都在普通流中。</p><p>脱离文档流：就是计算高度不叫我。<br>相对定位： 计算高度计算他。<br>内联元素的margin和padding会影响父级的宽度，但不会影响高度。<br>1个1：1的div用 ： padding-top: 100%;</p><p>中文字的对齐：<br><img src="media/15378384261294/15378408191332.jpg" alt></p><p>清楚浮动<br><img src="media/15378384261294/15378410630358.jpg" alt></p><pre><code>### 堆叠上下文学会 调试（实验） text-indent/ margin: -5px;![](media/15378384261294/15378500552333.jpg)</code></pre><h3 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h3><p>sprites 精灵图</p><ol><li>把ps中的单个图层导出为PNG。</li><li>如果是PNG，扣图是用选择工具选中然后右键copy；</li><li>html 实体编号entity；</li></ol><h3 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h3><p>用 @media，一个条件是一个括号</p><pre class=" language-css"><code class="language-css"><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 320px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/* 0-320px */</span>    <span class="token number">...</span><span class="token punctuation">}</span><span class="token atrule"><span class="token rule">@media</span> <span class="token punctuation">(</span><span class="token property">min-width</span><span class="token punctuation">:</span> 321px<span class="token punctuation">)</span> and <span class="token punctuation">(</span><span class="token property">max-width</span><span class="token punctuation">:</span> 375px<span class="token punctuation">)</span></span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">/*321px - 275px*/</span>    <span class="token number">...</span><span class="token punctuation">}</span></code></pre><p>@media 可以作用到css文件上 如： <code>&lt;link rel=&quot;stylesheet&quot; media=&quot;only screen and (max-width:320px)&quot;&gt;</code></p><p>mobile first 移动优先</p><p>classList.toggle(‘active’) 原生的toggle class</p><p>980px 是业界 移动端模拟pc的大小。</p><h3 id="移动端滑动"><a href="#移动端滑动" class="headerlink" title="移动端滑动"></a>移动端滑动</h3><p><a href="https://github.com/mattbryson/TouchSwipe-Jquery-Plugin" target="_blank" rel="noopener">jquery模拟的</a>，vue 也有对应的。<br>移动端是没有滚动条的，他有的是位置指示器。</p><h3 id="flex布局"><a href="#flex布局" class="headerlink" title="flex布局"></a>flex布局</h3><p>flex-direction: 可以确定主轴的方向</p><h3 id="布局套路"><a href="#布局套路" class="headerlink" title="布局套路"></a>布局套路</h3><p><strong>用作布局的div只用来用作布局，不要加内容等，给宽高给到最里面让他去撑</strong></p><ol><li>兼容ie8 用Float布局 定宽</li><li>用Flex布局</li></ol><p>注意： 不写死width和height、尽量用高级语法： calc、flex 、如果是ie8 则写死</p><p>布局1： Float： 儿子用float 父级加clear: both; </p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.clearfix</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token comment" spellcheck="true">/* 兼容ie8 */</span><span class="token selector"><span class="token class">.clearfix</span></span><span class="token punctuation">{</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">/* 可以兼容ie6 */</span></code></pre><p>布局2：  给父级加<code>display: flex</code><br>给一个没有宽度的div加一个 margin的 负值，那么它会被撑开。 如果最后这里在做移动端的时候出现滚动条则用 <code>overflow: hidden</code> 去除。</p><h3 id="负margin-用一个xxx包着做。"><a href="#负margin-用一个xxx包着做。" class="headerlink" title="负margin 用一个xxx包着做。"></a>负margin 用一个xxx包着做。</h3><h3 id="用shift-tab实现-负缩进"><a href="#用shift-tab实现-负缩进" class="headerlink" title="用shift tab实现 负缩进"></a>用shift tab实现 负缩进</h3><h3 id="不用img标签-解决img变形"><a href="#不用img标签-解决img变形" class="headerlink" title="不用img标签 解决img变形"></a>不用img标签 解决img变形</h3><h3 id="用padding去和兄弟元素的高度对齐。"><a href="#用padding去和兄弟元素的高度对齐。" class="headerlink" title="用padding去和兄弟元素的高度对齐。"></a>用padding去和兄弟元素的高度对齐。</h3><h2 id="动态REM-手机专用"><a href="#动态REM-手机专用" class="headerlink" title="动态REM  - 手机专用"></a>动态REM  - 手机专用</h2><p>宽度单位： </p><ol><li>px：像素 </li><li>em：一个M(它的宽高一致所有说是一个M)的宽度（一个汉字的宽度）</li><li>rem: root em 根元素的font-size的大小</li><li>vh/vw: viewport height</li></ol><p><strong>12px法则</strong><br>网页的默认font-size:16px;<br>chrome可以设置最小是12px 小于12px的 显示还是12px</p><ol><li>百分比布局</li><li>整比例缩放</li></ol><p><strong>一切单位以宽度 ， 就能保证完美还原设计</strong></p><p><strong>如何引入rem的使用呢？</strong><br>1rem = html font-size = page width;</p><p>切记html的font-size 不要太小，可以和其他单位混用。</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vim折腾记-1</title>
      <link href="/2018/09/17/vim%E6%8A%98%E8%85%BE%E8%AE%B0-1/"/>
      <url>/2018/09/17/vim%E6%8A%98%E8%85%BE%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<p>学习 vim 并且其会成为你最后一个使用的文本编辑器。没有比这个更好的文本编辑器了，非常地难学，但是却不可思议地好用。</p><a id="more"></a><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><p><strong>移动:</strong><br>hjkl: 分别对应左下上右</p><p>** 切换操作模式**<br>要始终记得按<code>esc</code>来退回Normal模式,已下要说的前提都是在Normal模式开始。</p><p>按esc键 → Normal模式，在VIM的Normal模式下，所有的键就是功能键了。</p><p>i → insrt模式，相当于其他编辑器正常的输入模式。</p><p>: → 后面接命令，进入vim的命令模式。</p><p>:! → 调用外部的命令行。</p><p>→ 注: 凡是<code>:</code>开始的命令你需要输入<code>&lt;enter&gt;</code>回车来结束（执行）</p><h2 id="需要记忆的知识点"><a href="#需要记忆的知识点" class="headerlink" title="需要记忆的知识点"></a>需要记忆的知识点</h2><p><strong>插入</strong></p><p>a → 光标后插入<br>o → 当前行后插入一行<br>O → 当前行前插入一行<br>cw → 替换从光标位置到单词结尾的字符</p><p><strong>位移动</strong></p><p>0 → 到行头<br>^ → 和0差不多，到本行第一个不是blank字符的位置（blank: 空格、tab、换行、回车等看不见的字符）<br>$ → 到行尾<br>g下换线 → 到本行最后一个不是blank字符的位置</p><p><strong>单词间移动</strong><br>w → 到下一个单词的开头。<br>e → 到下一个单词的结尾。</p><p><strong>块内移动</strong><br>% : 匹配括号移动，包括 (, {,[</p><ul><li>和 #:  全局匹配光标当前所在的单词，移动光标到下一个（或上一个）匹配单词（*是下一个，#是上一个)</li></ul><hr><p><strong>行移动</strong><br>NG → 到第 N 行<br>gg → 到第一行<br>G → 到最后一行</p><p><strong>搜索</strong></p><p>/pattern → 搜索<code>pattern</code>的字符，如果有多个在enter后 按n 向后，N 先前。</p><p><strong>撤销和取消撤销</strong></p><p>u → undo<br><c-r> → redo</c-r></p><p><strong>打开/保存/退出/改变文件</strong><br>:e &lt;path/to/file&gt; → 打开一个文件<br>:x/ZZ/:wq → 都是保存并退出<br>:bn和: bp → 当有多个文件打开时，可以切换 n 是next p是previous</p><p><strong>重复</strong><br>. → 重复上一次的命令<br>N<command> → 重复某个命令N次</p><p>如：<br>2dd → 删除2行<br>3p → 粘贴文本3次<br>接着上次按 . 可以再次粘贴文本3次，<br>但是 3. 则是粘贴文本3次而不是9次</p><h2 id="Vim-超能力"><a href="#Vim-超能力" class="headerlink" title="Vim 超能力"></a>Vim 超能力</h2><p>fa → 到下一个为a的字符处，你也可以fs到下一个为s的字符。<br>t, → 到逗号前的第一个字符。逗号可以变成其它字符。<br>3fa → 在当前行查找第三个出现的a。<br>F 和 T → 和 f 和 t 一样，只不过是相反方向。<br>dt” → 删除所有的内容，直到遇到双引号—— “。</p><h2 id="visual模式下的操作"><a href="#visual模式下的操作" class="headerlink" title="visual模式下的操作"></a>visual模式下的操作</h2><blockquote><p>可视选择模式。此时可用hjkl 移动</p></blockquote><p><strong>选择后的操作</strong><br>d → (删除 )<br>gU → (变大写)<br>gu → (变小写)<br>J → 把所有的行连接起来（变成一行）<br>&lt; 或 &gt; → 左右缩进<br>= → 自动给缩进</p><p><strong>visual模式的命令</strong><br><action>a<object> 和 <action>i<object>  v模式的命令<br>action可以是任何的命令，如 d (删除), y (拷贝), v (可以视模式选择)。<br>object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：”、 ‘、 )、 }、 ]。</object></action></object></action></p><p>假设你有一个字符串 (map (+) (“foo”)).而光标键在第一个 o 的位置。</p><pre><code>vi&quot; → 会选择 foo.va&quot; → 会选择 &quot;foo&quot;.vi) → 会选择 &quot;foo&quot;.va) → 会选择(&quot;foo&quot;).v2i) → 会选择 map (+) (&quot;foo&quot;)v2a) → 会选择 (map (+) (&quot;foo&quot;))</code></pre><p><strong>块操作: <c-v></c-v></strong><br>块操作，典型的操作： 0 <c-v> <c-d> I– [ESC]</c-d></c-v></p><p>^ → 到行头<br><c-v> → 开始块操作<br><c-d> → 向下移动 (你也可以使用hjkl来移动光标，或是使用%，或是别的)<br>I– [ESC] → I是插入，插入“–”，按ESC键来为每一行生效。</c-d></c-v></p><h2 id="分屏"><a href="#分屏" class="headerlink" title="分屏"></a>分屏</h2><p>:vs 水平分屏<br>:sv 垂直分屏<br><c-w>w 顺序切换<br><c-w><dir> : dir就是方向，可以是 hjkl 或是 ←↓↑→ 中的一个，其用来切换分屏。<br><c-w>_ (或 <c-w>|) : 最大化尺寸 (<c-w>| 垂直分屏)<br><c-w>+ (或 <c-w>-) : 增加尺寸</c-w></c-w></c-w></c-w></c-w></dir></c-w></c-w></p><p><strong>启动时分屏</strong></p><p>使用大写的O参数来垂直分屏。<br><code>vim -On file1 file2 ...</code></p><blockquote><p>使用小写的o参数来水平分屏。n 代表分几屏<br><strong>关闭分屏</strong><br>Ctrl+W c</p></blockquote><h2 id="自动提示-和"><a href="#自动提示-和" class="headerlink" title="自动提示   和 "></a>自动提示  <c-n> 和 <c-p></c-p></c-n></h2><p>在 Insert 模式下，你可以输入一个词的开头，然后按 <c-p>或是<c-n>，自动补齐功能就出现了……</c-n></c-p></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>ye 当前位置拷贝到本单词的最后一个字符。<br>y2/foo 来拷贝2个 “foo” 之间的字符串。</p>]]></content>
      
      
      <categories>
          
          <category> Tools </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>github上实用的库</title>
      <link href="/2018/09/17/github%E4%B8%8A%E5%AE%9E%E7%94%A8%E7%9A%84%E5%BA%93/"/>
      <url>/2018/09/17/github%E4%B8%8A%E5%AE%9E%E7%94%A8%E7%9A%84%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="Echo-js-–-简单易用的图片延迟加载插件"><a href="#Echo-js-–-简单易用的图片延迟加载插件" class="headerlink" title="Echo.js – 简单易用的图片延迟加载插件"></a>Echo.js – 简单易用的图片延迟加载插件</h2><p>github：<a href="https://github.com/toddmotto/echo" target="_blank" rel="noopener">https://github.com/toddmotto/echo</a></p><p>官方网站：<a href="https://toddmotto.com/echo-js-simple-javascript-image-lazy-loading/" target="_blank" rel="noopener">https://toddmotto.com/echo-js-simple-javascript-image-lazy-loading/</a></p><p>star: 3K+</p><p>size：2KB</p><p>功能介绍：</p><blockquote><p>Echo.js 是一个独立的延迟加载图片的 JavaScript 插件。Echo.js 不依赖第三方库，压缩后不到1KB大小。 延迟加载是提高网页首屏显示速度的一种很有效的方法，当图片元素进入窗口可视区域的时候，它就会改变图像的 src 属性，从服务端加载所需的图片，这也是一个异步的过程。</p></blockquote><a id="more"></a><h2 id="Lazyr-js-–-延迟加载图片（Lazy-Loading）"><a href="#Lazyr-js-–-延迟加载图片（Lazy-Loading）" class="headerlink" title="Lazyr.js – 延迟加载图片（Lazy Loading）"></a>Lazyr.js – 延迟加载图片（Lazy Loading）</h2><p>github：<a href="https://github.com/callmecavs/layzr.js" target="_blank" rel="noopener">https://github.com/callmecavs/layzr.js</a></p><p>官方网站：<a href="http://callmecavs.com/layzr.js/" target="_blank" rel="noopener">http://callmecavs.com/layzr.js/</a></p><p>star: 5K+</p><p>size：2.75KB</p><p>功能介绍：</p><blockquote><p>Lazyr.js 是一个小的、快速的、现代的、相互间无依赖的图片延迟加载库。通过延迟加载图片，让图片出现在（或接近)）视窗才加载来提高页面打开速度。这个库通过保持最少选项并最大化速度。</p></blockquote><h2 id="infinite-scroll-–-一款滚动加载按需加载的轻量级插件"><a href="#infinite-scroll-–-一款滚动加载按需加载的轻量级插件" class="headerlink" title="infinite-scroll – 一款滚动加载按需加载的轻量级插件"></a>infinite-scroll – 一款滚动加载按需加载的轻量级插件</h2><p>github：<a href="https://github.com/infinite-scroll/infinite-scroll" target="_blank" rel="noopener">https://github.com/infinite-scroll/infinite-scroll</a></p><p>官方网站：<a href="http://www.infinite-scroll.com/" target="_blank" rel="noopener">http://www.infinite-scroll.com/</a></p><p>star：5k+</p><p>功能介绍：</p><blockquote><p>infinite-scroll是一款滚动加载，滚动到最下到自动加载的轻量级JavaScript插件，简单实用，按需加载提高用户体验，非常适合移动端使用，配合上面的图片懒加载如虎添翼。这个东西不是完全开源的，自己用的话无所谓，但如果想要在商业项目中使用，就必须要购买使用许可。</p></blockquote><h2 id="iscroll-在网页上实现平滑滚动"><a href="#iscroll-在网页上实现平滑滚动" class="headerlink" title="iscroll - 在网页上实现平滑滚动"></a>iscroll - 在网页上实现平滑滚动</h2><p>github：<a href="https://github.com/cubiq/iscroll" target="_blank" rel="noopener">https://github.com/cubiq/iscroll</a></p><p>官方网站：<a href="http://iscrolljs.com/" target="_blank" rel="noopener">http://iscrolljs.com</a></p><p>star：9K+</p><p>功能介绍：</p><blockquote><p>iScroll是一个高性能，小尺寸，无依赖关系，适用于 移动端 和 pc多平台JavaScript的滚动插件库，并且不仅仅是滚动，还可以缩放、平移、无线滚动、视差滚动、旋转滚动等，做到移动web与原生APP的完美结合，此系列还被细分出了许多其他专注于某个领域的插件，可以根据需要选择使用。</p></blockquote><h2 id="better-scroll-js-–-小巧，灵活的-JavaScript-模拟滚动条的插件"><a href="#better-scroll-js-–-小巧，灵活的-JavaScript-模拟滚动条的插件" class="headerlink" title="better-scroll.js – 小巧，灵活的 JavaScript 模拟滚动条的插件"></a>better-scroll.js – 小巧，灵活的 JavaScript 模拟滚动条的插件</h2><p>github：<a href="https://github.com/ustbhuangyi/better-scroll" target="_blank" rel="noopener">https://github.com/ustbhuangyi/better-scroll</a></p><p>官方网站：<a href="https://ustbhuangyi.github.io/better-scroll/" target="_blank" rel="noopener">https://ustbhuangyi.github.io/better-scroll/</a></p><p>star：1.7K+</p><p>size: 24KB</p><p>功能介绍：</p><blockquote><p>better-scroll 是一个只有24.8KB的 JavaScript 模拟浏览器自带滚动条的插件，是在iscroll开源的基础上进行优化的一款插件，简单好用，轻巧高性能，功能强大，API通俗易懂，有完善详细的官方文档，并且仓库中示例DEMO丰富详细，全都有对应的 vue实现，结合vue使用这款插件，简直不能再得心用手。</p></blockquote><h2 id="better-picker-–-一款轻量级IOS风格的JavaScript选择器"><a href="#better-picker-–-一款轻量级IOS风格的JavaScript选择器" class="headerlink" title="better-picker – 一款轻量级IOS风格的JavaScript选择器"></a>better-picker – 一款轻量级IOS风格的JavaScript选择器</h2><p>github：<a href="https://github.com/ustbhuangyi/picker" target="_blank" rel="noopener">https://github.com/ustbhuangyi/picker</a></p><p>官方网站：<a href="http://ustbhuangyi.github.io/picker/" target="_blank" rel="noopener">http://ustbhuangyi.github.io/picker/</a></p><p>star: 500+</p><p>size: 46.5KB</p><p>功能介绍：</p><blockquote><p>移动端最好用的的筛选器组件，高仿 ios 的 UIPickerView ，非常流畅的体验，原生 JS 实现，不依赖任何插件和第三方库</p></blockquote><p><img src="https://raw.githubusercontent.com/accforgit/DayLearnNote/master/img/picker.gif" alt="showpicture"></p><h2 id="nativeShare-js-调起移动端浏览器自带分享功能"><a href="#nativeShare-js-调起移动端浏览器自带分享功能" class="headerlink" title="nativeShare.js - 调起移动端浏览器自带分享功能"></a>nativeShare.js - 调起移动端浏览器自带分享功能</h2><p>github: <a href="https://github.com/fa-ge/NativeShare" target="_blank" rel="noopener">https://github.com/fa-ge/NativeShare</a></p><p>star: 60+</p><p>size: 4KB</p><p>功能介绍：</p><blockquote><p>移动端浏览器大多都有自带的调起分享功能，不过因为这种功能并没有统一的规范，所以每种浏览器的实现方法都不一样，此库整合了大部分浏览器的调起方法，让调起浏览器的 native分享功能的操作变的 <code>so easy</code>。</p></blockquote><h2 id="Share-js-纯网页端一键分享"><a href="#Share-js-纯网页端一键分享" class="headerlink" title="Share.js - 纯网页端一键分享"></a>Share.js - 纯网页端一键分享</h2><p>github: <a href="https://github.com/overtrue/share.js" target="_blank" rel="noopener">https://github.com/overtrue/share.js</a></p><p>star: 1.4k+</p><p>功能介绍：</p><blockquote><p>一键分享到微博、QQ空间、QQ好友、微信、腾讯微博、豆瓣、Facebook、Twitter、Linkedin、Google+、点点等社交网站，主要是调起这些网站对外开放的分享 <code>api</code></p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/1472352/11433126/05f8b0e0-94f4-11e5-9fca-74dc9d1b633f.png" alt="showpicture"></p><h2 id="Sortable-–-一款用于实现元素拖拽排序的功能的插件"><a href="#Sortable-–-一款用于实现元素拖拽排序的功能的插件" class="headerlink" title="Sortable – 一款用于实现元素拖拽排序的功能的插件"></a>Sortable – 一款用于实现元素拖拽排序的功能的插件</h2><p>github：<a href="https://github.com/RubaXa/Sortable" target="_blank" rel="noopener">https://github.com/RubaXa/Sortable</a></p><p>官方网站：<a href="http://rubaxa.github.io/Sortable/" target="_blank" rel="noopener">http://rubaxa.github.io/Sortable/</a></p><p>star：11k+</p><p>size: 5KB</p><p>功能介绍：</p><blockquote><p>现代浏览器上用于实现元素拖拽排序的功能，支持 Meteor, AngularJS, React</p></blockquote><h2 id="react-sortable-hoc-react-拖拽排序"><a href="#react-sortable-hoc-react-拖拽排序" class="headerlink" title="react-sortable-hoc - react 拖拽排序"></a>react-sortable-hoc - react 拖拽排序</h2><p>github: <a href="https://github.com/clauderic/react-sortable-hoc" target="_blank" rel="noopener">https://github.com/clauderic/react-sortable-hoc</a></p><p>star：2.8K+</p><p>功能介绍：</p><blockquote><p>基于react 的拖拽实现</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/react-sortable-hoc.gif" alt="showpicture"></p><h2 id="Draggabilly-–-轻松实现拖放功能（Drag-amp-Drop）"><a href="#Draggabilly-–-轻松实现拖放功能（Drag-amp-Drop）" class="headerlink" title="Draggabilly – 轻松实现拖放功能（Drag &amp; Drop）"></a>Draggabilly – 轻松实现拖放功能（Drag &amp; Drop）</h2><p>github：<a href="https://github.com/desandro/draggabilly" target="_blank" rel="noopener">https://github.com/desandro/draggabilly</a></p><p>官方网站：<a href="http://draggabilly.desandro.com/" target="_blank" rel="noopener">http://draggabilly.desandro.com/</a></p><p>star：2.9k+</p><p>size: 5KB</p><p>功能介绍：</p><blockquote><p>Draggabilly 是一个很小的 JavaScript 库，专注于拖放功能。只需要简单的设置参数就可以在你的网站用添加拖放功能。兼容 IE8+ 浏览器，支持多点触摸。可以灵活绑定事件，支持 RequireJS 以及 Bower 安装。</p></blockquote><h2 id="slick-–-功能异常强大的一个图片滑动切换效果库"><a href="#slick-–-功能异常强大的一个图片滑动切换效果库" class="headerlink" title="slick – 功能异常强大的一个图片滑动切换效果库"></a>slick – 功能异常强大的一个图片滑动切换效果库</h2><p>github：<a href="https://github.com/kenwheeler/slick" target="_blank" rel="noopener">https://github.com/kenwheeler/slick</a></p><p>官方网站：<a href="http://kenwheeler.github.io/slick/" target="_blank" rel="noopener">http://kenwheeler.github.io/slick/</a></p><p>star: 19K+</p><p>size: 40KB</p><p>功能介绍：</p><blockquote><p>slick 是一个功能异常强大的一个图片滑动切换效果库，接口丰富，支持各种动画和各种样式的切换滑动，唯一的缺点就是基于jQuery，基本废了，因为 jQuery没办法装逼，所以应该没人会在新项目用了，支持 RequireJS 以及 Bower 安装</p></blockquote><h2 id="react-slick-基于-slick-打造的-react-slick组件"><a href="#react-slick-基于-slick-打造的-react-slick组件" class="headerlink" title="react-slick - 基于 slick 打造的 react-slick组件"></a>react-slick - 基于 slick 打造的 react-slick组件</h2><p>github: <a href="https://github.com/akiran/react-slick" target="_blank" rel="noopener">https://github.com/akiran/react-slick</a></p><p>官网：<a href="http://neostack.com/opensource/react-slick" target="_blank" rel="noopener">http://neostack.com/opensource/react-slick</a></p><p>star: 3.3K+</p><p>功能介绍：</p><blockquote><p>基于 slick的 react-slick组件，支持无限轮播、垂直轮播、自动轮播等多种轮播方式</p></blockquote><h2 id="swipe-–-非常轻量级的一个图片滑动切换效果库"><a href="#swipe-–-非常轻量级的一个图片滑动切换效果库" class="headerlink" title="swipe – 非常轻量级的一个图片滑动切换效果库"></a>swipe – 非常轻量级的一个图片滑动切换效果库</h2><p>github：<a href="https://github.com/lyfeyaj/Swipe" target="_blank" rel="noopener">https://github.com/lyfeyaj/Swipe</a></p><p>官方网站：<a href="http://lyfeyaj.github.io/swipe/" target="_blank" rel="noopener">http://lyfeyaj.github.io/swipe/</a></p><p>star：390+</p><p>size: 5KB</p><p>功能介绍：</p><blockquote><p>非常轻量级的一个图片滑动切换效果库, 性能良好, 尤其是对手机的支持, 压缩后的大小约 5kb。可以结合 jQuery、RequireJS 使用</p></blockquote><p><img src="https://camo.githubusercontent.com/e04da5ac669c9c94d5e95181ad840a4197d14a60/687474703a2f2f6f6f327239726e7a702e626b742e636c6f7564646e2e636f6d2f323031372d30342d303925323030322e32392e32372e676966" alt="showpicture"></p><h2 id="Slideout-js-–-触摸滑出式-Web-App-导航菜单"><a href="#Slideout-js-–-触摸滑出式-Web-App-导航菜单" class="headerlink" title="Slideout.js – 触摸滑出式 Web App 导航菜单"></a>Slideout.js – 触摸滑出式 Web App 导航菜单</h2><p>github：<a href="https://github.com/mango/slideout" target="_blank" rel="noopener">https://github.com/mango/slideout</a></p><p>官方网站：<a href="https://slideout.js.org/" target="_blank" rel="noopener">https://slideout.js.org/</a></p><p>star：6.7k+</p><p>size: 4KB</p><p>功能介绍：</p><blockquote><p>Slideout.js 是为您的移动 Web 应用开发的触摸滑出式的导航菜单。它没有依赖，自由搭配简单的标记，支持原生的滚动，您可以轻松地定制它。它支持不同的 CSS3 转换和过渡。最重要的是，它只是4KB 。</p></blockquote><p><img src="https://camo.githubusercontent.com/9975d7a2331494043067998480ace0f1d2157e86/68747470733a2f2f692e696d6775722e636f6d2f415767776c56572e676966" alt="showpicture"></p><h2 id="SweetAlert-–-替代-Alert-的漂亮的提示效果"><a href="#SweetAlert-–-替代-Alert-的漂亮的提示效果" class="headerlink" title="SweetAlert – 替代 Alert 的漂亮的提示效果"></a>SweetAlert – 替代 Alert 的漂亮的提示效果</h2><p>github：<a href="https://github.com/t4t5/sweetalert" target="_blank" rel="noopener">https://github.com/t4t5/sweetalert</a></p><p>官方网站：<a href="http://t4t5.github.io/sweetalert/" target="_blank" rel="noopener">http://t4t5.github.io/sweetalert/</a></p><p>star：16k+</p><p>功能介绍：</p><blockquote><p>Sweet Alert 是一个替代传统的 JavaScript Alert 的漂亮提示效果。SweetAlert 自动居中对齐在页面中央，不管您使用的是台式电脑，手机或平板电脑看起来效果都很棒。另外提供了丰富的自定义配置选择，可以灵活控制。</p></blockquote><p><img src="https://sweetalert.js.org/assets/images/modal-examples.png" alt="这里写图片描述"></p><h2 id="push-js-桌面通知-Notification框架库"><a href="#push-js-桌面通知-Notification框架库" class="headerlink" title="push.js - 桌面通知 Notification框架库"></a>push.js - 桌面通知 Notification框架库</h2><p>github: <a href="https://github.com/Nickersoft/push.js" target="_blank" rel="noopener">https://github.com/Nickersoft/push.js</a></p><p>star: 6.1k+</p><p>功能介绍：Push 是 BrowserStack 出品的，快速实现基于 HTML5 API Notification 的桌面消息推送工具；Push 能够自动利用 Chrome、Safari、Firefox、IE9+ 这些现代浏览器提供的底层接口，为开发者提供跨平台的统一调用，如果浏览器不支持此 API，则启动回退机制，支持 Chrome, Safari, Firefox, and IE 9+</p><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/pushjs.gif" alt="pushjs"></p><h2 id="tracking-js-web端图像追踪引擎"><a href="#tracking-js-web端图像追踪引擎" class="headerlink" title="tracking.js - web端图像追踪引擎"></a>tracking.js - web端图像追踪引擎</h2><p>github：<a href="https://github.com/eduardolundgren/tracking.js" target="_blank" rel="noopener">https://github.com/eduardolundgren/tracking.js</a></p><p>官网：<a href="https://trackingjs.com/" target="_blank" rel="noopener">https://trackingjs.com/</a></p><p>star：5.4K+</p><p>功能介绍：</p><blockquote><p>完成各种追踪类的图像处理任务，例如人脸识别、五官追踪等</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/trackingjs.gif" alt="trackingjs"></p><h2 id="AlloyImage-堪称前端PS的前端图像处理类库"><a href="#AlloyImage-堪称前端PS的前端图像处理类库" class="headerlink" title="AlloyImage - 堪称前端PS的前端图像处理类库"></a>AlloyImage - 堪称前端PS的前端图像处理类库</h2><p>github：<a href="https://github.com/AlloyTeam/AlloyImage" target="_blank" rel="noopener">https://github.com/AlloyTeam/AlloyImage</a></p><p>官网：<a href="http://alloyteam.github.io/AlloyImage/" target="_blank" rel="noopener">http://alloyteam.github.io/AlloyImage/</a></p><p>star:1.7K+</p><p>功能介绍：</p><blockquote><p>腾讯前端出品，基于html5的JS图片图像处理库，堪称前端PS，简单易用，官方文档齐全，支持多图层操作，与PS对应的17种图层混合模式，多种基本滤镜处理效果，多种组合风格效果，另有 <a href="http://alloyteam.github.io/AlloyImage/alloyphotopro.html" target="_blank" rel="noopener">AlloyPhoto</a>，基于此类库开发，AlloyImage的强势Demo。</p></blockquote><h2 id="gm-基于nodeJS操作图片的库"><a href="#gm-基于nodeJS操作图片的库" class="headerlink" title="gm - 基于nodeJS操作图片的库"></a>gm - 基于nodeJS操作图片的库</h2><p>github：<a href="https://github.com/aheckmann/gm" target="_blank" rel="noopener">https://github.com/aheckmann/gm</a></p><p>官网：<a href="http://aheckmann.github.io/gm/" target="_blank" rel="noopener">http://aheckmann.github.io/gm/</a></p><p>star：4.3K+</p><p>功能介绍：</p><blockquote><p>基于node操作图片的库，可以获取图片尺寸(size)、路径(orientation )、类型(format)、色值(depth)、颜色(color)、分辨率(res)、体积(filesize)等信息，可以对图像进行拼合、水印、自适应、模糊、压缩、旋转等多种操作，功能很强大。</p></blockquote><p>star：4.3K+</p><h2 id="Awesomplete-js-比datalist更强大更实用，零依赖的简单自动补全插件"><a href="#Awesomplete-js-比datalist更强大更实用，零依赖的简单自动补全插件" class="headerlink" title="Awesomplete.js - 比datalist更强大更实用，零依赖的简单自动补全插件"></a>Awesomplete.js - 比datalist更强大更实用，零依赖的简单自动补全插件</h2><p>github：<a href="https://github.com/leaverou/awesomplete/" target="_blank" rel="noopener">https://github.com/leaverou/awesomplete/</a></p><p>官方网站：<a href="http://leaverou.github.io/awesomplete/" target="_blank" rel="noopener">http://leaverou.github.io/awesomplete/</a></p><p>star: 5.6K+</p><p>size: 5KB</p><p>功能介绍：</p><blockquote><p>Awesomplete 是一款超轻量级的，可定制的，简单的自动完成插件，零依赖，使用现代化标准构建。你可以简单地添加 awesomplete 样式，让它自动处理（你仍然可以通过指定 HTML 属性配置更多选项），您可以用几行 JS 代码，提供更多的自定义</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/awesomplete.gif" alt="awesomplete"></p><h2 id="Cleave-js-–-自动格式化表单输入框的文本内容"><a href="#Cleave-js-–-自动格式化表单输入框的文本内容" class="headerlink" title="Cleave.js – 自动格式化表单输入框的文本内容"></a>Cleave.js – 自动格式化表单输入框的文本内容</h2><p>github：<a href="https://github.com/nosir/cleave.js/" target="_blank" rel="noopener">https://github.com/nosir/cleave.js/</a></p><p>官方网站：<a href="http://nosir.github.io/cleave.js/" target="_blank" rel="noopener">http://nosir.github.io/cleave.js/</a></p><p>star: 7.2K+</p><p>size: 11.1KB</p><p>功能介绍：</p><blockquote><p>Cleave.js 有一个简单的目的：帮助你自动格式输入的文本内容。 这个想法是提供一个简单的方法来格式化您的输入数据以增加输入字段的可读性。通过使用这个库，您不需要编写任何正则表达式来控制输入文本的格式。然而，这并不意味着取代任何验证或掩码库，你仍应在后端验证数据。它支持信用卡号码、电话号码格式（支持各个国家）、日期格式、数字格式、自定义分隔符，前缀和块模式等，提供 CommonJS/AMD 模式以及ReactJS 组件端口。</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/cleavejs.gif" alt="Cleave"></p><h2 id="Immutable-js-–-JavaScript-不可变数据集合（Facebook出品）"><a href="#Immutable-js-–-JavaScript-不可变数据集合（Facebook出品）" class="headerlink" title="Immutable.js – JavaScript 不可变数据集合（Facebook出品）"></a>Immutable.js – JavaScript 不可变数据集合（Facebook出品）</h2><p>github：<a href="https://github.com/facebook/immutable-js" target="_blank" rel="noopener">https://github.com/facebook/immutable-js</a></p><p>官方网站：<a href="http://facebook.github.io/immutable-js/" target="_blank" rel="noopener">http://facebook.github.io/immutable-js/</a></p><p>star: 20K+</p><p>size: 60KB</p><p>功能介绍：</p><blockquote><p>不可变数据是指一旦创建就不能被修改的数据，使得应用开发更简单，允许使用函数式编程技术，比如惰性评估。Immutable JS 提供一个惰性 Sequence，允许高效的队列方法链，类似 map 和 filter ，不用创建中间代表。Immutable.js 提供持久化的列表、堆栈、Map， 以及 OrderedMap 等，最大限度地减少需要复制或缓存数据。</p></blockquote><h2 id="howler-js-为现代web浏览器打造的-javascript音频库"><a href="#howler-js-为现代web浏览器打造的-javascript音频库" class="headerlink" title="howler.js - 为现代web浏览器打造的 javascript音频库"></a>howler.js - 为现代web浏览器打造的 javascript音频库</h2><p>github：<a href="https://github.com/goldfire/howler.js" target="_blank" rel="noopener">https://github.com/goldfire/howler.js</a></p><p>官网：<a href="https://howlerjs.com/" target="_blank" rel="noopener">https://howlerjs.com/</a></p><p>star: 8.4K+</p><p>size: 28.3KB</p><p>功能介绍：</p><blockquote><p>为现代web浏览器打造的跨浏览器 javascript音频库，默认使用 HTML5 Audio API，回退为 HTML Audio，统一所有浏览器的 Audio API接口，<br>自动缓存、音频控制（快进、快退、速度等）、混合、裁剪、3D音效等众多功能，纯净无依赖、压缩后仅有 28.3Kb、gzip之后仅有 7KB大小，支持 <code>IE9.0+</code></p></blockquote><p><img src="https://howlerjs.com/assets/images/logo.svg" alt="showpicture"></p><h2 id="Popmotion-js-–-小巧，灵活的-JavaScript-运动引擎"><a href="#Popmotion-js-–-小巧，灵活的-JavaScript-运动引擎" class="headerlink" title="Popmotion.js – 小巧，灵活的 JavaScript 运动引擎"></a>Popmotion.js – 小巧，灵活的 JavaScript 运动引擎</h2><p>github：<a href="https://github.com/Popmotion/popmotion" target="_blank" rel="noopener">https://github.com/Popmotion/popmotion</a></p><p>官方网站：<a href="https://popmotion.io/" target="_blank" rel="noopener">https://popmotion.io/</a></p><p>star：3.9k+</p><p>size: 12KB</p><p>功能介绍：</p><blockquote><p>Popmotion 是一个只有12KB的 JavaScript 运动引擎，可以用来实现，物理效果和输入跟踪。原生的DOM支持：CSS，SVG，SVG路径和DOM属性的支持，开箱即用。Popmotion 网站上有很多很赞的效果，赶紧去体验一下。</p></blockquote><h2 id="Dynamics-js-创建逼真的物理动画的-JS-库"><a href="#Dynamics-js-创建逼真的物理动画的-JS-库" class="headerlink" title="Dynamics.js - 创建逼真的物理动画的 JS 库"></a>Dynamics.js - 创建逼真的物理动画的 JS 库</h2><p>github：<a href="https://github.com/michaelvillar/dynamics.js" target="_blank" rel="noopener">https://github.com/michaelvillar/dynamics.js</a></p><p>官方网站：<a href="http://dynamicsjs.com/" target="_blank" rel="noopener">http://dynamicsjs.com/</a></p><p>star：6.5k+</p><p>size: 20KB</p><p>功能介绍：</p><blockquote><p>创建逼真的物理动画的 JS 库</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/dynamicsjs.gif" alt="dynamics"></p><h2 id="Snabbt-js-–-极简性能的-JavaScript-动画库"><a href="#Snabbt-js-–-极简性能的-JavaScript-动画库" class="headerlink" title="Snabbt.js – 极简性能的 JavaScript 动画库"></a>Snabbt.js – 极简性能的 JavaScript 动画库</h2><p>github：<a href="http://daniel-lundin.github.io/snabbt.js/" target="_blank" rel="noopener">http://daniel-lundin.github.io/snabbt.js/</a></p><p>star：5k+</p><p>功能介绍：</p><blockquote><p>Snabbt.js 是一个简约的 JavaScript 动画库。它会平移，旋转，缩放，倾斜和调整你的元素。通过矩阵乘法运算，变换等可以任何你想要的方式进行组合。最终的结果通过 CSS3 变换矩阵设置。</p></blockquote><h2 id="animate-css-经典的-cs动画库"><a href="#animate-css-经典的-cs动画库" class="headerlink" title="animate.css - 经典的 cs动画库"></a>animate.css - 经典的 cs动画库</h2><p>github: <a href="https://github.com/daneden/animate.css" target="_blank" rel="noopener">https://github.com/daneden/animate.css</a></p><p>star： 44k+</p><p>功能介绍：</p><blockquote><p>类似于上面的 <a href="http://daniel-lundin.github.io/snabbt.js/" target="_blank" rel="noopener">Snabbt.js</a>，不过动画效果是由 <code>css</code>实现的，支持多种动画效果。</p></blockquote><h2 id="velocity-js-javascript动画库，专注于动画的渲染速度"><a href="#velocity-js-javascript动画库，专注于动画的渲染速度" class="headerlink" title="velocity.js - javascript动画库，专注于动画的渲染速度"></a>velocity.js - javascript动画库，专注于动画的渲染速度</h2><p>github: <a href="https://github.com/julianshapiro/velocity" target="_blank" rel="noopener">https://github.com/julianshapiro/velocity</a></p><p>官网：<a href="http://velocityjs.org/" target="_blank" rel="noopener">http://velocityjs.org/</a></p><p>star：13.3K+</p><p>功能介绍：</p><blockquote><p>javascript动画库，专注于动画的渲染速度，具有和 Jquery $.animate()相同的动画引擎，不过其并不依赖 Jquery</p></blockquote><h2 id="mojs-web端图形运动算法库，用于制作复杂的炫酷动画效果"><a href="#mojs-web端图形运动算法库，用于制作复杂的炫酷动画效果" class="headerlink" title="mojs - web端图形运动算法库，用于制作复杂的炫酷动画效果"></a>mojs - web端图形运动算法库，用于制作复杂的炫酷动画效果</h2><p>github：<a href="https://github.com/legomushroom/mojs" target="_blank" rel="noopener">https://github.com/legomushroom/mojs</a></p><p>star: 11.9K+</p><p>功能介绍：</p><blockquote><p>web端图形运动算法库，用于制作复杂的炫酷动画效果，官网有详细的 api文档以及示例</p></blockquote><h2 id="tween-js-javascript-tweening-engine"><a href="#tween-js-javascript-tweening-engine" class="headerlink" title="tween.js - javascript tweening engine"></a>tween.js - javascript tweening engine</h2><p>github: <a href="https://github.com/tweenjs/tween.js" target="_blank" rel="noopener">https://github.com/tweenjs/tween.js</a></p><p>star: 4.5k+</p><p>功能介绍：</p><blockquote><p>一款根据给定的初始坐标和结束坐标进行运动动画的动画库，包括 Linear、Quadratic、cubic、Quartic、Quintic、Sinusoidal、Exponential等形式的动画效果，还包括在动画过程中增删更新元素等的操作，便于实现简单的两点动画。</p></blockquote><h2 id="Rainyday-js-–-使用-JavaScript-实现雨滴效果"><a href="#Rainyday-js-–-使用-JavaScript-实现雨滴效果" class="headerlink" title="Rainyday.js – 使用 JavaScript 实现雨滴效果"></a>Rainyday.js – 使用 JavaScript 实现雨滴效果</h2><p>github：<a href="https://github.com/maroslaw/rainyday.js" target="_blank" rel="noopener">https://github.com/maroslaw/rainyday.js</a></p><p>官方网站：<a href="http://maroslaw.github.io/rainyday.js/" target="_blank" rel="noopener">http://maroslaw.github.io/rainyday.js/</a></p><p>star：5.2k+</p><p>size: 10KB</p><p>功能介绍：</p><blockquote><p>Rainyday.js 背后的想法是创建一个 JavaScript 库，利用 HTML5 Canvas 渲染一个雨滴落在玻璃表面的动画。Rainyday.js 有功能可扩展的 API，例如碰撞检测和易于扩展自己的不同的动画组件的实现。它是一个使用 HTML5 特性纯 JavaScript 库，支持大部分现代浏览器。</p></blockquote><p><img src="http://maroslaw.github.io/rainyday.js/img/dm1.jpg" alt="showpicture"></p><h2 id="vx-react-D3"><a href="#vx-react-D3" class="headerlink" title="vx react + D3"></a>vx react + D3</h2><p>github: <a href="https://github.com/hshoff/vx" target="_blank" rel="noopener">https://github.com/hshoff/vx</a></p><p>官网：<a href="https://vx-demo.now.sh/" target="_blank" rel="noopener">https://vx-demo.now.sh/</a></p><p>star：2.6K+</p><p>功能介绍：</p><blockquote><p>react结合 D3实现的图标库</p></blockquote><p><img src="https://raw.githubusercontent.com/hshoff/vx/master/assets/vx-gallery.png" alt="showpicture"></p><h2 id="vue-svg-icon-轻量的Vue2多色动态svg图标方案"><a href="#vue-svg-icon-轻量的Vue2多色动态svg图标方案" class="headerlink" title="vue-svg-icon - 轻量的Vue2多色动态svg图标方案"></a>vue-svg-icon - 轻量的Vue2多色动态svg图标方案</h2><p>github: <a href="https://github.com/cenkai88/vue-svg-icon" target="_blank" rel="noopener">https://github.com/cenkai88/vue-svg-icon</a></p><p>star: 230+</p><p>功能介绍：</p><blockquote><p>不需要 inject注册 svg，可以自行调整大小、颜色，没有冗余的初始图标库，你需要什么图标就自己添加，完全按需加载，不用担心额外图标库带来的体积增加。</p></blockquote><h2 id="pasition-轻量级Path过渡库，渲染到任何地方"><a href="#pasition-轻量级Path过渡库，渲染到任何地方" class="headerlink" title="pasition - 轻量级Path过渡库，渲染到任何地方"></a>pasition - 轻量级Path过渡库，渲染到任何地方</h2><p>github: <a href="https://github.com/AlloyTeam/pasition" target="_blank" rel="noopener">https://github.com/AlloyTeam/pasition</a></p><p>star:700k+</p><p>功能介绍：</p><blockquote><p>在两个 svg path将设置过渡渲染效果，让两个 path间的变化显得更加平滑</p></blockquote><p><img src="https://camo.githubusercontent.com/d48802a29ef0d970b453b1a414c5a4c34b7e52f7/687474703a2f2f696d61676573323031352e636e626c6f67732e636f6d2f626c6f672f3130353431362f3230313730362f3130353431362d32303137303632303039343831373535342d34383331363130372e676966" alt="showpicture"></p><h2 id="scrollReveal-js-–-使元素以非常酷帅的方式进入画布-Viewpoint"><a href="#scrollReveal-js-–-使元素以非常酷帅的方式进入画布-Viewpoint" class="headerlink" title="scrollReveal.js – 使元素以非常酷帅的方式进入画布 (Viewpoint)"></a>scrollReveal.js – 使元素以非常酷帅的方式进入画布 (Viewpoint)</h2><p>github：<a href="https://github.com/jlmakes/scrollreveal" target="_blank" rel="noopener">https://github.com/jlmakes/scrollreveal</a></p><p>官方网站：<a href="https://scrollrevealjs.org/" target="_blank" rel="noopener">https://scrollrevealjs.org/</a></p><p>star：12k+</p><p>size: 8KB</p><p>功能介绍：</p><blockquote><p>scrollReveal.js 是一个用于使元素以非常酷帅的方式进入画布的 JavaScript 工具库，常见于整屏的 H5动画，当元素进入或者离开可视范围时，进行一系列的动画效果，轻量级，高性能，无依赖的一个小巧酷炫的库。</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/scrollrevealjs.gif" alt="scrollreveal"></p><h2 id="Swiper-–-经典的移动触摸滑块轮播插件"><a href="#Swiper-–-经典的移动触摸滑块轮播插件" class="headerlink" title="Swiper – 经典的移动触摸滑块轮播插件"></a>Swiper – 经典的移动触摸滑块轮播插件</h2><p>github：<a href="https://github.com/nolimits4web/Swiper" target="_blank" rel="noopener">https://github.com/nolimits4web/Swiper</a></p><p>官方网站：<a href="http://idangero.us/swiper/" target="_blank" rel="noopener">http://idangero.us/swiper/</a></p><p>star：13.3k+</p><p>功能介绍：</p><blockquote><p>Swiper 是移动 Web 开发中最常用的滑块插件，是一款免费的，最现代化的移动触摸滑块，支持硬件加速的转换和惊人的原生表现。它的目的是在移动网站，移动 Web 应用程序和 Hygrid 混合应用程序中使用。最初的设计主要是为 iOS，但同时也支持最新的 Android，Windows Phone 8 和现代的桌面浏览器。</p></blockquote><h2 id="imagesLoaded-–-检测网页中的图片是否加载完成"><a href="#imagesLoaded-–-检测网页中的图片是否加载完成" class="headerlink" title="imagesLoaded – 检测网页中的图片是否加载完成"></a>imagesLoaded – 检测网页中的图片是否加载完成</h2><p>github：<a href="https://github.com/desandro/imagesloaded" target="_blank" rel="noopener">https://github.com/desandro/imagesloaded</a></p><p>官方网站：<a href="http://imagesloaded.desandro.com/" target="_blank" rel="noopener">http://imagesloaded.desandro.com/</a></p><p>star：6.6k+</p><p>size: 1.9KB</p><p>功能介绍：</p><blockquote><p>imagesLoaded 是一个用于来检测网页中的图片是否载入完成的 JavaScript 工具库。支持回调的获取图片加载的进度，还可以绑定自定义事件。可以结合 jQuery、RequireJS 使用(不是必须的)。</p></blockquote><h2 id="Fort-js-–-时尚、现代的表单填写进度提示效果"><a href="#Fort-js-–-时尚、现代的表单填写进度提示效果" class="headerlink" title="Fort.js – 时尚、现代的表单填写进度提示效果"></a>Fort.js – 时尚、现代的表单填写进度提示效果</h2><p>github：<a href="https://github.com/idriskhenchil/Fort.js" target="_blank" rel="noopener">https://github.com/idriskhenchil/Fort.js</a></p><p>官方网站：<a href="https://github.com/idriskhenchil/Fort.js" target="_blank" rel="noopener">https://github.com/idriskhenchil/Fort.js</a></p><p>star：900+</p><p>size: 6KB</p><p>功能介绍：</p><blockquote><p>Fort.js 是一款用于时尚、现代的表单填写进度提示效果的 JavaScript 库，主要就是在浏览器顶部增加一个进度条，随着表单内的 input框被填写的比例进行进度条的长度变化，进度条支持多种变化的样式，例如渐变、从两边朝中间合并、变色等，你需要做的就是添加表单，剩下的任务就交给 Fort.js 算法了，使用非常简单。提供了Default、Gradient、Sections 以及 Flash 四种效果，满足开发的各种场合需要。</p></blockquote><h2 id="MagicSuggest-–-Bootstrap-主题的多选组合框"><a href="#MagicSuggest-–-Bootstrap-主题的多选组合框" class="headerlink" title="MagicSuggest – Bootstrap 主题的多选组合框"></a>MagicSuggest – Bootstrap 主题的多选组合框</h2><p>github：<a href="https://github.com/nicolasbize/magicsuggest" target="_blank" rel="noopener">https://github.com/nicolasbize/magicsuggest</a></p><p>官方网站：<a href="http://nicolasbize.com/magicsuggest/" target="_blank" rel="noopener">http://nicolasbize.com/magicsuggest/</a></p><p>star：1.2k+</p><p>size: 21.8KB</p><p>功能介绍：</p><blockquote><p>MagicSuggest 是专为 Bootstrap 主题开发的多选组合框，即允许在一个输入框中输入多个下拉选择，它支持自定义呈现，数据通过 Ajax 异步获取，使用组件自动过滤。它允许空间免费项目，也有动态加载固定的建议，</p></blockquote><h2 id="Numeral-js-–-格式化和操作数字的-JavaScript-库"><a href="#Numeral-js-–-格式化和操作数字的-JavaScript-库" class="headerlink" title="Numeral.js – 格式化和操作数字的 JavaScript 库"></a>Numeral.js – 格式化和操作数字的 JavaScript 库</h2><p>github：<a href="https://github.com/adamwdraper/Numeral-js" target="_blank" rel="noopener">https://github.com/adamwdraper/Numeral-js</a></p><p>官方网站：<a href="http://numeraljs.com/" target="_blank" rel="noopener">http://numeraljs.com/</a></p><p>star：5.3k+</p><p>size: 10KB</p><p>功能介绍：</p><blockquote><p>Numeral.js 是一个用于格式化和操作数字的 JavaScript 库。数字可以格式化为货币，百分比，时间，甚至是小数，千位，和缩写格式，功能十分强大。支持包括中文在内的17种语言。</p></blockquote><h2 id="Quill-–-可以灵活自定义的开源的富文本编辑器"><a href="#Quill-–-可以灵活自定义的开源的富文本编辑器" class="headerlink" title="Quill – 可以灵活自定义的开源的富文本编辑器"></a>Quill – 可以灵活自定义的开源的富文本编辑器</h2><p>github：<a href="https://github.com/quilljs/quill/" target="_blank" rel="noopener">https://github.com/quilljs/quill/</a></p><p>官方网站：<a href="https://quilljs.com/" target="_blank" rel="noopener">https://quilljs.com</a></p><p>star：14k+</p><p>功能介绍：</p><blockquote><p>Quill 的建立是为了解决现有的所见即所得（WYSIWYG）的编辑器本身就是所见即所得（指不能再扩张）的问题。如果编辑器不正是你想要的方式，这是很难或不可能对其进行自定义以满足您的需求。<br>Quill 旨在通过把自身组织成模块，并提供了强大的 API 来构建额外的模块来解决这个问题。它也并没有规定你用样式来定义编辑器皮肤。Quill 还提供了所有你希望富文本编辑器说用于的功能，包括轻量级封装，众多的格式化选项，以及广泛的跨平台支持。</p></blockquote><h2 id="request-让-http请求变得更简单"><a href="#request-让-http请求变得更简单" class="headerlink" title="request - 让 http请求变得更简单"></a>request - 让 http请求变得更简单</h2><p>github: <a href="https://github.com/request/request" target="_blank" rel="noopener">https://github.com/request/request</a></p><p>star: 16.7K+</p><p>size: 500K+</p><p>功能介绍：</p><blockquote><p>基于 node.js http模块，为浏览器打造易用的 http请求库，默认支持 https和重定向，支持文件流和表单的传输、HTTP认证、OAuth登录、定制HTTP header、cookies(默认禁止，需要自动开启)、代理、promise、async/await、HAR 1.2等多种 http请求。</p></blockquote><h2 id="r2-参考-request打造的轻量级、高可用的-http客户端"><a href="#r2-参考-request打造的轻量级、高可用的-http客户端" class="headerlink" title="r2 - 参考 request打造的轻量级、高可用的 http客户端"></a>r2 - 参考 request打造的轻量级、高可用的 http客户端</h2><p>github: <a href="https://github.com/mikeal/r2" target="_blank" rel="noopener">https://github.com/mikeal/r2</a></p><p>size: 66K</p><p>功能介绍：</p><blockquote><p>与 request为同一个作者打造，相比于 request更加轻量、专注，基于现代浏览器的 <code>fetch API</code>，基于 <code>promise</code>， 与 <code>asynv/await</code>搭配更佳。</p></blockquote><h2 id="basket-js-–-基于-LocalStorage-的资源加载器"><a href="#basket-js-–-基于-LocalStorage-的资源加载器" class="headerlink" title="basket.js – 基于 LocalStorage 的资源加载器"></a>basket.js – 基于 LocalStorage 的资源加载器</h2><p>github：<a href="https://github.com/addyosmani/basket.js" target="_blank" rel="noopener">https://github.com/addyosmani/basket.js</a></p><p>官方网站：<a href="https://addyosmani.com/basket.js/" target="_blank" rel="noopener">https://addyosmani.com/basket.js/</a></p><p>star：2.9k+</p><p>size: 4KB</p><p>功能介绍：</p><blockquote><p>basket.js是一款基于 LocalStorage 的资源加载器，可以用来缓存 script 和 css, 手机端使用速度快于浏览器直接缓存。</p></blockquote><h2 id="moment-js-–-一款轻量级的Javascript日期处理类库"><a href="#moment-js-–-一款轻量级的Javascript日期处理类库" class="headerlink" title="moment.js – 一款轻量级的Javascript日期处理类库"></a>moment.js – 一款轻量级的Javascript日期处理类库</h2><p>github：<a href="https://github.com/moment/moment/" target="_blank" rel="noopener">https://github.com/moment/moment/</a></p><p>官方网站：<a href="http://momentjs.com/" target="_blank" rel="noopener">http://momentjs.com/</a></p><p>star：32k+</p><p>size: 16.6KB</p><p>功能介绍：</p><blockquote><p>moment.js是一个轻量级的JavaScript库日期解析、验证操作,格式化日期的库。</p></blockquote><h2 id="hammerjs"><a href="#hammerjs" class="headerlink" title="hammerjs"></a>hammerjs</h2><p>github：<a href="https://github.com/hammerjs/hammer.js/" target="_blank" rel="noopener">https://github.com/hammerjs/hammer.js/</a></p><p>star: 16k+</p><p>功能介绍：</p><blockquote><p>hammer.js是一个轻量级的手势库，支持各种手势的事件。</p></blockquote><h2 id="ityped-模拟打字效果"><a href="#ityped-模拟打字效果" class="headerlink" title="ityped - 模拟打字效果"></a>ityped - 模拟打字效果</h2><p>github: <a href="https://github.com/luisvinicius167/ityped" target="_blank" rel="noopener">https://github.com/luisvinicius167/ityped</a></p><p>官网：<a href="https://ityped.surge.sh/" target="_blank" rel="noopener">https://ityped.surge.sh/</a></p><p>star: 1.7K+</p><p>size: 1.9KB</p><p>功能介绍：</p><blockquote><p>模拟打字机效果</p></blockquote><p><img src="https://camo.githubusercontent.com/4737e3d76d0b124e49bce863013e08f0b8eb664d/68747470733a2f2f63646e2e7261776769742e636f6d2f6c75697376696e69636975733136372f6974797065642f6d61737465722f696d672f6974797065646a732e676966" alt="showpicture"></p><h2 id="favico-js-动态变换网站图标"><a href="#favico-js-动态变换网站图标" class="headerlink" title="favico.js - 动态变换网站图标"></a>favico.js - 动态变换网站图标</h2><p>github：<a href="https://github.com/ejci/favico.js" target="_blank" rel="noopener">https://github.com/ejci/favico.js</a></p><p>star: 7.6K+</p><p>功能介绍：</p><blockquote><p>动态改变网站的 favico图标，可以是图片、html视频等，支持改变颜色、字体、背景颜色等。</p></blockquote><h2 id="move-js-js动态设置-css3动画"><a href="#move-js-js动态设置-css3动画" class="headerlink" title="move.js - js动态设置 css3动画"></a>move.js - js动态设置 <code>css3</code>动画</h2><p>github: <a href="https://github.com/visionmedia/move.js" target="_blank" rel="noopener">https://github.com/visionmedia/move.js</a></p><p>star: 4.1K+</p><p>功能介绍：</p><blockquote><p>为元素设置css3动画</p></blockquote><h2 id="notie-网页提示弹窗"><a href="#notie-网页提示弹窗" class="headerlink" title="notie - 网页提示弹窗"></a>notie - 网页提示弹窗</h2><p>github：<a href="https://github.com/jaredreich/notie" target="_blank" rel="noopener">https://github.com/jaredreich/notie</a></p><p>star: 5.6K+</p><p>功能介绍：</p><blockquote><p>平滑出现在网页内的弹窗，类似于 modal窗</p></blockquote><p><img src="https://github.com/accforgit/DayLearnNote/raw/master/img/notie.gif" alt="notie"></p><h2 id="particles-js-粒子动画库"><a href="#particles-js-粒子动画库" class="headerlink" title="particles.js - 粒子动画库"></a>particles.js - 粒子动画库</h2><p>github：<a href="https://github.com/VincentGarreau/particles.js" target="_blank" rel="noopener">https://github.com/VincentGarreau/particles.js</a></p><p>star: 11.1k+</p><p>功能介绍：</p><blockquote><p>炫酷的粒子动画</p></blockquote><p><img src="https://camo.githubusercontent.com/cdc9e740f0c04b77449e476c91e6f7770a6af6e7/687474703a2f2f76696e63656e74676172726561752e636f6d2f7061727469636c65732e6a732f6173736574732f696d672f6769746875622d73637265656e2e6a7067" alt="showpicture"></p><h2 id="popper-js"><a href="#popper-js" class="headerlink" title="popper.js"></a>popper.js</h2><p>github：<a href="https://github.com/FezVrasta/popper.js" target="_blank" rel="noopener">https://github.com/FezVrasta/popper.js</a></p><p>官网：<a href="https://popper.js.org/" target="_blank" rel="noopener">https://popper.js.org/</a></p><p>star: 5.5K+</p><p>size: 6KB</p><p>功能介绍：</p><blockquote><p>纯 JS 写的轻量级位置计算引擎，零依赖；可用她定制诸如 tooltips等工具，比如 Tippy.js、tooltip.js 就是基于该库打造而成的。</p></blockquote><h2 id="lightgallery-js-图片-amp-视频展示的gallery"><a href="#lightgallery-js-图片-amp-视频展示的gallery" class="headerlink" title="lightgallery.js - 图片&amp;视频展示的gallery"></a>lightgallery.js - 图片&amp;视频展示的gallery</h2><p>github: <a href="https://github.com/sachinchoolur/lightgallery.js" target="_blank" rel="noopener">https://github.com/sachinchoolur/lightgallery.js</a></p><p>官网：<a href="https://sachinchoolur.github.io/lightgallery.js/" target="_blank" rel="noopener">https://sachinchoolur.github.io/lightgallery.js/</a></p><p>star: 3.5k+</p><p>功能介绍：</p><blockquote><p>纯 JS 写的图片&amp;视频展示的gallery，提供丰富的API、响应式功能、HTML5特性支持等，功能强大，用于网站的图片专门的浏览页面；</p></blockquote><p><img src="https://raw.githubusercontent.com/sachinchoolur/lightgallery.js/gh-pages/lightgallery.png" alt="showpicture"></p><h2 id="APlayer-快速创建音乐播放器"><a href="#APlayer-快速创建音乐播放器" class="headerlink" title="APlayer - 快速创建音乐播放器"></a>APlayer - 快速创建音乐播放器</h2><p>github：<a href="https://github.com/MoePlayer/APlayer" target="_blank" rel="noopener">https://github.com/MoePlayer/APlayer</a></p><p>star: 1.8K+</p><p>功能介绍：</p><blockquote><p>只需配置参数即可快速创建音乐播放器</p></blockquote><p><img src="https://camo.githubusercontent.com/a69d395460135e5542a3fd3f9a09d3817d17c228/68747470733a2f2f692e696d6775722e636f6d2f4a44724a5843722e706e67" alt="showpicture"></p><h2 id="fabric-js-简单而强大的-JavaScript-Canvas-库"><a href="#fabric-js-简单而强大的-JavaScript-Canvas-库" class="headerlink" title="fabric.js - 简单而强大的 JavaScript Canvas 库"></a>fabric.js - 简单而强大的 JavaScript Canvas 库</h2><p>github: <a href="https://github.com/kangax/fabric.js" target="_blank" rel="noopener">https://github.com/kangax/fabric.js</a></p><p>官网：<a href="http://fabricjs.com/" target="_blank" rel="noopener">http://fabricjs.com/</a></p><p>star: 8.5K+</p><p>功能介绍：</p><blockquote><p>支持 canvas 与 svg、json之间的转换，支持图像形状、过渡色、颜色、角度、字体、动画、手势拖放等</p></blockquote><p><img src="https://github.com/kangax/fabric.js/raw/master/lib/screenshot.png" alt="showpicture"></p><h2 id="intro-js-向用户一步步介绍网站的新功能"><a href="#intro-js-向用户一步步介绍网站的新功能" class="headerlink" title="intro.js - 向用户一步步介绍网站的新功能"></a>intro.js - 向用户一步步介绍网站的新功能</h2><p>github: <a href="https://github.com/usablica/intro.js" target="_blank" rel="noopener">https://github.com/usablica/intro.js</a></p><p>官网：<a href="http://introjs.com/" target="_blank" rel="noopener">http://introjs.com/</a></p><p>star：15K+<br><img src="https://raw.githubusercontent.com/SirM2z/assets/master/image/4.gif" alt="showpicture"></p><p>功能介绍：</p><blockquote><p>使用动画来一步步引导用户熟悉网站功能</p></blockquote><h2 id="whatwg-fetch-fetch-的-polyfill"><a href="#whatwg-fetch-fetch-的-polyfill" class="headerlink" title="whatwg-fetch - fetch 的 polyfill"></a>whatwg-fetch - fetch 的 polyfill</h2><p>github: <a href="https://github.com/github/fetch" target="_blank" rel="noopener">https://github.com/github/fetch</a></p><p>star: 15.6k+</p><p>功能介绍：</p><blockquote><p>fetch 的 polyfill,支持 IE10+</p></blockquote><h2 id="isomorphic-fetch-基于-whatwg-fetch-实现的前后端同构-fetch，同时支持-node-与-浏览器"><a href="#isomorphic-fetch-基于-whatwg-fetch-实现的前后端同构-fetch，同时支持-node-与-浏览器" class="headerlink" title="isomorphic-fetch - 基于 whatwg-fetch 实现的前后端同构 fetch，同时支持 node 与 浏览器"></a>isomorphic-fetch - 基于 whatwg-fetch 实现的前后端同构 fetch，同时支持 node 与 浏览器</h2><p>github：<a href="https://github.com/matthew-andrews/isomorphic-fetch" target="_blank" rel="noopener">https://github.com/matthew-andrews/isomorphic-fetch</a></p><p>star: 4.8K+</p><p>功能介绍：</p><blockquote><p>基于 whatwg-fetch 实现的前后端同构 fetch，同时支持 node 与 浏览器</p></blockquote><h2 id="detector-识别客户端环境"><a href="#detector-识别客户端环境" class="headerlink" title="detector - 识别客户端环境"></a>detector - 识别客户端环境</h2><p>github: <a href="https://github.com/hotoo/detector" target="_blank" rel="noopener">https://github.com/hotoo/detector</a></p><p>star: 600+</p><p>功能介绍：</p><blockquote><p>用于自动识别用户使用的客户端环境。包括硬件设备、操作系统、浏览器、浏览器渲染引擎</p></blockquote><h2 id="aframe-js-web端-VR引擎"><a href="#aframe-js-web端-VR引擎" class="headerlink" title="aframe.js - web端 VR引擎"></a>aframe.js - web端 VR引擎</h2><p>github: <a href="https://github.com/aframevr/aframe/" target="_blank" rel="noopener">https://github.com/aframevr/aframe/</a></p><p>官网：<a href="https://aframe.io/" target="_blank" rel="noopener">https://aframe.io/</a></p><p>star：6.2K+</p><p>功能介绍：</p><blockquote><p>在 web端实现 VR效果，包括 360°全景图片、视频等</p></blockquote><h2 id="Babylon-js-使用-HTML-5-and-WebGL构建-3D-的-javascript引擎"><a href="#Babylon-js-使用-HTML-5-and-WebGL构建-3D-的-javascript引擎" class="headerlink" title="Babylon.js - 使用 HTML 5 and WebGL构建 3D 的 javascript引擎"></a>Babylon.js - 使用 HTML 5 and WebGL构建 3D 的 javascript引擎</h2><p>github: <a href="https://github.com/BabylonJS/Babylon.js" target="_blank" rel="noopener">https://github.com/BabylonJS/Babylon.js</a></p><p>官网：<a href="http://www.babylonjs.com/" target="_blank" rel="noopener">http://www.babylonjs.com/</a></p><p>star: 5.3K+</p><p>功能介绍：</p><blockquote><p>使用 HTML 5 and WebGL构建 3D 的 javascript引擎</p></blockquote><h2 id="AlloyTouch-移动端触摸滑动方案"><a href="#AlloyTouch-移动端触摸滑动方案" class="headerlink" title="AlloyTouch 移动端触摸滑动方案"></a>AlloyTouch 移动端触摸滑动方案</h2><p>github: <a href="https://github.com/AlloyTeam/AlloyTouch" target="_blank" rel="noopener">https://github.com/AlloyTeam/AlloyTouch</a></p><p>star: 1.4K</p><p>功能介绍：</p><blockquote><p>触摸滑动，可用根据此插件扩展上拉和下拉刷新、轮播、VR等</p></blockquote><h2 id="highlight-js-javascript-web高亮"><a href="#highlight-js-javascript-web高亮" class="headerlink" title="highlight.js - javascript web高亮"></a>highlight.js - javascript web高亮</h2><p>github：<a href="https://github.com/isagalaev/highlight.js" target="_blank" rel="noopener">https://github.com/isagalaev/highlight.js</a></p><p>star:10k+</p><p>功能介绍：</p><blockquote><p>在网页中显示 <code>javascript</code>代码时，自动高亮语法</p></blockquote><h2 id="clipboard-js-现代浏览器复制到粘贴板的解决方案"><a href="#clipboard-js-现代浏览器复制到粘贴板的解决方案" class="headerlink" title="clipboard.js - 现代浏览器复制到粘贴板的解决方案"></a>clipboard.js - 现代浏览器复制到粘贴板的解决方案</h2><p>github: <a href="https://github.com/zenorocha/clipboard.js" target="_blank" rel="noopener">https://github.com/zenorocha/clipboard.js</a></p><p>star: 18K+</p><p>size: 3KB</p><p>功能介绍：</p><blockquote><p>浏览器端复制到粘贴板的方法存在着各种兼容性问题，此插件提供了开箱即用的解决方案，支持到 IE9+</p></blockquote><p><img src="https://cloud.githubusercontent.com/assets/398893/16165747/a0f6fc46-349a-11e6-8c9b-c5fd58d9099c.png" alt="showpicture"></p><h2 id="iview-vue-UI组件库"><a href="#iview-vue-UI组件库" class="headerlink" title="iview - vue UI组件库"></a>iview - vue UI组件库</h2><p>github: <a href="https://github.com/iview/iview" target="_blank" rel="noopener">https://github.com/iview/iview</a></p><p>star: 8.5K+</p><p>功能介绍：</p><blockquote><p>高质量的 vue UI组件库</p></blockquote><h2 id="ant-design-阿里巴巴开源的-react组件库"><a href="#ant-design-阿里巴巴开源的-react组件库" class="headerlink" title="ant-design - 阿里巴巴开源的 react组件库"></a>ant-design - 阿里巴巴开源的 react组件库</h2><p>github: <a href="https://github.com/ant-design/ant-design" target="_blank" rel="noopener">https://github.com/ant-design/ant-design</a></p><p>star: 16K+</p><p>功能介绍：</p><blockquote><p>阿里巴巴开源的 react组件库,支持现代浏览器和 IE9 及以上，支持服务端渲染，支持Electron</p></blockquote><h2 id="awesome-react-components-react-UI库列表"><a href="#awesome-react-components-react-UI库列表" class="headerlink" title="awesome-react-components - react UI库列表"></a>awesome-react-components - react UI库列表</h2><p>github：<a href="https://github.com/brillout/awesome-react-components" target="_blank" rel="noopener">https://github.com/brillout/awesome-react-components</a></p><p>官网：<a href="https://devarchy.com/react" target="_blank" rel="noopener">https://devarchy.com/react</a></p><p>star：9.7K+</p><p>功能介绍：</p><blockquote><p>这并不是一个具备什么功能或者效果的技术库，而是一个整合了 github上几乎所有可用的 react UI组件库的列表，在这个列表中，你可以找到几乎所有的 react UI组件，以及众多优秀或者小众的 react UI组件库项目</p></blockquote><h2 id="video-js-HTML5-amp-Flash-视频播放器"><a href="#video-js-HTML5-amp-Flash-视频播放器" class="headerlink" title="video.js - HTML5 &amp; Flash 视频播放器"></a>video.js - HTML5 &amp; Flash 视频播放器</h2><p>github: <a href="https://github.com/videojs/video.js" target="_blank" rel="noopener">https://github.com/videojs/video.js</a></p><p>官网：<a href="http://videojs.com/" target="_blank" rel="noopener">http://videojs.com/</a></p><p>star: 17k+</p><p>功能介绍：</p><blockquote><p>基于 HTML5的网络视频播放器，支持 HTML和 Flash，支持 PC和移动端</p></blockquote><h2 id="sizzy-网站响应式一键测试"><a href="#sizzy-网站响应式一键测试" class="headerlink" title="sizzy - 网站响应式一键测试"></a>sizzy - 网站响应式一键测试</h2><p>github：<a href="https://github.com/kitze/sizzy" target="_blank" rel="noopener">https://github.com/kitze/sizzy</a></p><p>star：4.5K+</p><p>功能介绍:</p><blockquote><p>同时展现出一个网页在多种设备下显示效果，包括 iphone4、5、6、7、7plus、iPad Air、Nexus6P等</p></blockquote><h2 id="Next-js-React服务端渲染应用框架"><a href="#Next-js-React服务端渲染应用框架" class="headerlink" title="Next.js - React服务端渲染应用框架"></a>Next.js - React服务端渲染应用框架</h2><p>github: <a href="https://github.com/zeit/next.js" target="_blank" rel="noopener">https://github.com/zeit/next.js</a></p><p>官网： <a href="https://zeit.co/blog/next3" target="_blank" rel="noopener">https://zeit.co/blog/next3</a></p><p>star：16K+</p><p>功能介绍：</p><blockquote><p>React服务端渲染 SSR应用框架，支持可选的服务端与客户端渲染功能，简单易用，安装这个框架会搭建一个基于React、Webpack和Babel的构建过程，也就是说脚手架已经预设了配置，开发人员不必在搭建Webpack或Babel配置上花费时间了。以往，这两个步骤就会耗费开发人员很多的时间。要运行某个站点的开发版本，只需运行npm run dev。</p></blockquote><h2 id="Nuxt-js-Vue的服务端渲染应用框架"><a href="#Nuxt-js-Vue的服务端渲染应用框架" class="headerlink" title="Nuxt.js - Vue的服务端渲染应用框架"></a>Nuxt.js - Vue的服务端渲染应用框架</h2><p>github: <a href="https://github.com/nuxt/nuxt.js" target="_blank" rel="noopener">https://github.com/nuxt/nuxt.js</a></p><p>官网： <a href="https://nuxtjs.org/" target="_blank" rel="noopener">https://nuxtjs.org/</a> 中文：<a href="https://zh.nuxtjs.org/" target="_blank" rel="noopener">https://zh.nuxtjs.org/</a></p><p>star: 6.3K+</p><p>功能介绍：</p><blockquote><p>Vue的服务端渲染应用框架，类别上面的 Next.js，发布时间紧随在 Next.js后面几个小时，同样预设了利用Vue.js开发服务端渲染的应用所需要的各种配置，并且还提供了一种命令叫：nuxt generate，为基于 Vue.js 的应用提供生成对应的静态站点的功能，作为框架，Nuxt.js 为 客户端/服务端 这种典型的应用架构模式提供了许多有用的特性，例如异步数据加载、中间件支持、布局支持等，最美妙的是，与 <code>Vue</code>一样，这东西有中文版，看着就亲切。</p></blockquote><h2 id="react-native-vector-icons-react-native-图标库"><a href="#react-native-vector-icons-react-native-图标库" class="headerlink" title="react-native-vector-icons - react-native 图标库"></a>react-native-vector-icons - react-native 图标库</h2><p>github: <a href="https://github.com/oblador/react-native-vector-icons" target="_blank" rel="noopener">https://github.com/oblador/react-native-vector-icons</a></p><p>star：5.8K+</p><p>功能介绍：</p><blockquote><p>react-native 图标库，整合了 Entypo、EvilIcons、FontAwesome、Foundation、Ionicons、MaterialCommunityIcons等图标库，支持 IOS和 Android</p></blockquote><h2 id="react-native-snap-carousel-react-native的-swiper组件"><a href="#react-native-snap-carousel-react-native的-swiper组件" class="headerlink" title="react-native-snap-carousel - react-native的 swiper组件"></a>react-native-snap-carousel - react-native的 swiper组件</h2><p>github：<a href="https://github.com/archriss/react-native-snap-carousel" target="_blank" rel="noopener">https://github.com/archriss/react-native-snap-carousel</a></p><p>star: 800+</p><p>功能介绍：</p><blockquote><p>react-native的 swiper组件</p></blockquote><p><img src="https://camo.githubusercontent.com/b28e01e8f8375cc148493242c5ae06f8bc8fba9e/687474703a2f2f692e696d6775722e636f6d2f4f6451555948532e676966" alt="showpicture"></p><h2 id="react-native-fs-react-native-文件操作插件"><a href="#react-native-fs-react-native-文件操作插件" class="headerlink" title="react-native-fs - react-native 文件操作插件"></a>react-native-fs - react-native 文件操作插件</h2><p>github：<a href="https://github.com/itinance/react-native-fs" target="_blank" rel="noopener">https://github.com/itinance/react-native-fs</a></p><p>star：1.3K+</p><p>功能介绍：</p><blockquote><p>react-native 文件操作插件，兼容 IOS 和 Android</p></blockquote><h2 id="react-navigation-react-native-导航插件"><a href="#react-navigation-react-native-导航插件" class="headerlink" title="react-navigation - react-native 导航插件"></a>react-navigation - react-native 导航插件</h2><p>github：<a href="https://github.com/react-community/react-navigation" target="_blank" rel="noopener">https://github.com/react-community/react-navigation</a></p><p>star：6.4K+</p><p>功能介绍：</p><blockquote><p>react-native 导航插件，react-native 社区出品，易用，统一 IOS 和 Android间的导航操作，用于替代 react-native官方提供的导航API</p></blockquote><h2 id="react-native-action-view"><a href="#react-native-action-view" class="headerlink" title="react-native-action-view"></a>react-native-action-view</h2><p>github：<a href="https://github.com/wix/react-native-action-view" target="_blank" rel="noopener">https://github.com/wix/react-native-action-view</a></p><p>star: 50+</p><p>功能介绍：</p><blockquote><p>react-native类似于 微信 和 QQ好友列表的删除、置顶的操作，多种样式可选</p></blockquote><p><img src="https://raw.githubusercontent.com/MortimerGoro/MGSwipeTableCell/master/readme-assets/border.gif" alt="showpicture"></p><h2 id="react-native-svg-在react-native中使用-svg"><a href="#react-native-svg-在react-native中使用-svg" class="headerlink" title="react-native-svg - 在react-native中使用 svg"></a>react-native-svg - 在react-native中使用 svg</h2><p>github:<a href="https://github.com/react-native-community/react-native-svg" target="_blank" rel="noopener">https://github.com/react-native-community/react-native-svg</a></p><p>star：1.5K+</p><p>功能介绍：</p><blockquote><p>react-native社区出品，在react-native中使用 svg</p></blockquote><p><img src="https://raw.githubusercontent.com/react-native-community/react-native-svg/master/screenShoots/clip-path.png" alt="showpicture"></p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 收藏 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>learnGit</title>
      <link href="/2018/09/08/learnGit/"/>
      <url>/2018/09/08/learnGit/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前的Git配置</span>$ <span class="token function">git</span> config --list<span class="token comment" spellcheck="true"># 编辑Git配置文件</span>$ <span class="token function">git</span> config -e <span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置提交代码时的用户信息</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.name <span class="token string">"[name]"</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.email <span class="token string">"[email address]"</span></code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> add -p<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span></code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment" spellcheck="true"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span></code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span></code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@{0 day ago}"</span><span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>暂时将未提交的变化移除，稍后再移入$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成一个可供发布的压缩包</span>$ <span class="token function">git</span> archive</code></pre><blockquote><p>以上常用命令来自阮一峰老师的博客文章《常用 Git 命令清单》，感谢阮老师！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>js中的深浅拷贝</title>
      <link href="/2018/09/08/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/"/>
      <url>/2018/09/08/js%E4%B8%AD%E7%9A%84%E6%B7%B1%E6%B5%85%E6%8B%B7%E8%B4%9D/</url>
      
        <content type="html"><![CDATA[<ul><li>先贴代码</li></ul><h2 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h2><pre class=" language-js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">shallowCopy</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">in</span> oldObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                newObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> oldObj<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h2><pre class=" language-js"><code class="language-js">    <span class="token keyword">function</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">in</span> oldObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepCopy</span><span class="token punctuation">(</span>oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> oldObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h1 id="总结一下"><a href="#总结一下" class="headerlink" title="总结一下"></a>总结一下</h1><ul><li>首先深拷贝和浅拷贝只针对Object、Array这样的复杂对象。简单来说，浅拷贝只会将各个属性进行复制，不会进行递归复制，而JavaSript储存对象都是存的地址，所以浅拷贝中如果有子对象。就会和拷贝的那个 指向同一内存地址。而深拷贝则会开辟新的内存地址，从而不会因为一个的改变影响到另一个。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bable_learn</title>
      <link href="/2018/09/08/Bable-learn/"/>
      <url>/2018/09/08/Bable-learn/</url>
      
        <content type="html"><![CDATA[<h1 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h1><p>目的是为了 用es6的特性,所以用到Babel</p><h2 id="安装-babel-cli-不推荐全局安装"><a href="#安装-babel-cli-不推荐全局安装" class="headerlink" title="安装 babel-cli 不推荐全局安装"></a>安装 babel-cli <code>不推荐全局安装</code></h2><p> <code>npm install --save-dev/-D babel-cli</code></p><blockquote><p>注: 本地安装如果想用babel 需要到<code>./node_modules/.bin/babel</code>才可以使用，所以可以用npm的npx执行<code>npx babel</code>这里前缀加上npx可以自动去找.bin目录下的babel可执行文件. 如果没有就向上寻找如果全局也没有就会提示没有安装babel.</p></blockquote><h2 id="接着上一步-需要在项目跟目录创建-babelrc文件"><a href="#接着上一步-需要在项目跟目录创建-babelrc文件" class="headerlink" title="接着上一步 需要在项目跟目录创建 .babelrc文件"></a>接着上一步 需要在项目跟目录创建 <code>.babelrc</code>文件</h2><blockquote><p>推荐配置</p></blockquote><pre class=" language-json"><code class="language-json"><span class="token punctuation">{</span>  <span class="token property">"presets"</span><span class="token operator">:</span> <span class="token punctuation">[</span>    <span class="token string">"es2015"</span><span class="token punctuation">,</span>    <span class="token string">"stage-0"</span><span class="token punctuation">,</span>    //<span class="token string">"env"</span>  //env不仅可以转换es6，还可以转换es7\es8代码到es5  <span class="token punctuation">]</span><span class="token punctuation">,</span>  <span class="token property">"plugins"</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">"transform-runtime"</span><span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h2 id="babel-cli的用法"><a href="#babel-cli的用法" class="headerlink" title="babel-cli的用法"></a>babel-cli的用法</h2><ul><li><p>直接输出到控制台</p><pre><code>npx babel script.js</code></pre></li><li><p>单文件编译到单文件 用 <code>--out-file / -o</code></p><pre><code>npx babel script.js -o script-compiled.js</code></pre></li><li><p>监听同时编译单文件 <code>--watch / -w</code></p><pre><code>npx babel script.js -w -o script-compiled.js</code></pre></li><li><p>编译目录 <code>--out-dir / -d</code> 这不会覆盖其他文件或目录</p><pre><code>npx babel src -d dist</code></pre></li><li><p>编译目录到一个单文件中</p><pre><code>npx babel src -d script-compiled.js</code></pre></li><li><p>忽略文件 <code>--ignore</code></p></li></ul><blockquote><p>如忽略spec和test文件</p><pre><code>npx babel src -d lib --ignore spec.js,test.js</code></pre></blockquote><ul><li>复制文件</li></ul><blockquote><p>复制不需要编译的文件</p><pre><code>npx babel src --out-dir lib --copy-files</code></pre></blockquote><ul><li>传输文件</li></ul><blockquote><p>通过标准输入传入一个文件并输出到 <code>script-compiled.js</code></p><pre><code>npx babel --out-file script-compiled.js &lt; script.js</code></pre></blockquote><ul><li>使用插件</li></ul><blockquote><p>使用 <code>--plugins</code> 选项来指定编译中要使用的插件</p><pre><code>npx babel script.js --out-file script-compiled.js --plugins=transform-runtime,transform-es2015-modules-amd</code></pre></blockquote><ul><li>使用 Presets</li></ul><blockquote><p>使用 <code>--presets</code> 选项指定编译中要使用的插件</p><pre><code>npx babel script.js --out-file script-compiled.js --presets=es2015,react</code></pre></blockquote><ul><li>忽略 .babelrc 文件</li></ul><blockquote><p>忽略项目中 <code>.babelrc</code> 文件的配置并使用 cli 选项，例如，为一个自定义的构建</p><pre><code>npx babel --no-babelrc script.js --out-file script-compiled.js --presets=es2015,react</code></pre></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> es6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL浅析</title>
      <link href="/2018/09/01/URL-summary/"/>
      <url>/2018/09/01/URL-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h2><blockquote><p>协议 + 域名或IP + 端口号 + 路径 + 查询字符串 + 锚点</p></blockquote><p>如： <code>https://www.baidu.com/s?wd=hello&amp;rsv_sp=1#6</code></p><p>域名后边的<code>#锚点</code>的内容是无法发送给服务器的</p><p>锚点看起来有中文，实际上不支持中文</p><h3 id="什么是IP"><a href="#什么是IP" class="headerlink" title="什么是IP"></a>什么是IP</h3><blockquote><p>IP: Internet Protocal (协议)</p></blockquote><p>主要约定了两件事: </p><ol><li>如何定位一台设备</li><li>如何封装数据报文, 已跟其他设备交流</li></ol><p>只要你在互联网中, <strong>你就至少拥有一个独特的IP</strong></p><h3 id="外网IP和内网IP"><a href="#外网IP和内网IP" class="headerlink" title="外网IP和内网IP"></a>外网IP和内网IP</h3><p>IP地址相当于电脑在网络上的身份证，但事实上IP地址却没有想象中那么简单，IP也分很多种，比如经常提到内网IP和外网IP。</p><p>以家中接入外网的路由为中心，家中所有使用路由器的设备，他们大多数以192、172、10开头的IP，经过路由器之后才连到外网的。<br>路由以内的叫内网，路由以外的叫外网。</p><p>注意: </p><ol><li>同一内网中的设备可以相互访问, 但是不能直接访问外网</li><li>外网中的设备可以互相访问, 但是无法访问你的内网</li><li>内网和外网就像是两个隔绝的空间, 无法想通, 唯一的联通点就是路由器</li></ol><h4 id="几个特殊的IP"><a href="#几个特殊的IP" class="headerlink" title="几个特殊的IP"></a>几个特殊的IP</h4><ul><li><code>127.0.0.1</code>表示自己</li><li><code>localhost</code>通过hosts指定为自己</li><li><code>0.0.0.0</code>不表示任何设备</li></ul><p>IP一般是自动获取, 遇到DNS挂掉的情况,可以设置为 <code>114.114.114.114</code>这也是电信提供的</p><h3 id="路由器的功能"><a href="#路由器的功能" class="headerlink" title="路由器的功能"></a>路由器的功能</h3><blockquote><p>路由器有时也被称为往<code>网关</code></p></blockquote><ol><li>内网设备想要访问外网,就必须经过路由器中转</li><li>外网设备想要把内容送到内网, 也必须通过路由器</li></ol><h3 id="端口-port"><a href="#端口-port" class="headerlink" title="端口 port"></a>端口 port</h3><p>一台机器可以提供很多服务, 每个服务一个号码, 这个号码就叫端口号</p><ul><li>要提供HTTP服务最好使用80端口</li><li>要提供HTTPS服务最好使用443端口</li><li>要提供FTP服务最好使用21端口</li><li>一共有65535个端口(基本够用)</li></ul><h4 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h4><ul><li>0-1023端口号是留给系统使用的</li><li>只有拥有管理员权限后才能使用者1024个端口</li><li>其他端口可以给普通用户使用</li><li>一个端口如果被占用，你就只能换一个端口</li></ul><p>总之IP和端口缺一不可</p><h3 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h3><blockquote><p>域名就是对IP的别称</p></blockquote><p>在命令行中用 中<code>ping</code>可以看到对应域名的IP</p><p>注意： </p><ul><li><p>一个域名可以对应不同IP，这叫负载均衡，防止一台机器扛不住</p></li><li><p>一个IP可以对应不同域名，这个叫共享主机</p></li><li><p><code>www.xxx.com</code>和<code>xxx.com</code>不是同一个域名</p></li><li><p><code>com</code>是顶级域名</p></li><li><p><code>xxx.com</code>是二级域名（俗称一级域名）</p></li><li><p><code>www.xxx.com</code>是三级域名（俗称二级）</p></li><li><p>他们是父子关系，他们可以是同一家公司的也可以不是</p></li></ul><h4 id="IP和域名如何对应"><a href="#IP和域名如何对应" class="headerlink" title="IP和域名如何对应"></a>IP和域名如何对应</h4><blockquote><p>通过DNS</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flexBox</title>
      <link href="/2018/07/08/flexBox/"/>
      <url>/2018/07/08/flexBox/</url>
      
        <content type="html"><![CDATA[<p>###flexBox 弹性盒子 by <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/" target="_blank" rel="noopener">$css-stricks</a></p><hr><h4 id="1-flex的兼用性"><a href="#1-flex的兼用性" class="headerlink" title="1.flex的兼用性"></a>1.flex的兼用性</h4><p>lex布局是不支持ie8，9的，所以建议，如果要做兼容ie8的pc端项目，还是老老实实用浮动布局吧~！但是现在是H5的时代，移动端我们还是放心大胆用吧，请抛弃恶心的清除浮动！</p><h4 id="2-语法速记"><a href="#2-语法速记" class="headerlink" title="2.语法速记"></a>2.语法速记</h4><p> 作用的对象：</p><blockquote><p>container父级 说明：(d) 表示 默认</p></blockquote><ul><li>添加flex属性：<br><code>display: flex/line-flex;</code></li><li>确定主轴方向：<br><code>flex-direction: row(d) | row-reverse | column | column-reverse</code></li><li>换行方式：<br><code>flex-wrap: nowrap(d) | wrap | wrap-reverse</code></li><li>主轴和换行结合:<br><code>flex-flow: &lt;&#39;flex-direction&#39;&gt; || &lt;&#39;flex-wrap&#39;&gt;</code>。默认是 <code>flex-flow: row nowrap</code></li><li>沿主轴的对齐方式：<br><code>justify-content: flex-start(d) | flex-end |center | space-between | space-around | space-evenly</code></li><li>沿主轴项目的横向放置行为：<br><code>align-items: flex-start | flex-end | center | stretch(d) | baseline</code></li><li>当主轴横向有空余空间是，类似于横向的<code>justify-content</code>:对于只有一行的不起作用<br><code>align-content: flex-start | flex-end | center | stretch(d) | space-between | space-around</code></li></ul><blockquote><p>item 子级 ——– 请注意float，clear并且vertical-align对Flex项目没有影响</p></blockquote><ul><li>order属性：（0是默认）order从小到大排列<br><code>order: &lt;integer&gt;</code></li><li>flex-grow属性：(0是默认,负数无效)item的必要的增长能力，如果一个设为2，其余的设为1，则设置为2的占据的大小是1的2倍。<br><code>flex-grow: &lt;number&gt;</code></li><li>flex-shrinks属性：(1是默认,负数无效) 和 flex-grow相反。是一种收缩能力<br><code>flex-shrinks:&lt;number&gt;</code></li><li>分配剩余空间之前定义元素的默认大小:如果设置为0，则不会考虑内容的额外空间。如果设置为auto，多余空间将根据其flex-grow值分配<br><code>flex-basis: &lt;length&gt; | auto(d)</code></li><li>flex属性：是flex-grow | flex-shrinks | flex-basis 的结合.第二个和第三个属性时可选的。默认是：<code>0 1 auto</code><br><code>flex: none | [ &lt;&#39;flex-grow&#39;&gt; &lt;&#39;flex-shrink&#39;&gt;? || &lt;&#39;flex-basis&#39;&gt; ]</code></li><li>align-self属性：可以用单独的属性。覆盖默认对齐方式<br><code>align-self: align-self: auto | flex-start | flex-end | center | baseline | stretch;</code></li></ul><h4 id="3-详解"><a href="#3-详解" class="headerlink" title="3.详解"></a>3.详解</h4><p>by – <a href="https://blog.csdn.net/lc941015/article/details/79098933" target="_blank" rel="noopener">CSND</a></p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.box</span></span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/* flex布局第一步：找到你要布局元素的父元素 */</span>    <span class="token property">display</span><span class="token punctuation">:</span>flex<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 第二步：判断方向：元素是横着排还是竖着排，默认为横着排，当项目空间不够时，是否换行 */</span>    <span class="token property">flex-direction</span><span class="token punctuation">:</span> row（横向） | column（纵向）<span class="token punctuation">;</span>    <span class="token property">flex-wrap</span><span class="token punctuation">:</span><span class="token function">nowrap</span><span class="token punctuation">(</span>默认不换行<span class="token punctuation">)</span> | wrap （换行，新元素在下面一行） | wrap-reverse（换行，新元素在上面一行）    <span class="token comment" spellcheck="true">/* 第三步：根据方向，进行布局操作,注意敲黑板啦        当为横向时，水平布局的操作用justify-content属性，垂直方向的操作用align-items属性；        当为纵向时，两属性的作用正好相反，水平布局的操作用align-items属性，垂直方向的操作用justify-content属性；        以上两个属性是用的最多的属性了。    */</span>    <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start | flex-end | center | space-between | space-around<span class="token punctuation">;</span>    <span class="token property">align-items</span><span class="token punctuation">:</span> flex-start | flex-end | center | baseline | stretch<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="justify-content-和-align-items-属性（设置到父元素）"><a href="#justify-content-和-align-items-属性（设置到父元素）" class="headerlink" title="justify-content 和 align-items 属性（设置到父元素）"></a>justify-content 和 align-items 属性（设置到父元素）</h4><ul><li>justify-content: flex-start 相当于左浮动</li><li>justify-content: flex-end 相当于右浮动，具体不赘述，同上</li><li>justify-content: center 让某个元素水平居中</li><li>justify-content: space-between 这个就非常好用的 ，两个子元素情况下，一个元素左对齐，一个元素右对齐。三个元素情况下就无敌了，能实现一个元素居中，一个元素左对齐，一个元素右对齐。放以前，中间居中的都不知道有多麻烦。</li><li>justify-content: space-around 每个子元素两侧的间距都相等，且为项目到边框距离的两倍。</li><li>align-items: flex-start 垂直方向的 上对齐。</li><li>align-items: flex-end 垂直方向的 下对齐。</li><li>align-items：center 最好用的竖直居中</li><li>align-items：stretch 如果元素没设置高的话，高度将与父元素相等（铺满整个元素）</li><li>align-items：baseline 与元素第一行文字的头对齐，我暂时没找到用此属性的地方</li></ul><h4 id="设置到子元素的常用属性："><a href="#设置到子元素的常用属性：" class="headerlink" title="设置到子元素的常用属性："></a>设置到子元素的常用属性：</h4><ul><li>order: 设置排序的，数值越小，元素越靠前（用的不多）</li><li>flex-grow: 设置项目的放大比例 有点栅格化布局的意思 比如三个子元素，全部设置 flex-grow: 1 则在父元素内 宽度都相等 （3等分）</li><li>flex-shrink：设置项目的缩小比例，当空间不足时，所有项目会默认等比例缩小。当设置flex-shrink:0 时，当空间不足时元素也不会缩小</li><li>注意 ：若设置了元素的宽度,还有设置 flex-shrink:0 ，否则项目空间不足时，元素会缩小，设置的宽度就不生效了</li><li>flex-basis：百分比或者像素，当项目空间充足时，给子元素设置一个默认的宽度，默认auto（项目的本来大小）</li><li>align-self：这个属性呢，就是单元素版的align-items（设置后，所有子元素都会生效），但如果只想让一个元素居中，就设置改元素align-self：center</li></ul><h4 id="4-flex布局常用demo"><a href="#4-flex布局常用demo" class="headerlink" title="4.flex布局常用demo"></a>4.flex布局常用demo</h4><p>1.带有icon的标题,icon居中</p><pre class=" language-css"><code class="language-css"><span class="token selector"><span class="token class">.title</span></span><span class="token punctuation">{</span>      <span class="token property">margin-top</span><span class="token punctuation">:</span><span class="token number">20</span>px<span class="token punctuation">;</span>      <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>      <span class="token property">width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span>      <span class="token property">justify-content</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>      <span class="token property">align-items</span><span class="token punctuation">:</span> center<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><p>2.左中右布局，左边右定宽，中间部分自适应。</p><pre class=" language-css"><code class="language-css">    在父元素中设置 <span class="token property">justify-content</span><span class="token punctuation">:</span> space-between<span class="token punctuation">;</span>在左右子元素中设置<span class="token property">flex-shrink</span><span class="token punctuation">:</span><span class="token number">0</span><span class="token punctuation">(</span>防止空间不足时缩小<span class="token punctuation">)</span><span class="token punctuation">;</span>在中间元素下设置<span class="token property">flex-grow</span><span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">(</span>让它撑满中间区域<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>3.input输入框跟不定长的label撑满一行</p><pre class=" language-css"><code class="language-css">其实跟上面要使用的方法差不多，将父元素设置<span class="token property">justify-content</span><span class="token punctuation">:</span> space-between，将要固定的元素<span class="token punctuation">(</span>label<span class="token punctuation">)</span>设置<span class="token property">flex-shrink</span><span class="token punctuation">:</span><span class="token number">0</span>，将要铺满的元素<span class="token punctuation">(</span>input<span class="token punctuation">)</span>设置<span class="token property">flex-grow</span><span class="token punctuation">:</span><span class="token number">1</span>。</code></pre><p>4.流式布局（一排放4个，放不下就换行）</p><pre class=" language-css"><code class="language-css">  <span class="token selector"><span class="token class">.flow</span></span><span class="token punctuation">{</span>      <span class="token property">display</span><span class="token punctuation">:</span> flex<span class="token punctuation">;</span>      <span class="token property">flex-wrap</span><span class="token punctuation">:</span>wrap<span class="token punctuation">;</span>      <span class="token property">justify-content</span><span class="token punctuation">:</span> flex-start<span class="token punctuation">;</span>      <span class="token property">border</span><span class="token punctuation">:</span><span class="token number">1</span>px solid <span class="token hexcode">#e3e3e3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token selector"><span class="token class">.flow</span> <span class="token class">.item</span></span><span class="token punctuation">{</span>      <span class="token property">flex</span><span class="token punctuation">:</span><span class="token number">0</span> <span class="token number">0</span> <span class="token number">22%</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/*        等同于        flex-grow: 0;        flex-shrink:0 ;        flex-basis:22%;      */</span>      <span class="token property">padding-bottom</span><span class="token punctuation">:</span> <span class="token number">22%</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* 做到宽高相等 */</span>      <span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">1.5%</span><span class="token punctuation">;</span>      <span class="token property">background</span><span class="token punctuation">:</span> yellow<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> css </tag>
            
            <tag> flex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最全的Git常用命令清单</title>
      <link href="/2018/07/01/%E6%9C%80%E5%85%A8%E7%9A%84Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/"/>
      <url>/2018/07/01/%E6%9C%80%E5%85%A8%E7%9A%84Git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%B8%85%E5%8D%95/</url>
      
        <content type="html"><![CDATA[<h1 id="Git常用命令"><a href="#Git常用命令" class="headerlink" title="Git常用命令"></a>Git常用命令</h1><h2 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 在当前目录新建一个Git代码库</span>$ <span class="token function">git</span> init<span class="token comment" spellcheck="true"># 新建一个目录，将其初始化为Git代码库</span>$ <span class="token function">git</span> init <span class="token punctuation">[</span>project-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 下载一个项目和它的整个代码历史</span>$ <span class="token function">git</span> clone <span class="token punctuation">[</span>url<span class="token punctuation">]</span></code></pre><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示当前的Git配置</span>$ <span class="token function">git</span> config --list<span class="token comment" spellcheck="true"># 编辑Git配置文件</span>$ <span class="token function">git</span> config -e <span class="token punctuation">[</span>--global<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 设置提交代码时的用户信息</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.name <span class="token string">"[name]"</span>$ <span class="token function">git</span> config <span class="token punctuation">[</span>--global<span class="token punctuation">]</span> user.email <span class="token string">"[email address]"</span></code></pre><h2 id="增加-删除文件"><a href="#增加-删除文件" class="headerlink" title="增加/删除文件"></a>增加/删除文件</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 添加指定文件到暂存区</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 添加指定目录到暂存区，包括子目录</span>$ <span class="token function">git</span> add <span class="token punctuation">[</span>dir<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 添加当前目录的所有文件到暂存区</span>$ <span class="token function">git</span> add <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 添加每个变化前，都会要求确认</span><span class="token comment" spellcheck="true"># 对于同一个文件的多处变化，可以实现分次提交</span>$ <span class="token function">git</span> add -p<span class="token comment" spellcheck="true"># 删除工作区文件，并且将这次删除放入暂存区</span>$ <span class="token function">git</span> <span class="token function">rm</span> <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.<span class="token comment" spellcheck="true"># 停止追踪指定文件，但该文件会保留在工作区</span>$ <span class="token function">git</span> <span class="token function">rm</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 改名文件，并且将这个改名放入暂存区</span>$ <span class="token function">git</span> <span class="token function">mv</span> <span class="token punctuation">[</span>file-original<span class="token punctuation">]</span> <span class="token punctuation">[</span>file-renamed<span class="token punctuation">]</span></code></pre><h2 id="代码提交"><a href="#代码提交" class="headerlink" title="代码提交"></a>代码提交</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 提交暂存区到仓库区</span>$ <span class="token function">git</span> commit -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交暂存区的指定文件到仓库区</span>$ <span class="token function">git</span> commit <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>. -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交工作区自上次commit之后的变化，直接到仓库区</span>$ <span class="token function">git</span> commit -a<span class="token comment" spellcheck="true"># 提交时显示所有diff信息</span>$ <span class="token function">git</span> commit -v<span class="token comment" spellcheck="true"># 使用一次新的commit，替代上一次提交</span><span class="token comment" spellcheck="true"># 如果代码没有任何新变化，则用来改写上一次commit的提交信息</span>$ <span class="token function">git</span> commit --amend -m <span class="token punctuation">[</span>message<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重做上一次commit，并包括指定文件的新变化</span>$ <span class="token function">git</span> commit --amend <span class="token punctuation">[</span>file1<span class="token punctuation">]</span> <span class="token punctuation">[</span>file2<span class="token punctuation">]</span> <span class="token punctuation">..</span>.</code></pre><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有本地分支</span>$ <span class="token function">git</span> branch<span class="token comment" spellcheck="true"># 列出所有远程分支</span>$ <span class="token function">git</span> branch -r<span class="token comment" spellcheck="true"># 列出所有本地分支和远程分支</span>$ <span class="token function">git</span> branch -a<span class="token comment" spellcheck="true"># 新建一个分支，但依然停留在当前分支</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，并切换到该分支</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，指向指定commit</span>$ <span class="token function">git</span> branch <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个分支，与指定的远程分支建立追踪关系</span>$ <span class="token function">git</span> branch --track <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到指定分支，并更新工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 切换到上一个分支</span>$ <span class="token function">git</span> checkout -<span class="token comment" spellcheck="true"># 建立追踪关系，在现有分支与指定的远程分支之间</span>$ <span class="token function">git</span> branch --set-upstream <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>remote-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 合并指定分支到当前分支</span>$ <span class="token function">git</span> merge <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 选择一个commit，合并进当前分支</span>$ <span class="token function">git</span> cherry-pick <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除分支</span>$ <span class="token function">git</span> branch -d <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程分支</span>$ <span class="token function">git</span> push origin --delete <span class="token punctuation">[</span>branch-name<span class="token punctuation">]</span>$ <span class="token function">git</span> branch -dr <span class="token punctuation">[</span>remote/branch<span class="token punctuation">]</span></code></pre><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 列出所有tag</span>$ <span class="token function">git</span> tag<span class="token comment" spellcheck="true"># 新建一个tag在当前commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个tag在指定commit</span>$ <span class="token function">git</span> tag <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除本地tag</span>$ <span class="token function">git</span> tag -d <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 删除远程tag</span>$ <span class="token function">git</span> push origin :refs/tags/<span class="token punctuation">[</span>tagName<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 查看tag信息</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交指定tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 提交所有tag</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --tags<span class="token comment" spellcheck="true"># 新建一个分支，指向某个tag</span>$ <span class="token function">git</span> checkout -b <span class="token punctuation">[</span>branch<span class="token punctuation">]</span> <span class="token punctuation">[</span>tag<span class="token punctuation">]</span></code></pre><h2 id="查看信息"><a href="#查看信息" class="headerlink" title="查看信息"></a>查看信息</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 显示有变更的文件</span>$ <span class="token function">git</span> status<span class="token comment" spellcheck="true"># 显示当前分支的版本历史</span>$ <span class="token function">git</span> log<span class="token comment" spellcheck="true"># 显示commit历史，以及每次commit发生变更的文件</span>$ <span class="token function">git</span> log --stat<span class="token comment" spellcheck="true"># 搜索提交历史，根据关键词</span>$ <span class="token function">git</span> log -S <span class="token punctuation">[</span>keyword<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，每个commit占据一行</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --pretty<span class="token operator">=</span>format:%s<span class="token comment" spellcheck="true"># 显示某个commit之后的所有变动，其"提交说明"必须符合搜索条件</span>$ <span class="token function">git</span> log <span class="token punctuation">[</span>tag<span class="token punctuation">]</span> HEAD --grep feature<span class="token comment" spellcheck="true"># 显示某个文件的版本历史，包括文件改名</span>$ <span class="token function">git</span> log --follow <span class="token punctuation">[</span>file<span class="token punctuation">]</span>$ <span class="token function">git</span> whatchanged <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示指定文件相关的每一次diff</span>$ <span class="token function">git</span> log -p <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示过去5次提交</span>$ <span class="token function">git</span> log -5 --pretty --oneline<span class="token comment" spellcheck="true"># 显示所有提交过的用户，按提交次数排序</span>$ <span class="token function">git</span> shortlog -sn<span class="token comment" spellcheck="true"># 显示指定文件是什么人在什么时间修改过</span>$ <span class="token function">git</span> blame <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示暂存区和工作区的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span><span class="token comment" spellcheck="true"># 显示暂存区和上一个commit的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> --cached <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示工作区与当前分支最新commit之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> HEAD<span class="token comment" spellcheck="true"># 显示两次提交之间的差异</span>$ <span class="token function">git</span> <span class="token function">diff</span> <span class="token punctuation">[</span>first-branch<span class="token punctuation">]</span><span class="token punctuation">..</span>.<span class="token punctuation">[</span>second-branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示今天你写了多少行代码</span>$ <span class="token function">git</span> <span class="token function">diff</span> --shortstat <span class="token string">"@{0 day ago}"</span><span class="token comment" spellcheck="true"># 显示某次提交的元数据和内容变化</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交发生变化的文件</span>$ <span class="token function">git</span> show --name-only <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示某次提交时，某个文件的内容</span>$ <span class="token function">git</span> show <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>:<span class="token punctuation">[</span>filename<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示当前分支的最近几次提交</span>$ <span class="token function">git</span> reflog</code></pre><h2 id="远程同步"><a href="#远程同步" class="headerlink" title="远程同步"></a>远程同步</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 下载远程仓库的所有变动</span>$ <span class="token function">git</span> fetch <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 显示所有远程仓库</span>$ <span class="token function">git</span> remote -v<span class="token comment" spellcheck="true"># 显示某个远程仓库的信息</span>$ <span class="token function">git</span> remote show <span class="token punctuation">[</span>remote<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 增加一个新的远程仓库，并命名</span>$ <span class="token function">git</span> remote add <span class="token punctuation">[</span>shortname<span class="token punctuation">]</span> <span class="token punctuation">[</span>url<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 取回远程仓库的变化，并与本地分支合并</span>$ <span class="token function">git</span> pull <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 上传本地指定分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> <span class="token punctuation">[</span>branch<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 强行推送当前分支到远程仓库，即使有冲突</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --force<span class="token comment" spellcheck="true"># 推送所有分支到远程仓库</span>$ <span class="token function">git</span> push <span class="token punctuation">[</span>remote<span class="token punctuation">]</span> --all</code></pre><h2 id="撤销"><a href="#撤销" class="headerlink" title="撤销"></a>撤销</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 恢复暂存区的指定文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复某个commit的指定文件到暂存区和工作区</span>$ <span class="token function">git</span> checkout <span class="token punctuation">[</span>commit<span class="token punctuation">]</span> <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 恢复暂存区的所有文件到工作区</span>$ <span class="token function">git</span> checkout <span class="token keyword">.</span><span class="token comment" spellcheck="true"># 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>file<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置暂存区与工作区，与上一次commit保持一致</span>$ <span class="token function">git</span> reset --hard<span class="token comment" spellcheck="true"># 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变</span>$ <span class="token function">git</span> reset <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致</span>$ <span class="token function">git</span> reset --hard <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 重置当前HEAD为指定commit，但保持暂存区和工作区不变</span>$ <span class="token function">git</span> reset --keep <span class="token punctuation">[</span>commit<span class="token punctuation">]</span><span class="token comment" spellcheck="true"># 新建一个commit，用来撤销指定commit</span><span class="token comment" spellcheck="true"># 后者的所有变化都将被前者抵消，并且应用到当前分支</span>$ <span class="token function">git</span> revert <span class="token punctuation">[</span>commit<span class="token punctuation">]</span>暂时将未提交的变化移除，稍后再移入$ <span class="token function">git</span> stash$ <span class="token function">git</span> stash pop</code></pre><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><pre class=" language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 生成一个可供发布的压缩包</span>$ <span class="token function">git</span> archive<span class="token comment" spellcheck="true"># 删除误初始化的git仓库使其变为正常状态</span>$ <span class="token function">rm</span> -rf .git</code></pre><blockquote><p>以上常用命令来自阮一峰老师的博客文章《常用 Git 命令清单》，感谢阮老师！</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>javascript中字符串的三个方法的对比slice,substring,substr</title>
      <link href="/2018/06/10/javascript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94slice-substring-substr/"/>
      <url>/2018/06/10/javascript%E4%B8%AD%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E4%B8%89%E4%B8%AA%E6%96%B9%E6%B3%95%E7%9A%84%E5%AF%B9%E6%AF%94slice-substring-substr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>slice，substring,substr三个函数都是截取字符串，但是对参数的处理有区别</p></blockquote><p><strong>参数处理相似的两个函数式slice和substring</strong></p><p>slice(start,end)和substring(start,end)</p><p>他们两个的end都是原字符串的索引，意思为截取到end（不包括end）位置的字符</p><p><strong>二者的区别是：</strong></p><p>slice中的start如果为负数，会从尾部算起，-1表示倒数第一个，-2表示倒数第2个，此时end必须为负数，并且是大于start的负数，否则返回空字符串</p><p>slice的end如果为负数，同样从尾部算起，如果其绝对值超过原字符串长度或者为0，返回空字符串</p><p>substring会取start和end中较小的值为start,二者相等返回空字符串，任何一个参数为负数被替换为0(即该值会成为start参数)</p><p><strong>而substr比较特殊</strong></p><p>substr的end参数表示，要截取的长度,若该参数为负数或0，都将返回空字符串</p>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动端知识点</title>
      <link href="/2018/05/24/learn-mobile/"/>
      <url>/2018/05/24/learn-mobile/</url>
      
        <content type="html"><![CDATA[<p>本文主要讲述刚接触移动端的开发人员可能遇到的一些坑。</p><h2 id="移动端的Click事件"><a href="#移动端的Click事件" class="headerlink" title="移动端的Click事件"></a>移动端的Click事件</h2><p>click事件，对于移动端的兼容性不是很好，有的设备上可能会失效问题。</p><p>有时候在由于一些原因，需要在 li 标签上添加点击事件，这时候使用click点击事件就可能会失灵。即点击非 a 链接或 button 按钮的时候，click事件不起作用。</p><p>click事件触发机制为：touchstart -&gt; touchend -&gt; click</p><p>解决方法：</p><h3 id="touchend"><a href="#touchend" class="headerlink" title="touchend"></a>touchend</h3><p>使用touchend代替click(不推荐)</p><pre class=" language-bash"><code class="language-bash">  <span class="token variable"><span class="token variable">$(</span>document<span class="token variable">)</span></span>.on<span class="token punctuation">(</span><span class="token string">'touchend'</span>,<span class="token string">'#btn'</span>,function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //add event code<span class="token punctuation">..</span>.  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>  touchend事件不推荐使用，因为：touchend事件在页面滚动时有个问题。在滚动完成后，如果当前触点的位置所指的元素绑定了touchend事件，这时便会触发该元素的touchend事件，造成误操作。</p><h3 id="tap"><a href="#tap" class="headerlink" title="tap"></a>tap</h3><p>使用tap代替click(常用，推荐)</p><p>这里有一个需要注意的地方，就是js的原生事件中是没有tap事件的，需要用jq框架或mui等框架封装的tap事件。</p><pre class=" language-bash"><code class="language-bash">  <span class="token variable"><span class="token variable">$(</span>document<span class="token variable">)</span></span>.on<span class="token punctuation">(</span><span class="token string">'tap'</span>,<span class="token string">'#btn'</span>,function<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    //add event code<span class="token punctuation">..</span>.  <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="css"><a href="#css" class="headerlink" title="css"></a>css</h3><p>给需要点击的标签添加CSS属性。</p><p>比如需要点击ul列表中的每个li项，可以给 li 添加 css 属性,使其支持click点击事件</p><pre class=" language-bash"><code class="language-bash">  ul <span class="token operator">></span> li <span class="token punctuation">{</span>cursor:pointer<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>  这个方法我这边使用目前没出现什么问题，不清楚具体的浏览器内核解析过程。</p><h2 id="移动端适配rem"><a href="#移动端适配rem" class="headerlink" title="移动端适配rem"></a>移动端适配rem</h2><p>移动端的适配一直以来，对开发人员就是一个比较难以解决的问题，我也只是把我接触过的适配方法写下来：</p><p>首先就是每个页面必须的声明部分</p><p>​``` bash</p><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">​```### 简单适配<p>适配代码需要放在css文件引入之前运行。css单位使用rem.</p><p>​<code>bashwindow.onload = function(){  /*720代表设计师给的设计稿的宽度，你的设计稿是多少，就写多少;100代表换算比例，这里写100是    为了以后好算,比如，你测量的一个宽度是100px,就可以写为1rem,以及1px=0.01rem等等*/  getRem(720,100)};window.onresize = function(){  getRem(720,100)};function getRem(pwidth,prem){  var html = document.getElementsByTagName(&quot;html&quot;)[0];  var oWidth = document.body.clientWidth || document.documentElement.clientWidth;  html.style.fontSize = oWidth/pwidth*prem + &quot;px&quot;;}​</code></p><h3 id="小米官网写法"><a href="#小米官网写法" class="headerlink" title="小米官网写法"></a>小米官网写法</h3><p>​<code>bash!function(n){  var e=n.document, //获取document  t=e.documentElement,  //获取根节点html  i=720,  //初始值720px  d=i/100,  //假设100px为1rem，那么720px为7.2rem  o=&quot;orientationchange&quot;in n?&quot;orientationchange&quot;:&quot;resize&quot;, //判断是否有改变横屏事件，没有的话用resize事件  a=function(){      var n=t.clientWidth||320; //获取手机屏幕宽度      n &gt; 720 &amp;&amp; (n=720), //手机屏幕宽度大于720px默认设置为720px，即最大宽度为720px       t.style.fontSize=n/d+&quot;px&quot;    //设置根元素的字体大小为手机屏幕宽度/7.2,为上面自己定义的，当然你可以定义成别的，8.2，9.4都行  };   e.addEventListener &amp;&amp; (n.addEventListener(o,a,!1), //判断是否有addeventlistener方法，如果有，就绑定上面判断的o事件  e.addEventListener(&quot;DOMContentLoaded&quot;,a,!1))    //绑定DOMContentLoaded事件}(window);​</code></p><h2 id="微信分享的缩略图和简介"><a href="#微信分享的缩略图和简介" class="headerlink" title="微信分享的缩略图和简介"></a>微信分享的缩略图和简介</h2><p>官方文档链接 <a href="https://mp.weixin.qq.com/wiki?t=resource/res_main&id=mp1421141115" target="_blank" rel="noopener">https://mp.weixin.qq.com/wiki?t=resource/res_main&amp;id=mp1421141115</a></p><p>声明shareWx方法</p><p>​``` bash<br>function shareWx(url,img,title,desc,callBack){<br>  $.ajax({<br>    url: ‘<strong>**</strong>‘, //获取微信公众平台的各种参数接口<br>    type: “POST”,<br>    data: {<br>      url: window.location.href,<br>      appid: “****” //微信公众号的appid<br>    },<br>    dataType: “json”,<br>    success: function (data) {<br>      if (data.nonceStr != null &amp;&amp; data.nonceStr != “”) {<br>        wx.config({<br>          debug: false, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。<br>          appId: data.appId, // 必填，公众号的唯一标识<br>          timestamp: data.timestamp, // 必填，生成签名的时间戳<br>          nonceStr: data.nonceStr, // 必填，生成签名的随机串<br>          signature: data.signature,// 必填，签名，见附录1<br>          jsApiList: [‘onMenuShareTimeline’, ‘onMenuShareAppMessage’, ‘hideAllNonBaseMenuItem’, ‘showMenuItems’,’addCard’] // 必填，需要使用的JS接口列表，所有JS接口列表见附录2<br>        });<br>        //分享链接的缩略图<br>        var imgUrl = img;<br>        //分享链接的链接地址<br>        var lineLink = url;<br>        //分享链接的描述信息<br>        var descContent = desc;<br>        //分享链接的标题<br>        var shareTitle = title;<br>        //一般为空就可以<br>        var appid = ‘’;<br>        //分享给好友<br>        wx.ready(function () {<br>          wx.onMenuShareTimeline({<br>            title: shareTitle, // 分享标题<br>            link: lineLink, // 分享链接<br>            imgUrl: imgUrl, // 分享图标<br>            success: function () {<br>              // 用户确认分享后执行的回调函数<br>              if(typeof callBack == “function”){<br>                callBack();<br>              }<br>            },<br>            cancel: function () {<br>              // 用户取消分享后执行的回调函数<br>            }<br>          });<br>          wx.onMenuShareAppMessage({<br>            title: shareTitle, // 分享标题<br>            desc: descContent, // 分享描述<br>            link: lineLink, // 分享链接<br>            imgUrl: imgUrl, // 分享图标<br>            type: ‘’, // 分享类型,music、video或link，不填默认为link<br>            dataUrl: ‘’, // 如果type是music或video，则要提供数据链接，默认为空<br>            success: function () {<br>              // 用户确认分享后执行的回调函数<br>              if(typeof callBack == “function”){<br>                callBack();<br>              }<br>            },<br>            cancel: function () {<br>              // 用户取消分享后执行的回调函数<br>            }<br>          });<br>          wx.hideAllNonBaseMenuItem();<br>          wx.showMenuItems({<br>            menuList: [‘menuItem:share:appMessage’,’menuItem:share:timeline’] // 要显示的菜单项，所有menu项见附录3<br>          });<br>        });</p><pre><code>    wx.error(function (res) {      //alert(&quot;验证不通过&quot;);      // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。    });  }}</code></pre><p>  });<br>}<br>​```</p><p>调用分享的方法，调用前需要在页面先引入微信官方提供的js</p><p>​``` bash<br>// 页面引入</p><script src="//res.wx.qq.com/open/js/jweixin-1.0.0.js"></script>  //页面引入js文件<p>// 调用方法<br>var url = “<strong>*”;    //分享链接的URL<br>var img = “test.jpg”; //分享的缩略图<br>var title = “*</strong>“;    //分享链接的标题<br>var content = “****”; //分享链接的描述信息<br>shareWx(url, img, title, content);  //调用方法<br>​```</p><p>附录1：<a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.3462185509276481#62" target="_blank" rel="noopener">JS-SDK使用权限签名算法</a><br>附录2：<a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.3462185509276481#63" target="_blank" rel="noopener">所有JS接口列表</a><br>附录3：<a href="https://mp.weixin.qq.com/wiki?action=doc&id=mp1421141115&t=0.3462185509276481#64" target="_blank" rel="noopener">所有菜单项列表</a></p><h2 id="video视频播放问题"><a href="#video视频播放问题" class="headerlink" title="video视频播放问题"></a>video视频播放问题</h2><p>有的视频，使用video标签播放的时候，Android端可以播放，但IOS端有时候不能播放视频。</p><p>可以转换为 .mp4 格式。</p><p>不过有时候 .mp4 格式可能也会无法播放，这是因为 mp4 格式中，视频编码方式也需要设置正确。</p><p>这里我用【格式工厂】软件来说明。</p><p>格式工厂 -&gt; mp4 -&gt; 输出配置 -&gt; 视频编码:AVC(H264)</p><h2 id="清除微信H5缓存"><a href="#清除微信H5缓存" class="headerlink" title="清除微信H5缓存"></a>清除微信H5缓存</h2><p>之前在调试开发的过程中，遇到一个问题，就是：无论怎样刷新微信页面，或者重启web服务器，都无法清除缓存的css和js数据。</p><p>现在推荐2种不同手机的清除缓存方法，用来清除微信浏览器缓存。</p><h3 id="IOS端"><a href="#IOS端" class="headerlink" title="IOS端"></a>IOS端</h3><ul><li>IOS端浏览器内置的刷新，貌似可以清除css和js缓存，我这边测试的时候，是可以清除缓存的。</li><li>IOS端：我 -&gt; 设置 -&gt; 通用 -&gt; 微信存储空间 -&gt; 清理微信缓存。即可清除缓存。</li></ul><p><em>今天(2018/06/29)遇到了点击“清理微信缓存”后，返回去查看页面还是没有变化的问题，后来多点了几次页面右上角的刷新，就解决了。</em></p><h3 id="Android端"><a href="#Android端" class="headerlink" title="Android端"></a>Android端</h3><p>在微信浏览器访问 <a href="http://debugx5.qq.com" target="_blank" rel="noopener">http://debugx5.qq.com</a> (X5 调试页面)，然后滚动到页面最下面。</p><p>勾选 Cookie, 文件缓存, 广告过滤缓存, DNS缓存 ,然后点击右侧的 “清除” 按钮。即可清除缓存。</p><p><em>注意：此方法不适用于IOS端。</em></p><h2 id="微信H5的a链接点击失灵"><a href="#微信H5的a链接点击失灵" class="headerlink" title="微信H5的a链接点击失灵"></a>微信H5的a链接点击失灵</h2><p>微信内置浏览器的 a 链接，来回跳转几次就出现了跳转加载进度条，但是就是不跳转，也没有任何反应的情况。</p><p>解决办法：</p><p>给 a 链接的 href 属性添加任意参数，例如：</p><p>​<code>bash&lt;a href=&quot;www.baidu.com?2018&quot;&gt;&lt;/a&gt;​</code></p><p>就可以解决 a 链接不跳转的问题。</p><h2 id="IOS端长按屏幕变暗"><a href="#IOS端长按屏幕变暗" class="headerlink" title="IOS端长按屏幕变暗"></a>IOS端长按屏幕变暗</h2><p>IOS端的微信H5页面，有时候长按 div 或带有 background-image 的时候，屏幕会变暗.</p><p>解决办法：</p><p>给CSS添加以下属性：</p><p>​``` bash</p><ul><li>{ -webkit-tap-highlight-color:transparent;}<br>​```<br>即可解决上述问题。</li></ul><h2 id="audio音乐标签的方法调用"><a href="#audio音乐标签的方法调用" class="headerlink" title="audio音乐标签的方法调用"></a>audio音乐标签的方法调用</h2><p>使用jq或者zepto时，想要调用音乐的play()方法时，发现 $(“#audio”).play(); 不起作用，并且报错 play()方法 undefined。</p><p>解决办法：</p><p>使用原生document方法即可调用</p><p>​<code>bashvar audio = document.getElementById(&#39;audio&#39;);audio.play();audio.stop();​</code></p><h2 id="IOS的alert弹窗有域名"><a href="#IOS的alert弹窗有域名" class="headerlink" title="IOS的alert弹窗有域名"></a>IOS的alert弹窗有域名</h2><p>微信内置的H5浏览器，在IOS端的alert()弹框会带上域名，很影响页面美观。在Android端不会带上域名。</p><p>解决办法:</p><p>在js中加上如下代码，重置window的alert()方法。</p><p>​<code>bashwindow.alert = function(name){  var iframe = document.createElement(&quot;IFRAME&quot;);  iframe.style.display=&quot;none&quot;;  iframe.setAttribute(&quot;src&quot;, &#39;data:text/plain,&#39;);  document.documentElement.appendChild(iframe);  window.frames[0].window.alert(name);  iframe.parentNode.removeChild(iframe);};​</code></p><h2 id="IOS的H5页面text-decoration无效"><a href="#IOS的H5页面text-decoration无效" class="headerlink" title="IOS的H5页面text-decoration无效"></a>IOS的H5页面text-decoration无效</h2><p>微信内置的H5浏览器，在IOS端CSS中的 text-decoration 属性不生效，在Android端显示正常。</p><p>解决办法：</p><p>添加 -webkit- 前缀</p><p>​<code>bash.test{  -webkit-text-decoration: underline solid #fff;  text-decoration: underline solid #fff;}​</code></p><hr><p>以上是我在开发过程中遇到的问题，后续再更新。。。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前端跨域的解决方法</title>
      <link href="/2018/05/14/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/"/>
      <url>/2018/05/14/%E5%89%8D%E7%AB%AF%E8%B7%A8%E5%9F%9F%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是跨域"><a href="#什么是跨域" class="headerlink" title="什么是跨域 ?"></a>什么是跨域 ?</h2><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源, 这里跨域是广义的.</p><p>广义的跨域:</p><ol><li>资源跳转：a链接、重定向、表单提交</li><li>资源嵌入： <link>、<script>、<img>、<frame>等DOM标签， 还有样式中的 background: url()、@font-face()等文件外链</li><li>脚本请求：js发起的ajax请求、dom和js对象的跨域操作等</li></ol><p>其实我们通常所说的跨域是侠义的，是由浏览器同源策略限制的一类请求场景。</p><h3 id="什么是同源策略？"><a href="#什么是同源策略？" class="headerlink" title="什么是同源策略？"></a>什么是同源策略？</h3><p>同源策略、SOP(Same Origin policy) 是一种约定，由Netscape公司1995年引入浏览器，她是浏览器最核心也最基本的安全功能， 如果缺少了同源策略，浏览器很容易受到XSS、CSRF等攻击。所谓的同源是指"协议+域名+端口"三者相同，即便两个不同的域名指向同一ip地址，也非同源。</p><p>同源策略限制以下几种行为：</p><p>1、Cookie、LocalStorage 和 IndexDB 无法读取</p><p>2、DOM和 JS对象无法获取</p><p>3、Ajax请求不能发送</p><h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a>常见跨域场景</h3><pre><code>URL                                      说明                    是否允许通信http://www.demo.com/a.jshttp://www.demo.com/b.js         同一域名，不同文件或路径           允许http://www.demo.com/lab/c.jshttp://www.demo.com:8000/a.jshttp://www.demo.com/b.js         同一域名，不同端口                不允许http://www.demo.com/a.jshttps://www.demo.com/b.js        同一域名，不同协议                不允许http://www.demo.com/a.jshttp://127.0.0.1/b.js           域名和域名对应相同ip              不允许http://www.demo.com/a.jshttp://x.demo.com/b.js           主域相同，子域不同                不允许http://demo.com/c.jshttp://www.demo1.com/a.jshttp://www.demo2.com/b.js        不同域名                         不允许</code></pre><h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a>跨域解决方案</h3><ol><li>通过jsonp跨域</li><li>document.domain + iframe跨域</li><li>location.hash + iframe跨域</li><li>window.name + iframe跨域</li><li>postMessage跨域</li><li>跨域资源共享 (CORS)</li><li>nginx代理跨域</li><li>nodejs中间件代理跨域</li><li>WebSocket协议跨域</li></ol><h3 id="一-通过jsonp跨域"><a href="#一-通过jsonp跨域" class="headerlink" title="一. 通过jsonp跨域"></a>一. 通过jsonp跨域</h3><p>通常为了减轻web服务器的负载, 我们把js/css/img等静态资源分离到另一个独立域名的服务器上, 在html页面中再通过相应的标签从不同域名下加载静态资源, 而被浏览器允许, 基于此原理, 我们可以通过动态创建script, 再请求一个带有参数的网址实现跨域通讯.</p><ol><li><p>原生js实现:</p><pre class=" language-js"><code class="language-js"><span class="token keyword">let</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">'script'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>script<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">'text/javascript'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 传参并指定回到执行函数为myBack</span>script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">'http://127.0.0.1:8080/login?user=admin&amp;callback=myBack'</span><span class="token punctuation">;</span>document<span class="token punctuation">.</span>head<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 回调函数</span><span class="token keyword">function</span> <span class="token function">myBack</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>jQuery实现:</p><pre class=" language-js"><code class="language-js">$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  url<span class="token punctuation">:</span> <span class="token string">'http://127.0.0.1:8080/login'</span><span class="token punctuation">,</span>  type<span class="token punctuation">:</span> <span class="token string">'get'</span><span class="token punctuation">,</span>  dataType<span class="token punctuation">:</span> <span class="token string">'jsonp'</span><span class="token punctuation">,</span> <span class="token comment" spellcheck="true">// 请求方式为jsonp</span>  jsonpCallback<span class="token punctuation">:</span> <span class="token string">'myBack'</span><span class="token punctuation">,</span>  data<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>vue.js</p><pre class=" language-js"><code class="language-js"><span class="token keyword">this</span><span class="token punctuation">.</span>$http<span class="token punctuation">.</span><span class="token function">jsonp</span><span class="token punctuation">(</span><span class="token string">'http://127.0.0.1:8080/login'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>  params<span class="token punctuation">:</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  jsonp<span class="token punctuation">:</span> 'myBack<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span><span class="token punctuation">{</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>Nodejs服务器代码 :</p></li></ol><pre class=" language-js"><code class="language-js">   <span class="token comment" spellcheck="true">// 引入express 框架</span>   <span class="token keyword">const</span> express <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'express'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">let</span> app <span class="token operator">=</span> <span class="token function">express</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 测试不用jsonp的清求</span>   app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/user'</span><span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span> <span class="token punctuation">{</span>     res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token string">'user=name'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   app<span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token string">'/login'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span>req<span class="token punctuation">,</span> res<span class="token punctuation">)</span><span class="token punctuation">{</span>     <span class="token keyword">let</span> user <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>user<span class="token punctuation">;</span>     <span class="token keyword">let</span> fn <span class="token operator">=</span> req<span class="token punctuation">.</span>query<span class="token punctuation">.</span>callback<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// res.writeHead(200, {'Content-Type': 'text/javascript'});</span>     <span class="token comment" spellcheck="true">// res.write(fn + '(' + JSON.stringify(user) + ')');</span>     <span class="token comment" spellcheck="true">// res.end();</span>     res<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>fn <span class="token operator">+</span> <span class="token string">'('</span> <span class="token operator">+</span> JSON<span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">')'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token keyword">let</span> port <span class="token operator">=</span> <span class="token number">8080</span><span class="token punctuation">;</span>   app<span class="token punctuation">.</span><span class="token function">listen</span><span class="token punctuation">(</span>port<span class="token punctuation">,</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'web服务器开启成功,监听在'</span> <span class="token operator">+</span> port<span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以看到其实用jsonp还是挺简单的, 只需要和后端约定好把要返回的数据用预定好的函数包裹起来, 作为参数发送就行了.  但是缺点是只能用 <code>get</code>请求.</p><h3 id="二-document-domain-iframe-跨域"><a href="#二-document-domain-iframe-跨域" class="headerlink" title="二. document.domain + iframe 跨域"></a>二. document.domain + iframe 跨域</h3><p>此方案仅限主域名相同, 子域不同的跨域应用场景.</p><p>实现原理: 两个页面都通过js强制设置document.domain为基础主域, 就实现了同源.</p><p>父窗口 （<a href="http://www.demo.com/a.html）">http://www.demo.com/a.html）</a></p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>iframe</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>iframe<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://child.demo.com/b.html<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>iframe</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'dome.com'</span><span class="token punctuation">;</span>  <span class="token keyword">let</span> user <span class="token operator">=</span> <span class="token string">'admin'</span><span class="token punctuation">;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>子窗口: (<a href="http://child.demo.com/b.html">http://child.demo.com/b.html</a>)</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">></span></span><span class="token script language-javascript">    document<span class="token punctuation">.</span>domain <span class="token operator">=</span> <span class="token string">'dome.com'</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 获取父窗口中的变量</span>  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>window<span class="token punctuation">.</span>parent<span class="token punctuation">.</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// admin</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="三-location-hash-iframe跨域"><a href="#三-location-hash-iframe跨域" class="headerlink" title="三. location.hash + iframe跨域"></a>三. location.hash + iframe跨域</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.cnblogs.com/sdcs/p/8484905.html">博客</a></li></ul></script></li></ol>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的诞生</title>
      <link href="/2018/04/21/birth-of-javascript/"/>
      <url>/2018/04/21/birth-of-javascript/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>1994年，网景公司（Netscape）发布了Navigator浏览器0.9版。这是历史上第一个比较成熟的网络浏览器，轰动一时。但是，这个版本的浏览器只能用来浏览，不具备与访问者互动的能力。……<strong>网景公司急需一种网页脚本语言，使得浏览器可以与网页互动。</strong></p><p>就在这时，发生了另外一件大事：1995年Sun公司将Oak语言改名为Java，正式向市场推出。</p><p>网景公司动了心，决定与Sun公司结成联盟。它不仅允许Java程序以applet（小程序）的形式，直接在浏览器中运行；甚至还考虑直接将Java作为脚本语言嵌入网页，只是因为这样会使HTML网页过于复杂，后来才不得不放弃。</p><p><strong>总之，当时的形势就是，网景公司的整个管理层，都是Java语言的信徒，Sun公司完全介入网页脚本语言的决策。</strong>因此，Javascript后来就是网景和Sun两家公司一起携手推向市场的，这种语言被命名为”Java+script”并不是偶然的。</p><h2 id="Brendan-Eich（JavaScript之父）"><a href="#Brendan-Eich（JavaScript之父）" class="headerlink" title="Brendan Eich（JavaScript之父）"></a>Brendan Eich（JavaScript之父）</h2><p>网景公司在1995年4月招聘了他，是为了研究将Scheme语言作为网页脚本语言的可能性。Brendan Eich的主要方向和兴趣是函数式编程，以为进入新公司后，会主要与Scheme语言打交道。</p><p>仅仅一个月之后，<strong>1995年5月，网景公司做出决策，未来的网页脚本语言必须”看上去与Java足够相似”，但是比Java简单，使得非专业的网页作者也能很快上手</strong>。但是，他对Java一点兴趣也没有。为了应付公司安排的任务，他只用10天时间就把Javascript设计出来了。</p><p>由于设计时间太短，语言的一些细节考虑得不够严谨，导致后来很长一段时间，Javascript写出来的程序混乱不堪。如果Brendan Eich预见到，未来这种语言会成为互联网第一大语言，全世界有几百万学习者，他会不会多花一点时间呢？</p><p>总的来说，他的设计思路是这样的：<br>（1）借鉴C语言的基本语法；<br>（2）借鉴Java语言的数据类型和内存管理；<br>（3）借鉴Scheme语言，将函数提升到”第一等公民”（first class）的地位；<br>（4）借鉴<a href="http://en.wikipedia.org/wiki/Self_(programming_language)" target="_blank" rel="noopener">Self语言</a>，使用基于原型（prototype）的继承机制。</p><p>所以，<strong>Javascript语言实际上是两种语言风格的混合产物—-（简化的）函数式编程+（简化的）面向对象编程。</strong>这是由Brendan Eich（函数式编程）与网景公司（面向对象编程）共同决定的。</p><h2 id="Brendan-Eich的评价"><a href="#Brendan-Eich的评价" class="headerlink" title="Brendan Eich的评价"></a>Brendan Eich的评价</h2><p>如果不是公司的决策，Brendan Eich绝不可能把Java作为Javascript设计的原型。作为设计者，他一点也不喜欢自己的这个作品：</p><blockquote><p>“与其说我爱Javascript，不如说我恨它。它是C语言和Self语言一夜情的产物。<strong>十八世纪英国文学家约翰逊博士说得好：’它的优秀之处并非原创，它的原创之处并不优秀。’</strong>（the part that is good is not original, and the part that is original is not good.）”</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>会动的简历</title>
      <link href="/2018/04/08/animation-resume/"/>
      <url>/2018/04/08/animation-resume/</url>
      
        <content type="html"><![CDATA[<h1 id="会动的简历"><a href="#会动的简历" class="headerlink" title="会动的简历"></a>会动的简历</h1><blockquote><p>总结收获</p></blockquote><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>使用的是String.substring()的方法实现一定时间增加一个字符渲染到div中</li><li>这里用的是VUE的数据做到同步更新</li><li>Promise的用法：<br>使用的是 async function(){<pre><code>await 接 Promise对象</code></pre>}</li><li>Vue中无法直接添加style可以用div包含着把style标签放进去使之生效；</li></ul><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>1.<a href="https://github.com/markedjs/marked" target="_blank" rel="noopener">markedjs</a><br>把markdown语法的字段转为html代码字段</p><blockquote><p>  项目中用法：<br>  <code>marked(xxx)</code><br>xxx:md文本 转化为html语句</p><p>2.<a href="https://prismjs.com/" target="_blank" rel="noopener">prismjs</a><br>把需要高亮的代码加上类名<br>  项目中用法：<br>  <code>Prism.highlight(this.code, Prism.languages.css)</code><br>this.coded是要高亮的语句<br>Prims.languages.css使用高亮的方法变量</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> es6 </tag>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>browser-render</title>
      <link href="/2017/12/26/browser-render/"/>
      <url>/2017/12/26/browser-render/</url>
      
        <content type="html"><![CDATA[<h2 id="一、浏览器如何渲染网页"><a href="#一、浏览器如何渲染网页" class="headerlink" title="一、浏览器如何渲染网页"></a>一、浏览器如何渲染网页</h2><p><strong>概述：浏览器渲染一共有五步</strong></p><ol><li>处理 <code>HTML</code> 并构建 <code>DOM</code> 树。</li><li>处理 <code>CSS</code>构建 <code>CSSOM</code> 树。</li><li>将 <code>DOM</code> 与 <code>CSSOM</code> 合并成一个渲染树。</li><li>根据渲染树来布局，计算每个节点的位置。</li><li>调用 <code>GPU</code> 绘制，合成图层，显示在屏幕上</li></ol><blockquote><p>第四步和第五步是最耗时的部分，这两步合起来，就是我们通常所说的渲染</p></blockquote><p>具体如下图过程如下图所示</p><p><img src="/images/dom-render.png" alt="image.png"></p><p><img src="/images/composite-render.png" alt="image.png"></p><p><strong>渲染</strong></p><ul><li>网页生成的时候，至少会渲染一次</li><li>在用户访问的过程中，还会不断重新渲染</li></ul><blockquote><p>重新渲染需要重复之前的第四步(重新生成布局)+第五步(重新绘制)或者只有第五个步(重新绘制)</p></blockquote><ul><li>在构建 <code>CSSOM</code> 树时，会阻塞渲染，直至 <code>CSSOM</code>树构建完成。并且构建 <code>CSSOM</code> 树是一个十分消耗性能的过程，所以应该尽量保证层级扁平，减少过度层叠，越是具体的 <code>CSS</code> 选择器，执行速度越慢</li><li>当 <code>HTML</code> 解析到 <code>script</code> 标签时，会暂停构建 <code>DOM</code>，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 <code>JS</code> 文件。并且<code>CSS</code>也会影响 <code>JS</code> 的执行，只有当解析完样式表才会执行 <code>JS</code>，所以也可以认为这种情况下，<code>CSS</code> 也会暂停构建 <code>DOM</code></li></ul><h2 id="二、浏览器渲染五个阶段"><a href="#二、浏览器渲染五个阶段" class="headerlink" title="二、浏览器渲染五个阶段"></a>二、浏览器渲染五个阶段</h2><h3 id="2-1-第一步：解析HTML标签，构建DOM树"><a href="#2-1-第一步：解析HTML标签，构建DOM树" class="headerlink" title="2.1 第一步：解析HTML标签，构建DOM树"></a>2.1 第一步：解析HTML标签，构建DOM树</h3><blockquote><p>在这个阶段，引擎开始解析<code>html</code>，解析出来的结果会成为一棵<code>dom</code>树<br><code>dom</code>的目的至少有<code>2</code>个</p></blockquote><ul><li>作为下个阶段渲染树状图的输入</li><li>成为网页和脚本的交互界面。(最常用的就是<code>getElementById</code>等等)</li></ul><p><strong>当解析器到达script标签的时候，发生下面四件事情</strong></p><ol><li><code>html</code>解析器停止解析,</li><li>如果是外部脚本，就从外部网络获取脚本代码</li><li>将控制权交给<code>js</code>引擎，执行<code>js</code>代码</li><li>恢复<code>html</code>解析器的控制权</li></ol><blockquote><p>由此可以得到第一个结论1</p></blockquote><ul><li>由于<code>&lt;script&gt;</code>标签是阻塞解析的，将脚本放在网页尾部会加速代码渲染。</li><li><code>defer</code>和<code>async</code>属性也能有助于加载外部脚本。</li><li><code>defer</code>使得脚本会在<code>dom</code>完整构建之后执行；</li><li><code>async</code>标签使得脚本只有在完全<code>available</code>才执行，并且是以非阻塞的方式进行的</li></ul><h3 id="2-2-第二步：解析CSS标签，构建CSSOM树"><a href="#2-2-第二步：解析CSS标签，构建CSSOM树" class="headerlink" title="2.2 第二步：解析CSS标签，构建CSSOM树"></a>2.2 第二步：解析CSS标签，构建CSSOM树</h3><ul><li>我们已经看到<code>html</code>解析器碰到脚本后会做的事情，接下来我们看下<code>html</code>解析器碰到样式表会发生的情况</li><li><code>js</code>会阻塞解析，因为它会修改文档(<code>document</code>)。<code>css</code>不会修改文档的结构，如果这样的话，似乎看起来<code>css</code>样式不会阻塞浏览器<code>html</code>解析。但是事实上 <code>css</code>样式表是阻塞的。阻塞是指当<code>cssom</code>树建立好之后才会进行下一步的解析渲染</li></ul><p><strong>通过以下手段可以减轻cssom带来的影响</strong></p><ul><li>将<code>script</code>脚本放在页面底部</li><li>尽可能快的加载<code>css</code>样式表</li><li>将样式表按照<code>media type</code>和<code>media query</code>区分，这样有助于我们将<code>css</code>资源标记成非阻塞渲染的资源。</li><li>非阻塞的资源还是会被浏览器下载，只是优先级较低</li></ul><h3 id="2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）"><a href="#2-3-第三步：把DOM和CSSOM组合成渲染树（render-tree）" class="headerlink" title="2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）"></a>2.3 第三步：把DOM和CSSOM组合成渲染树（render tree）</h3><p><img src="/images/3renders.png" alt="image.png"></p><h3 id="2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"><a href="#2-4-第四步：在渲染树的基础上进行布局，计算每个节点的几何结构" class="headerlink" title="2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构"></a>2.4 第四步：在渲染树的基础上进行布局，计算每个节点的几何结构</h3><blockquote><p>布局(<code>layout</code>)：定位坐标和大小，是否换行，各种<code>position</code>, <code>overflow</code>, <code>z-index</code>属性</p></blockquote><h3 id="2-5-调用-GPU-绘制，合成图层，显示在屏幕上"><a href="#2-5-调用-GPU-绘制，合成图层，显示在屏幕上" class="headerlink" title="2.5 调用 GPU 绘制，合成图层，显示在屏幕上"></a>2.5 调用 GPU 绘制，合成图层，显示在屏幕上</h3><blockquote><p>将渲染树的各个节点绘制到屏幕上，这一步被称为绘制<code>painting</code></p></blockquote><h2 id="三、渲染优化相关"><a href="#三、渲染优化相关" class="headerlink" title="三、渲染优化相关"></a>三、渲染优化相关</h2><h3 id="3-1-Load-和-DOMContentLoaded-区别"><a href="#3-1-Load-和-DOMContentLoaded-区别" class="headerlink" title="3.1 Load 和 DOMContentLoaded 区别"></a>3.1 Load 和 DOMContentLoaded 区别</h3><ul><li><code>Load</code> 事件触发代表页面中的 <code>DOM</code>，<code>CSS</code>，<code>JS</code>，图片已经全部加载完毕。</li><li><code>DOMContentLoaded</code> 事件触发代表初始的 <code>HTML</code> 被完全加载和解析，不需要等待 <code>CSS</code>，<code>JS</code>，图片加载</li></ul><h3 id="3-2-图层"><a href="#3-2-图层" class="headerlink" title="3.2 图层"></a>3.2 图层</h3><blockquote><p>一般来说，可以把普通文档流看成一个图层。特定的属性可以生成一个新的图层。不同的图层渲染互不影响，所以对于某些频繁需要渲染的建议单独生成一个新图层，提高性能。但也不能生成过多的图层，会引起反作用。</p></blockquote><p><strong>通过以下几个常用属性可以生成新图层</strong></p><ul><li><code>3D</code> 变换：<code>translate3d</code>、<code>translateZ</code></li><li><code>will-change</code></li><li><code>video</code>、<code>iframe</code> 标签</li><li>通过动画实现的 <code>opacity</code> 动画转换</li><li><code>position: fixed</code></li></ul><h3 id="3-3-重绘（Repaint）和回流（Reflow）"><a href="#3-3-重绘（Repaint）和回流（Reflow）" class="headerlink" title="3.3 重绘（Repaint）和回流（Reflow）"></a>3.3 重绘（Repaint）和回流（Reflow）</h3><blockquote><p>重绘和回流是渲染步骤中的一小节，但是这两个步骤对于性能影响很大</p></blockquote><ul><li>重绘是当节点需要更改外观而不会影响布局的，比如改变 <code>color</code> 就叫称为重绘</li><li>回流是布局或者几何属性需要改变就称为回流。</li></ul><blockquote><p>回流必定会发生重绘，重绘不一定会引发回流。回流所需的成本比重绘高的多，改变深层次的节点很可能导致父节点的一系列回流</p></blockquote><p><strong>以下几个动作可能会导致性能问题</strong></p><ul><li>改变 <code>window</code> 大小</li><li>改变字体</li><li>添加或删除样式</li><li>文字改变</li><li>定位或者浮动</li><li>盒模型</li></ul><p><strong>很多人不知道的是，重绘和回流其实和 Event loop 有关</strong></p><ul><li>当 <code>Event loop</code> 执行完<code>Microtasks</code> 后，会判断 <code>document</code> 是否需要更新。因为浏览器是 <code>60Hz</code> 的刷新率，每 <code>16ms</code> 才会更新一次。</li><li>然后判断是否有 <code>resize</code> 或者 <code>scroll</code> ，有的话会去触发事件，所以 <code>resize</code> 和 <code>scroll</code> 事件也是至少 <code>16ms</code>才会触发一次，并且自带节流功能。</li><li>判断是否触发了 <code>media query</code></li><li>更新动画并且发送事件</li><li>判断是否有全屏操作事件</li><li>执行 <code>requestAnimationFrame</code> 回调</li><li>执行 <code>IntersectionObserver</code> 回调，该方法用于判断元素是否可见，可以用于懒加载上，但是兼容性不好</li><li>更新界面</li><li>以上就是一帧中可能会做的事情。如果在一帧中有空闲时间，就会去执行 <code>requestIdleCallback</code> 回调</li></ul><p><strong>常见的引起重绘的属性</strong></p><ul><li><code>color</code></li><li><code>border-style</code>    </li><li><code>visibility</code>  </li><li><code>background</code></li><li><code>text-decoration</code> </li><li><code>background-image</code>    </li><li><code>background-position</code> </li><li><code>background-repeat</code></li><li><code>outline-color</code>   </li><li><code>outline</code> </li><li><code>outline-style</code>   </li><li><code>border-radius</code></li><li><code>outline-width</code>   </li><li><code>box-shadow</code>  </li><li><code>background-size</code> </li></ul><h3 id="3-4-常见引起回流属性和方法"><a href="#3-4-常见引起回流属性和方法" class="headerlink" title="3.4 常见引起回流属性和方法"></a>3.4 常见引起回流属性和方法</h3><blockquote><p>任何会改变元素几何信息(元素的位置和尺寸大小)的操作，都会触发重排，下面列一些栗子</p></blockquote><ul><li>添加或者删除可见的<code>DOM</code>元素；</li><li>元素尺寸改变——边距、填充、边框、宽度和高度</li><li>内容变化，比如用户在<code>input</code>框中输入文字</li><li>浏览器窗口尺寸改变——<code>resize</code>事件发生时</li><li>计算 <code>offsetWidth</code> 和 <code>offsetHeight</code> 属性</li><li>设置 <code>style</code> 属性的值</li></ul><p><strong>回流影响的范围</strong></p><blockquote><p>由于浏览器渲染界面是基于流失布局模型的，所以触发重排时会对周围DOM重新排列，影响的范围有两种</p></blockquote><ul><li>全局范围：从根节点<code>html</code>开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>全局范围回流</strong></p><p>​```html</p><body>  <div class="hello">    <h4>hello</h4>    <p><strong>Name:</strong>BDing</p>    <h5>male</h5>    <ol>      <li>coding</li>      <li>loving</li>    </ol>  </div></body>​```<blockquote><p>当<code>p</code>节点上发生<code>reflow</code>时，<code>hello</code>和<code>body</code>也会重新渲染，甚至<code>h5</code>和<code>ol</code>都会收到影响</p></blockquote><p><strong>局部范围回流</strong></p><blockquote><p>用局部布局来解释这种现象：把一个<code>dom</code>的宽高之类的几何信息定死，然后在<code>dom</code>内部触发重排，就只会重新渲染该<code>dom</code>内部的元素，而不会影响到外界</p></blockquote><h3 id="3-5-减少重绘和回流"><a href="#3-5-减少重绘和回流" class="headerlink" title="3.5 减少重绘和回流"></a>3.5 减少重绘和回流</h3><blockquote><p>使用 <code>translate</code> 替代 <code>top</code></p></blockquote><p>​```html</p><div class="test"></div><style>    .test {        position: absolute;        top: 10px;        width: 100px;        height: 100px;        background: red;    }</style><script>    setTimeout(() => {        // 引起回流        document.querySelector('.test').style.top = '100px'    }, 1000)</script>​```<ul><li>使用 <code>visibility</code> 替换 <code>display: none</code> ，因为前者只会引起重绘，后者会引发回流（改变了布局）</li><li>把 <code>DOM</code> 离线后修改，比如：先把 <code>DOM</code> 给 <code>display:none</code> (有一次 <code>Reflow)</code>，然后你修改<code>100</code>次，然后再把它显示出来</li><li>不要把 <code>DOM</code> 结点的属性值放在一个循环里当成循环里的变量</li></ul><p>​<code>jsfor(let i = 0; i &lt; 1000; i++) {​    // 获取 offsetTop 会导致回流，因为需要去获取正确的值​    console.log(document.querySelector(&#39;.test&#39;).style.offsetTop)}​</code></p><ul><li>不要使用 <code>table</code> 布局，可能很小的一个小改动会造成整个 <code>table</code> 的重新布局</li><li>动画实现的速度的选择，动画速度越快，回流次数越多，也可以选择使用 <code>requestAnimationFrame</code></li><li><code>CSS</code>选择符从右往左匹配查找，避免 <code>DOM</code>深度过深</li><li>将频繁运行的动画变为图层，图层能够阻止该节点回流影响别的元素。比如对于 <code>video</code>标签，浏览器会自动将该节点变为图层。</li></ul><p><img src="/images/layout-video-render.png" alt="image.png"></p><blockquote><p><a href="http://blog.poetries.top/2018/01/12/fed-performance-optimization/#%E5%85%AD%E3%80%81%E9%87%8D%E7%BB%98%E4%B8%8E%E5%9B%9E%E6%B5%81" target="_blank" rel="noopener">重绘与回流</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Front-End </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML重难点</title>
      <link href="/2017/08/26/HTML%E9%87%8D%E9%9A%BE%E7%82%B9/"/>
      <url>/2017/08/26/HTML%E9%87%8D%E9%9A%BE%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="HTML-重难点"><a href="#HTML-重难点" class="headerlink" title="HTML 重难点"></a>HTML 重难点</h1><h2 id="a标签-anchor"><a href="#a标签-anchor" class="headerlink" title="a标签 (anchor)"></a>a标签 (anchor)</h2><blockquote><p>一个特别常用的标签, 可以创建通向其他网页、文件、同一页面内的位置、电子邮箱、电话或任何其他URL的超链接</p></blockquote><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><h4 id="href-取值"><a href="#href-取值" class="headerlink" title="href 取值"></a>href 取值</h4><ul><li>网址 <code>//google.com</code> 无协议： 会继承当前的协议, 注：http的根路径是根据服务开启的目录</li><li>伪协议： 可以执行javascript代码，如<code>href=javascript:alert(1);</code><ul><li>一般用于: href=”javascript:;’’ 什么都不做</li><li>mailto:邮箱, 会调用邮箱客户端</li><li>tel: 手机号，会调用手机自带的电话</li></ul></li><li>id锚点：页面调到此id位置</li></ul><h4 id="target-取值"><a href="#target-取值" class="headerlink" title="target 取值"></a>target 取值</h4><ul><li>_self(默认): 当前页面打开</li><li>_blank: 空白标签打开</li><li>_parent: 配合iframe时在上层iframe中打开</li><li>_top: 配合iframe时在顶层iframe中打开</li><li>window和iframe的name: 在指定的window或iframe中打开</li><li></li></ul><h2 id="table标签"><a href="#table标签" class="headerlink" title="table标签"></a>table标签</h2><ul><li>thead: 表格的头部</li><li>tbody: 表格的身体</li><li>tfoot: 表格的底部</li><li>tr: table row 行</li><li>td: table data  放数据的</li><li>th: table header 会默认加粗, 和td同一级(也是放数据的不过一般是表头)</li></ul><h3 id="我的table-reset"><a href="#我的table-reset" class="headerlink" title="我的table reset"></a>我的table reset</h3><pre class=" language-css"><code class="language-css">  <span class="token property">border-collapse</span><span class="token punctuation">:</span> collapse<span class="token punctuation">;</span>      <span class="token property">border-spacing</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><h2 id="img标签"><a href="#img标签" class="headerlink" title="img标签"></a>img标签</h2><blockquote><p>发送get请求,展示一张图片</p></blockquote><h3 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h3><ul><li>alt: 在图片无法显示的时候展示的文字</li><li>src: source的缩写, get请求资源路径</li><li>height: 设置高度, 不需要加px</li></ul><h3 id="响应式"><a href="#响应式" class="headerlink" title="响应式"></a>响应式</h3><p>max-width: 100%</p><h2 id="form表单"><a href="#form表单" class="headerlink" title="form表单"></a>form表单</h2><blockquote><p>发送get或者post请求(form只能设置这两个方式), 然后刷新页面</p></blockquote><p><strong>注意 :</strong></p><ol><li>autocomplete 属性设置在form上,给 input 添加<code>name=username</code>之类的name属性后才会生效哦</li><li>一般不监听 input 的click事件, 一般监听 change 或者 blur</li><li>form里边的input 要有name</li><li>form中要放一个type=submit才能出发submit事件</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML入门笔记1</title>
      <link href="/2017/04/19/html-primer-note-1/"/>
      <url>/2017/04/19/html-primer-note-1/</url>
      
        <content type="html"><![CDATA[<h2 id="发明者"><a href="#发明者" class="headerlink" title="发明者"></a>发明者</h2><p>提姆·柏纳-李（Tim Berners-Lee）一位英国计算机科学家，他的发明叫全球资讯网（World Wid Web）</p><h2 id="HTML如何起手"><a href="#HTML如何起手" class="headerlink" title="HTML如何起手"></a>HTML如何起手</h2><p>进入一个编辑器保存一个文件后缀为html结尾的文件， 开始编辑输入<code>!</code>然后按<code>TAB</code>， 编辑器会自动补全， 如果要开发国内的网页推荐把html标签的lang属性改为<code>zh-CN</code>或者<code>zh-Hans</code>都可以。</p><p><strong><em>注意</em></strong></p><ul><li><meta charset="UTF-8"> 这里必须是 UTF-8</li><li>移动端meta<code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot;&gt;</code></li><li>让IE浏览器用最新的内核来渲染页面 <code>&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt;</code></li></ul><h2 id="常用标签"><a href="#常用标签" class="headerlink" title="常用标签"></a>常用标签</h2><p>标签主要分两类，用来布局的表示一块一块的是章节标签。 另一类是用来表示内容的内容标签</p><h3 id="章节标签"><a href="#章节标签" class="headerlink" title="章节标签"></a>章节标签</h3><ul><li>section：表示一个包含在HTML文档中的独立部分，它没有更具体的语义元素来表示，一般会包含标题</li><li>article：表示网站的独立结构可以再次嵌套article，它可能是论坛帖子、杂志或新闻文章、博客、用户提交的评论、交互式组件</li></ul><h2 id="常见属性"><a href="#常见属性" class="headerlink" title="常见属性"></a>常见属性</h2><blockquote><p>所有的标签都是有属性的。</p></blockquote><ul><li>class：类属性</li><li>id: id属性，不能保证唯一性（因为不会报错）， id可以在js中直接用id名获取到对应的节点（parent，top等window属性除外）</li><li>title：当文字显示不全的时候可以在title中书写所有的文字， hover的时候可以看到</li><li>hidden：添加了这个属性，元素会不可见，不同于css的display</li><li>contenteditable：当属性值为true的时候元素可以编辑</li><li>tabindex：页面中按tab键后的跳转元素的优先级， 0是最后访问，-1不可被访问</li><li>style：行内样式</li></ul><h2 id="css-reset"><a href="#css-reset" class="headerlink" title="css reset"></a>css reset</h2><p>在没有CSS的年代浏览器为了让页面更好看，自带了需要默认样式，现在已经不符合我们的需求了所以我们需要重置。<br>如何看哪些是浏览器的默认样式呢，打开开发者工具点击要查看的元素找到<code>style</code>找到<code>user agent stylesheet</code>就是了</p><h3 id="我的css-reset"><a href="#我的css-reset" class="headerlink" title="我的css reset"></a>我的css reset</h3><pre class=" language-css"><code class="language-css"><span class="token comment" spellcheck="true">/**我的css reset**/</span><span class="token selector">*</span><span class="token punctuation">{</span><span class="token property">margin</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token property">padding</span><span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">*<span class="token pseudo-element">::after</span>,*<span class="token pseudo-element">::before</span></span><span class="token punctuation">{</span><span class="token property">box-sizing</span><span class="token punctuation">:</span> border-box<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.clearfix</span><span class="token pseudo-element">::after</span></span><span class="token punctuation">{</span>  <span class="token property">content</span><span class="token punctuation">:</span> <span class="token string">''</span><span class="token punctuation">;</span>  <span class="token property">display</span><span class="token punctuation">:</span> block<span class="token punctuation">;</span>  <span class="token property">clear</span><span class="token punctuation">:</span> both<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector"><span class="token class">.clearfix</span></span><span class="token punctuation">{</span>  <span class="token property">zoom</span><span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">a</span><span class="token punctuation">{</span><span class="token property">text-decoration</span><span class="token punctuation">:</span> none<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token selector">img</span><span class="token punctuation">{</span>  <span class="token property">max-width</span><span class="token punctuation">:</span> <span class="token number">100%</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
